/*
 * (C) Copyright IBM Corp. 2019, 2021
 *
 * SPDX-License-Identifier: Apache-2.0
 */

package com.ibm.fhir.model.parser;

import static com.ibm.fhir.model.util.XMLSupport.FHIR_NS_URI;
import static com.ibm.fhir.model.util.XMLSupport.XHTML_NS_URI;
import static com.ibm.fhir.model.util.XMLSupport.checkElementOrder;
import static com.ibm.fhir.model.util.XMLSupport.createStreamReaderDelegate;
import static com.ibm.fhir.model.util.XMLSupport.isResourceContainer;
import static com.ibm.fhir.model.util.XMLSupport.parseDiv;
import static com.ibm.fhir.model.util.XMLSupport.requireNamespace;

import java.io.InputStream;
import java.io.Reader;
import java.util.Stack;
import java.util.StringJoiner;

import javax.annotation.Generated;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;

import com.ibm.fhir.core.ResourceType;

import com.ibm.fhir.model.parser.exception.FHIRParserException;
import com.ibm.fhir.model.resource.*;
import com.ibm.fhir.model.type.*;
import com.ibm.fhir.model.type.code.*;
import com.ibm.fhir.model.type.Boolean;
import com.ibm.fhir.model.type.Integer;
import com.ibm.fhir.model.type.String;
import com.ibm.fhir.model.util.XMLSupport.StreamReaderDelegate;

import net.jcip.annotations.NotThreadSafe;

@NotThreadSafe
@Generated("com.ibm.fhir.tools.CodeGenerator")
public class FHIRXMLParser extends FHIRAbstractParser {
    public static boolean DEBUG = false;

    private final Stack<java.lang.String> stack = new Stack<>();

    FHIRXMLParser() {
        // only visible to subclasses or classes/interfaces in the same package (e.g. FHIRParser)
    }

    @SuppressWarnings("unchecked")
    @Override
    public <T extends Resource> T parse(InputStream in) throws FHIRParserException {
        try (StreamReaderDelegate delegate = createStreamReaderDelegate(in)) {
            reset();
            while (delegate.hasNext()) {
                int eventType = delegate.next();
                switch (eventType) {
                case XMLStreamReader.START_ELEMENT:
                    requireNamespace(delegate, FHIR_NS_URI);
                    return (T) parseResource(getResourceType(delegate), delegate, -1);
                }
            }
            throw new XMLStreamException("Unexpected end of stream");
        } catch (Exception e) {
            throw new FHIRParserException(e.getMessage(), getPath(), e);
        }
    }

    @SuppressWarnings("unchecked")
    @Override
    public <T extends Resource> T parse(Reader reader) throws FHIRParserException {
        try (StreamReaderDelegate delegate = createStreamReaderDelegate(reader)) {
            reset();
            while (delegate.hasNext()) {
                int eventType = delegate.next();
                switch (eventType) {
                case XMLStreamReader.START_ELEMENT:
                    requireNamespace(delegate, FHIR_NS_URI);
                    return (T) parseResource(getResourceType(delegate), delegate, -1);
                }
            }
            throw new XMLStreamException("Unexpected end of stream");
        } catch (Exception e) {
            throw new FHIRParserException(e.getMessage(), getPath(), e);
        }
    }

    private void reset() {
        stack.clear();
    }

    private Resource parseResource(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        if (isResourceContainer(elementName)) {
            reader.nextTag();
        }
        java.lang.String resourceType = getResourceType(reader);
        switch (resourceType) {
        case "Account":
            return parseAccount(elementName, reader, elementIndex);
        case "ActivityDefinition":
            return parseActivityDefinition(elementName, reader, elementIndex);
        case "AdministrableProductDefinition":
            return parseAdministrableProductDefinition(elementName, reader, elementIndex);
        case "AdverseEvent":
            return parseAdverseEvent(elementName, reader, elementIndex);
        case "AllergyIntolerance":
            return parseAllergyIntolerance(elementName, reader, elementIndex);
        case "Appointment":
            return parseAppointment(elementName, reader, elementIndex);
        case "AppointmentResponse":
            return parseAppointmentResponse(elementName, reader, elementIndex);
        case "AuditEvent":
            return parseAuditEvent(elementName, reader, elementIndex);
        case "Basic":
            return parseBasic(elementName, reader, elementIndex);
        case "Binary":
            return parseBinary(elementName, reader, elementIndex);
        case "BiologicallyDerivedProduct":
            return parseBiologicallyDerivedProduct(elementName, reader, elementIndex);
        case "BodyStructure":
            return parseBodyStructure(elementName, reader, elementIndex);
        case "Bundle":
            return parseBundle(elementName, reader, elementIndex);
        case "CapabilityStatement":
            return parseCapabilityStatement(elementName, reader, elementIndex);
        case "CarePlan":
            return parseCarePlan(elementName, reader, elementIndex);
        case "CareTeam":
            return parseCareTeam(elementName, reader, elementIndex);
        case "CatalogEntry":
            return parseCatalogEntry(elementName, reader, elementIndex);
        case "ChargeItem":
            return parseChargeItem(elementName, reader, elementIndex);
        case "ChargeItemDefinition":
            return parseChargeItemDefinition(elementName, reader, elementIndex);
        case "Citation":
            return parseCitation(elementName, reader, elementIndex);
        case "Claim":
            return parseClaim(elementName, reader, elementIndex);
        case "ClaimResponse":
            return parseClaimResponse(elementName, reader, elementIndex);
        case "ClinicalImpression":
            return parseClinicalImpression(elementName, reader, elementIndex);
        case "ClinicalUseDefinition":
            return parseClinicalUseDefinition(elementName, reader, elementIndex);
        case "CodeSystem":
            return parseCodeSystem(elementName, reader, elementIndex);
        case "Communication":
            return parseCommunication(elementName, reader, elementIndex);
        case "CommunicationRequest":
            return parseCommunicationRequest(elementName, reader, elementIndex);
        case "CompartmentDefinition":
            return parseCompartmentDefinition(elementName, reader, elementIndex);
        case "Composition":
            return parseComposition(elementName, reader, elementIndex);
        case "ConceptMap":
            return parseConceptMap(elementName, reader, elementIndex);
        case "Condition":
            return parseCondition(elementName, reader, elementIndex);
        case "Consent":
            return parseConsent(elementName, reader, elementIndex);
        case "Contract":
            return parseContract(elementName, reader, elementIndex);
        case "Coverage":
            return parseCoverage(elementName, reader, elementIndex);
        case "CoverageEligibilityRequest":
            return parseCoverageEligibilityRequest(elementName, reader, elementIndex);
        case "CoverageEligibilityResponse":
            return parseCoverageEligibilityResponse(elementName, reader, elementIndex);
        case "DetectedIssue":
            return parseDetectedIssue(elementName, reader, elementIndex);
        case "Device":
            return parseDevice(elementName, reader, elementIndex);
        case "DeviceDefinition":
            return parseDeviceDefinition(elementName, reader, elementIndex);
        case "DeviceMetric":
            return parseDeviceMetric(elementName, reader, elementIndex);
        case "DeviceRequest":
            return parseDeviceRequest(elementName, reader, elementIndex);
        case "DeviceUseStatement":
            return parseDeviceUseStatement(elementName, reader, elementIndex);
        case "DiagnosticReport":
            return parseDiagnosticReport(elementName, reader, elementIndex);
        case "DocumentManifest":
            return parseDocumentManifest(elementName, reader, elementIndex);
        case "DocumentReference":
            return parseDocumentReference(elementName, reader, elementIndex);
        case "Encounter":
            return parseEncounter(elementName, reader, elementIndex);
        case "Endpoint":
            return parseEndpoint(elementName, reader, elementIndex);
        case "EnrollmentRequest":
            return parseEnrollmentRequest(elementName, reader, elementIndex);
        case "EnrollmentResponse":
            return parseEnrollmentResponse(elementName, reader, elementIndex);
        case "EpisodeOfCare":
            return parseEpisodeOfCare(elementName, reader, elementIndex);
        case "EventDefinition":
            return parseEventDefinition(elementName, reader, elementIndex);
        case "Evidence":
            return parseEvidence(elementName, reader, elementIndex);
        case "EvidenceReport":
            return parseEvidenceReport(elementName, reader, elementIndex);
        case "EvidenceVariable":
            return parseEvidenceVariable(elementName, reader, elementIndex);
        case "ExampleScenario":
            return parseExampleScenario(elementName, reader, elementIndex);
        case "ExplanationOfBenefit":
            return parseExplanationOfBenefit(elementName, reader, elementIndex);
        case "FamilyMemberHistory":
            return parseFamilyMemberHistory(elementName, reader, elementIndex);
        case "Flag":
            return parseFlag(elementName, reader, elementIndex);
        case "Goal":
            return parseGoal(elementName, reader, elementIndex);
        case "GraphDefinition":
            return parseGraphDefinition(elementName, reader, elementIndex);
        case "Group":
            return parseGroup(elementName, reader, elementIndex);
        case "GuidanceResponse":
            return parseGuidanceResponse(elementName, reader, elementIndex);
        case "HealthcareService":
            return parseHealthcareService(elementName, reader, elementIndex);
        case "ImagingStudy":
            return parseImagingStudy(elementName, reader, elementIndex);
        case "Immunization":
            return parseImmunization(elementName, reader, elementIndex);
        case "ImmunizationEvaluation":
            return parseImmunizationEvaluation(elementName, reader, elementIndex);
        case "ImmunizationRecommendation":
            return parseImmunizationRecommendation(elementName, reader, elementIndex);
        case "ImplementationGuide":
            return parseImplementationGuide(elementName, reader, elementIndex);
        case "Ingredient":
            return parseIngredient(elementName, reader, elementIndex);
        case "InsurancePlan":
            return parseInsurancePlan(elementName, reader, elementIndex);
        case "Invoice":
            return parseInvoice(elementName, reader, elementIndex);
        case "Library":
            return parseLibrary(elementName, reader, elementIndex);
        case "Linkage":
            return parseLinkage(elementName, reader, elementIndex);
        case "List":
            return parseList(elementName, reader, elementIndex);
        case "Location":
            return parseLocation(elementName, reader, elementIndex);
        case "ManufacturedItemDefinition":
            return parseManufacturedItemDefinition(elementName, reader, elementIndex);
        case "Measure":
            return parseMeasure(elementName, reader, elementIndex);
        case "MeasureReport":
            return parseMeasureReport(elementName, reader, elementIndex);
        case "Media":
            return parseMedia(elementName, reader, elementIndex);
        case "Medication":
            return parseMedication(elementName, reader, elementIndex);
        case "MedicationAdministration":
            return parseMedicationAdministration(elementName, reader, elementIndex);
        case "MedicationDispense":
            return parseMedicationDispense(elementName, reader, elementIndex);
        case "MedicationKnowledge":
            return parseMedicationKnowledge(elementName, reader, elementIndex);
        case "MedicationRequest":
            return parseMedicationRequest(elementName, reader, elementIndex);
        case "MedicationStatement":
            return parseMedicationStatement(elementName, reader, elementIndex);
        case "MedicinalProductDefinition":
            return parseMedicinalProductDefinition(elementName, reader, elementIndex);
        case "MessageDefinition":
            return parseMessageDefinition(elementName, reader, elementIndex);
        case "MessageHeader":
            return parseMessageHeader(elementName, reader, elementIndex);
        case "MolecularSequence":
            return parseMolecularSequence(elementName, reader, elementIndex);
        case "NamingSystem":
            return parseNamingSystem(elementName, reader, elementIndex);
        case "NutritionOrder":
            return parseNutritionOrder(elementName, reader, elementIndex);
        case "NutritionProduct":
            return parseNutritionProduct(elementName, reader, elementIndex);
        case "Observation":
            return parseObservation(elementName, reader, elementIndex);
        case "ObservationDefinition":
            return parseObservationDefinition(elementName, reader, elementIndex);
        case "OperationDefinition":
            return parseOperationDefinition(elementName, reader, elementIndex);
        case "OperationOutcome":
            return parseOperationOutcome(elementName, reader, elementIndex);
        case "Organization":
            return parseOrganization(elementName, reader, elementIndex);
        case "OrganizationAffiliation":
            return parseOrganizationAffiliation(elementName, reader, elementIndex);
        case "PackagedProductDefinition":
            return parsePackagedProductDefinition(elementName, reader, elementIndex);
        case "Parameters":
            return parseParameters(elementName, reader, elementIndex);
        case "Patient":
            return parsePatient(elementName, reader, elementIndex);
        case "PaymentNotice":
            return parsePaymentNotice(elementName, reader, elementIndex);
        case "PaymentReconciliation":
            return parsePaymentReconciliation(elementName, reader, elementIndex);
        case "Person":
            return parsePerson(elementName, reader, elementIndex);
        case "PlanDefinition":
            return parsePlanDefinition(elementName, reader, elementIndex);
        case "Practitioner":
            return parsePractitioner(elementName, reader, elementIndex);
        case "PractitionerRole":
            return parsePractitionerRole(elementName, reader, elementIndex);
        case "Procedure":
            return parseProcedure(elementName, reader, elementIndex);
        case "Provenance":
            return parseProvenance(elementName, reader, elementIndex);
        case "Questionnaire":
            return parseQuestionnaire(elementName, reader, elementIndex);
        case "QuestionnaireResponse":
            return parseQuestionnaireResponse(elementName, reader, elementIndex);
        case "RegulatedAuthorization":
            return parseRegulatedAuthorization(elementName, reader, elementIndex);
        case "RelatedPerson":
            return parseRelatedPerson(elementName, reader, elementIndex);
        case "RequestGroup":
            return parseRequestGroup(elementName, reader, elementIndex);
        case "ResearchDefinition":
            return parseResearchDefinition(elementName, reader, elementIndex);
        case "ResearchElementDefinition":
            return parseResearchElementDefinition(elementName, reader, elementIndex);
        case "ResearchStudy":
            return parseResearchStudy(elementName, reader, elementIndex);
        case "ResearchSubject":
            return parseResearchSubject(elementName, reader, elementIndex);
        case "RiskAssessment":
            return parseRiskAssessment(elementName, reader, elementIndex);
        case "Schedule":
            return parseSchedule(elementName, reader, elementIndex);
        case "SearchParameter":
            return parseSearchParameter(elementName, reader, elementIndex);
        case "ServiceRequest":
            return parseServiceRequest(elementName, reader, elementIndex);
        case "Slot":
            return parseSlot(elementName, reader, elementIndex);
        case "Specimen":
            return parseSpecimen(elementName, reader, elementIndex);
        case "SpecimenDefinition":
            return parseSpecimenDefinition(elementName, reader, elementIndex);
        case "StructureDefinition":
            return parseStructureDefinition(elementName, reader, elementIndex);
        case "StructureMap":
            return parseStructureMap(elementName, reader, elementIndex);
        case "Subscription":
            return parseSubscription(elementName, reader, elementIndex);
        case "SubscriptionStatus":
            return parseSubscriptionStatus(elementName, reader, elementIndex);
        case "SubscriptionTopic":
            return parseSubscriptionTopic(elementName, reader, elementIndex);
        case "Substance":
            return parseSubstance(elementName, reader, elementIndex);
        case "SubstanceDefinition":
            return parseSubstanceDefinition(elementName, reader, elementIndex);
        case "SupplyDelivery":
            return parseSupplyDelivery(elementName, reader, elementIndex);
        case "SupplyRequest":
            return parseSupplyRequest(elementName, reader, elementIndex);
        case "Task":
            return parseTask(elementName, reader, elementIndex);
        case "TerminologyCapabilities":
            return parseTerminologyCapabilities(elementName, reader, elementIndex);
        case "TestReport":
            return parseTestReport(elementName, reader, elementIndex);
        case "TestScript":
            return parseTestScript(elementName, reader, elementIndex);
        case "ValueSet":
            return parseValueSet(elementName, reader, elementIndex);
        case "VerificationResult":
            return parseVerificationResult(elementName, reader, elementIndex);
        case "VisionPrescription":
            return parseVisionPrescription(elementName, reader, elementIndex);
        }
        return null;
    }

    private Account parseAccount(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Account.Builder builder = Account.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, subjectElementIndex = 0, coverageElementIndex = 0, guarantorElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((AccountStatus) parseString(AccountStatus.builder(), "status", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 10, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 11, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 12, position, true);
                    builder.subject(parseReference("subject", reader, subjectElementIndex++));
                    break;
                case "servicePeriod":
                    position = checkElementOrder("servicePeriod", 13, position, false);
                    builder.servicePeriod(parsePeriod("servicePeriod", reader, -1));
                    break;
                case "coverage":
                    position = checkElementOrder("coverage", 14, position, true);
                    builder.coverage(parseAccountCoverage("coverage", reader, coverageElementIndex++));
                    break;
                case "owner":
                    position = checkElementOrder("owner", 15, position, false);
                    builder.owner(parseReference("owner", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 16, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "guarantor":
                    position = checkElementOrder("guarantor", 17, position, true);
                    builder.guarantor(parseAccountGuarantor("guarantor", reader, guarantorElementIndex++));
                    break;
                case "partOf":
                    position = checkElementOrder("partOf", 18, position, false);
                    builder.partOf(parseReference("partOf", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Account.Coverage parseAccountCoverage(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Account.Coverage.Builder builder = Account.Coverage.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "coverage":
                    position = checkElementOrder("coverage", 2, position, false);
                    builder.coverage(parseReference("coverage", reader, -1));
                    break;
                case "priority":
                    position = checkElementOrder("priority", 3, position, false);
                    builder.priority((PositiveInt) parseInteger(PositiveInt.builder(), "priority", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Account.Guarantor parseAccountGuarantor(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Account.Guarantor.Builder builder = Account.Guarantor.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "party":
                    position = checkElementOrder("party", 2, position, false);
                    builder.party(parseReference("party", reader, -1));
                    break;
                case "onHold":
                    position = checkElementOrder("onHold", 3, position, false);
                    builder.onHold(parseBoolean("onHold", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 4, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ActivityDefinition parseActivityDefinition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ActivityDefinition.Builder builder = ActivityDefinition.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, contactElementIndex = 0, useContextElementIndex = 0, jurisdictionElementIndex = 0, topicElementIndex = 0, authorElementIndex = 0, editorElementIndex = 0, reviewerElementIndex = 0, endorserElementIndex = 0, relatedArtifactElementIndex = 0, libraryElementIndex = 0, participantElementIndex = 0, dosageElementIndex = 0, bodySiteElementIndex = 0, specimenRequirementElementIndex = 0, observationRequirementElementIndex = 0, observationResultRequirementElementIndex = 0, dynamicValueElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 10, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 11, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 12, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "subtitle":
                    position = checkElementOrder("subtitle", 13, position, false);
                    builder.subtitle(parseString("subtitle", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 14, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 15, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "subjectCodeableConcept":
                    position = checkElementOrder("subject[x]", 16, position, false);
                    builder.subject(parseCodeableConcept("subjectCodeableConcept", reader, -1));
                    break;
                case "subjectReference":
                    position = checkElementOrder("subject[x]", 16, position, false);
                    builder.subject(parseReference("subjectReference", reader, -1));
                    break;
                case "subjectCanonical":
                    position = checkElementOrder("subject[x]", 16, position, false);
                    builder.subject((Canonical) parseUri(Canonical.builder(), "subjectCanonical", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 17, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 18, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 19, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 20, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 21, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 22, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 23, position, false);
                    builder.purpose((Markdown) parseString(Markdown.builder(), "purpose", reader, -1));
                    break;
                case "usage":
                    position = checkElementOrder("usage", 24, position, false);
                    builder.usage(parseString("usage", reader, -1));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 25, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                case "approvalDate":
                    position = checkElementOrder("approvalDate", 26, position, false);
                    builder.approvalDate(parseDate("approvalDate", reader, -1));
                    break;
                case "lastReviewDate":
                    position = checkElementOrder("lastReviewDate", 27, position, false);
                    builder.lastReviewDate(parseDate("lastReviewDate", reader, -1));
                    break;
                case "effectivePeriod":
                    position = checkElementOrder("effectivePeriod", 28, position, false);
                    builder.effectivePeriod(parsePeriod("effectivePeriod", reader, -1));
                    break;
                case "topic":
                    position = checkElementOrder("topic", 29, position, true);
                    builder.topic(parseCodeableConcept("topic", reader, topicElementIndex++));
                    break;
                case "author":
                    position = checkElementOrder("author", 30, position, true);
                    builder.author(parseContactDetail("author", reader, authorElementIndex++));
                    break;
                case "editor":
                    position = checkElementOrder("editor", 31, position, true);
                    builder.editor(parseContactDetail("editor", reader, editorElementIndex++));
                    break;
                case "reviewer":
                    position = checkElementOrder("reviewer", 32, position, true);
                    builder.reviewer(parseContactDetail("reviewer", reader, reviewerElementIndex++));
                    break;
                case "endorser":
                    position = checkElementOrder("endorser", 33, position, true);
                    builder.endorser(parseContactDetail("endorser", reader, endorserElementIndex++));
                    break;
                case "relatedArtifact":
                    position = checkElementOrder("relatedArtifact", 34, position, true);
                    builder.relatedArtifact(parseRelatedArtifact("relatedArtifact", reader, relatedArtifactElementIndex++));
                    break;
                case "library":
                    position = checkElementOrder("library", 35, position, true);
                    builder.library((Canonical) parseUri(Canonical.builder(), "library", reader, libraryElementIndex++));
                    break;
                case "kind":
                    position = checkElementOrder("kind", 36, position, false);
                    builder.kind((ActivityDefinitionKind) parseString(ActivityDefinitionKind.builder(), "kind", reader, -1));
                    break;
                case "profile":
                    position = checkElementOrder("profile", 37, position, false);
                    builder.profile((Canonical) parseUri(Canonical.builder(), "profile", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 38, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "intent":
                    position = checkElementOrder("intent", 39, position, false);
                    builder.intent((RequestIntent) parseString(RequestIntent.builder(), "intent", reader, -1));
                    break;
                case "priority":
                    position = checkElementOrder("priority", 40, position, false);
                    builder.priority((RequestPriority) parseString(RequestPriority.builder(), "priority", reader, -1));
                    break;
                case "doNotPerform":
                    position = checkElementOrder("doNotPerform", 41, position, false);
                    builder.doNotPerform(parseBoolean("doNotPerform", reader, -1));
                    break;
                case "timingTiming":
                    position = checkElementOrder("timing[x]", 42, position, false);
                    builder.timing(parseTiming("timingTiming", reader, -1));
                    break;
                case "timingDateTime":
                    position = checkElementOrder("timing[x]", 42, position, false);
                    builder.timing(parseDateTime("timingDateTime", reader, -1));
                    break;
                case "timingAge":
                    position = checkElementOrder("timing[x]", 42, position, false);
                    builder.timing((Age) parseQuantity(Age.builder(), "timingAge", reader, -1));
                    break;
                case "timingPeriod":
                    position = checkElementOrder("timing[x]", 42, position, false);
                    builder.timing(parsePeriod("timingPeriod", reader, -1));
                    break;
                case "timingRange":
                    position = checkElementOrder("timing[x]", 42, position, false);
                    builder.timing(parseRange("timingRange", reader, -1));
                    break;
                case "timingDuration":
                    position = checkElementOrder("timing[x]", 42, position, false);
                    builder.timing((Duration) parseQuantity(Duration.builder(), "timingDuration", reader, -1));
                    break;
                case "location":
                    position = checkElementOrder("location", 43, position, false);
                    builder.location(parseReference("location", reader, -1));
                    break;
                case "participant":
                    position = checkElementOrder("participant", 44, position, true);
                    builder.participant(parseActivityDefinitionParticipant("participant", reader, participantElementIndex++));
                    break;
                case "productReference":
                    position = checkElementOrder("product[x]", 45, position, false);
                    builder.product(parseReference("productReference", reader, -1));
                    break;
                case "productCodeableConcept":
                    position = checkElementOrder("product[x]", 45, position, false);
                    builder.product(parseCodeableConcept("productCodeableConcept", reader, -1));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 46, position, false);
                    builder.quantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "quantity", reader, -1));
                    break;
                case "dosage":
                    position = checkElementOrder("dosage", 47, position, true);
                    builder.dosage(parseDosage("dosage", reader, dosageElementIndex++));
                    break;
                case "bodySite":
                    position = checkElementOrder("bodySite", 48, position, true);
                    builder.bodySite(parseCodeableConcept("bodySite", reader, bodySiteElementIndex++));
                    break;
                case "specimenRequirement":
                    position = checkElementOrder("specimenRequirement", 49, position, true);
                    builder.specimenRequirement(parseReference("specimenRequirement", reader, specimenRequirementElementIndex++));
                    break;
                case "observationRequirement":
                    position = checkElementOrder("observationRequirement", 50, position, true);
                    builder.observationRequirement(parseReference("observationRequirement", reader, observationRequirementElementIndex++));
                    break;
                case "observationResultRequirement":
                    position = checkElementOrder("observationResultRequirement", 51, position, true);
                    builder.observationResultRequirement(parseReference("observationResultRequirement", reader, observationResultRequirementElementIndex++));
                    break;
                case "transform":
                    position = checkElementOrder("transform", 52, position, false);
                    builder.transform((Canonical) parseUri(Canonical.builder(), "transform", reader, -1));
                    break;
                case "dynamicValue":
                    position = checkElementOrder("dynamicValue", 53, position, true);
                    builder.dynamicValue(parseActivityDefinitionDynamicValue("dynamicValue", reader, dynamicValueElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ActivityDefinition.DynamicValue parseActivityDefinitionDynamicValue(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ActivityDefinition.DynamicValue.Builder builder = ActivityDefinition.DynamicValue.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "path":
                    position = checkElementOrder("path", 2, position, false);
                    builder.path(parseString("path", reader, -1));
                    break;
                case "expression":
                    position = checkElementOrder("expression", 3, position, false);
                    builder.expression(parseExpression("expression", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ActivityDefinition.Participant parseActivityDefinitionParticipant(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ActivityDefinition.Participant.Builder builder = ActivityDefinition.Participant.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type((ActivityParticipantType) parseString(ActivityParticipantType.builder(), "type", reader, -1));
                    break;
                case "role":
                    position = checkElementOrder("role", 3, position, false);
                    builder.role(parseCodeableConcept("role", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Address parseAddress(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Address.Builder builder = Address.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, lineElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "use":
                    position = checkElementOrder("use", 1, position, false);
                    builder.use((AddressUse) parseString(AddressUse.builder(), "use", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type((AddressType) parseString(AddressType.builder(), "type", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 3, position, false);
                    builder.text(parseString("text", reader, -1));
                    break;
                case "line":
                    position = checkElementOrder("line", 4, position, true);
                    builder.line(parseString("line", reader, lineElementIndex++));
                    break;
                case "city":
                    position = checkElementOrder("city", 5, position, false);
                    builder.city(parseString("city", reader, -1));
                    break;
                case "district":
                    position = checkElementOrder("district", 6, position, false);
                    builder.district(parseString("district", reader, -1));
                    break;
                case "state":
                    position = checkElementOrder("state", 7, position, false);
                    builder.state(parseString("state", reader, -1));
                    break;
                case "postalCode":
                    position = checkElementOrder("postalCode", 8, position, false);
                    builder.postalCode(parseString("postalCode", reader, -1));
                    break;
                case "country":
                    position = checkElementOrder("country", 9, position, false);
                    builder.country(parseString("country", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 10, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private AdministrableProductDefinition parseAdministrableProductDefinition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        AdministrableProductDefinition.Builder builder = AdministrableProductDefinition.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, formOfElementIndex = 0, producedFromElementIndex = 0, ingredientElementIndex = 0, propertyElementIndex = 0, routeOfAdministrationElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "formOf":
                    position = checkElementOrder("formOf", 10, position, true);
                    builder.formOf(parseReference("formOf", reader, formOfElementIndex++));
                    break;
                case "administrableDoseForm":
                    position = checkElementOrder("administrableDoseForm", 11, position, false);
                    builder.administrableDoseForm(parseCodeableConcept("administrableDoseForm", reader, -1));
                    break;
                case "unitOfPresentation":
                    position = checkElementOrder("unitOfPresentation", 12, position, false);
                    builder.unitOfPresentation(parseCodeableConcept("unitOfPresentation", reader, -1));
                    break;
                case "producedFrom":
                    position = checkElementOrder("producedFrom", 13, position, true);
                    builder.producedFrom(parseReference("producedFrom", reader, producedFromElementIndex++));
                    break;
                case "ingredient":
                    position = checkElementOrder("ingredient", 14, position, true);
                    builder.ingredient(parseCodeableConcept("ingredient", reader, ingredientElementIndex++));
                    break;
                case "device":
                    position = checkElementOrder("device", 15, position, false);
                    builder.device(parseReference("device", reader, -1));
                    break;
                case "property":
                    position = checkElementOrder("property", 16, position, true);
                    builder.property(parseAdministrableProductDefinitionProperty("property", reader, propertyElementIndex++));
                    break;
                case "routeOfAdministration":
                    position = checkElementOrder("routeOfAdministration", 17, position, true);
                    builder.routeOfAdministration(parseAdministrableProductDefinitionRouteOfAdministration("routeOfAdministration", reader, routeOfAdministrationElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private AdministrableProductDefinition.Property parseAdministrableProductDefinitionProperty(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        AdministrableProductDefinition.Property.Builder builder = AdministrableProductDefinition.Property.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "valueCodeableConcept":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCodeableConcept("valueCodeableConcept", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueDate":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDate("valueDate", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueAttachment":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseAttachment("valueAttachment", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 4, position, false);
                    builder.status(parseCodeableConcept("status", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private AdministrableProductDefinition.RouteOfAdministration parseAdministrableProductDefinitionRouteOfAdministration(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        AdministrableProductDefinition.RouteOfAdministration.Builder builder = AdministrableProductDefinition.RouteOfAdministration.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, targetSpeciesElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "firstDose":
                    position = checkElementOrder("firstDose", 3, position, false);
                    builder.firstDose(parseQuantity("firstDose", reader, -1));
                    break;
                case "maxSingleDose":
                    position = checkElementOrder("maxSingleDose", 4, position, false);
                    builder.maxSingleDose(parseQuantity("maxSingleDose", reader, -1));
                    break;
                case "maxDosePerDay":
                    position = checkElementOrder("maxDosePerDay", 5, position, false);
                    builder.maxDosePerDay(parseQuantity("maxDosePerDay", reader, -1));
                    break;
                case "maxDosePerTreatmentPeriod":
                    position = checkElementOrder("maxDosePerTreatmentPeriod", 6, position, false);
                    builder.maxDosePerTreatmentPeriod(parseRatio("maxDosePerTreatmentPeriod", reader, -1));
                    break;
                case "maxTreatmentPeriod":
                    position = checkElementOrder("maxTreatmentPeriod", 7, position, false);
                    builder.maxTreatmentPeriod((Duration) parseQuantity(Duration.builder(), "maxTreatmentPeriod", reader, -1));
                    break;
                case "targetSpecies":
                    position = checkElementOrder("targetSpecies", 8, position, true);
                    builder.targetSpecies(parseAdministrableProductDefinitionRouteOfAdministrationTargetSpecies("targetSpecies", reader, targetSpeciesElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private AdministrableProductDefinition.RouteOfAdministration.TargetSpecies parseAdministrableProductDefinitionRouteOfAdministrationTargetSpecies(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        AdministrableProductDefinition.RouteOfAdministration.TargetSpecies.Builder builder = AdministrableProductDefinition.RouteOfAdministration.TargetSpecies.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, withdrawalPeriodElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "withdrawalPeriod":
                    position = checkElementOrder("withdrawalPeriod", 3, position, true);
                    builder.withdrawalPeriod(parseAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod("withdrawalPeriod", reader, withdrawalPeriodElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private AdministrableProductDefinition.RouteOfAdministration.TargetSpecies.WithdrawalPeriod parseAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        AdministrableProductDefinition.RouteOfAdministration.TargetSpecies.WithdrawalPeriod.Builder builder = AdministrableProductDefinition.RouteOfAdministration.TargetSpecies.WithdrawalPeriod.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "tissue":
                    position = checkElementOrder("tissue", 2, position, false);
                    builder.tissue(parseCodeableConcept("tissue", reader, -1));
                    break;
                case "value":
                    position = checkElementOrder("value", 3, position, false);
                    builder.value(parseQuantity("value", reader, -1));
                    break;
                case "supportingInformation":
                    position = checkElementOrder("supportingInformation", 4, position, false);
                    builder.supportingInformation(parseString("supportingInformation", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private AdverseEvent parseAdverseEvent(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        AdverseEvent.Builder builder = AdverseEvent.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, categoryElementIndex = 0, resultingConditionElementIndex = 0, contributorElementIndex = 0, suspectEntityElementIndex = 0, subjectMedicalHistoryElementIndex = 0, referenceDocumentElementIndex = 0, studyElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, false);
                    builder.identifier(parseIdentifier("identifier", reader, -1));
                    break;
                case "actuality":
                    position = checkElementOrder("actuality", 9, position, false);
                    builder.actuality((AdverseEventActuality) parseString(AdverseEventActuality.builder(), "actuality", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 10, position, true);
                    builder.category(parseCodeableConcept("category", reader, categoryElementIndex++));
                    break;
                case "event":
                    position = checkElementOrder("event", 11, position, false);
                    builder.event(parseCodeableConcept("event", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 12, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 13, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 14, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "detected":
                    position = checkElementOrder("detected", 15, position, false);
                    builder.detected(parseDateTime("detected", reader, -1));
                    break;
                case "recordedDate":
                    position = checkElementOrder("recordedDate", 16, position, false);
                    builder.recordedDate(parseDateTime("recordedDate", reader, -1));
                    break;
                case "resultingCondition":
                    position = checkElementOrder("resultingCondition", 17, position, true);
                    builder.resultingCondition(parseReference("resultingCondition", reader, resultingConditionElementIndex++));
                    break;
                case "location":
                    position = checkElementOrder("location", 18, position, false);
                    builder.location(parseReference("location", reader, -1));
                    break;
                case "seriousness":
                    position = checkElementOrder("seriousness", 19, position, false);
                    builder.seriousness(parseCodeableConcept("seriousness", reader, -1));
                    break;
                case "severity":
                    position = checkElementOrder("severity", 20, position, false);
                    builder.severity(parseCodeableConcept("severity", reader, -1));
                    break;
                case "outcome":
                    position = checkElementOrder("outcome", 21, position, false);
                    builder.outcome(parseCodeableConcept("outcome", reader, -1));
                    break;
                case "recorder":
                    position = checkElementOrder("recorder", 22, position, false);
                    builder.recorder(parseReference("recorder", reader, -1));
                    break;
                case "contributor":
                    position = checkElementOrder("contributor", 23, position, true);
                    builder.contributor(parseReference("contributor", reader, contributorElementIndex++));
                    break;
                case "suspectEntity":
                    position = checkElementOrder("suspectEntity", 24, position, true);
                    builder.suspectEntity(parseAdverseEventSuspectEntity("suspectEntity", reader, suspectEntityElementIndex++));
                    break;
                case "subjectMedicalHistory":
                    position = checkElementOrder("subjectMedicalHistory", 25, position, true);
                    builder.subjectMedicalHistory(parseReference("subjectMedicalHistory", reader, subjectMedicalHistoryElementIndex++));
                    break;
                case "referenceDocument":
                    position = checkElementOrder("referenceDocument", 26, position, true);
                    builder.referenceDocument(parseReference("referenceDocument", reader, referenceDocumentElementIndex++));
                    break;
                case "study":
                    position = checkElementOrder("study", 27, position, true);
                    builder.study(parseReference("study", reader, studyElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private AdverseEvent.SuspectEntity parseAdverseEventSuspectEntity(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        AdverseEvent.SuspectEntity.Builder builder = AdverseEvent.SuspectEntity.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, causalityElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "instance":
                    position = checkElementOrder("instance", 2, position, false);
                    builder.instance(parseReference("instance", reader, -1));
                    break;
                case "causality":
                    position = checkElementOrder("causality", 3, position, true);
                    builder.causality(parseAdverseEventSuspectEntityCausality("causality", reader, causalityElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private AdverseEvent.SuspectEntity.Causality parseAdverseEventSuspectEntityCausality(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        AdverseEvent.SuspectEntity.Causality.Builder builder = AdverseEvent.SuspectEntity.Causality.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "assessment":
                    position = checkElementOrder("assessment", 2, position, false);
                    builder.assessment(parseCodeableConcept("assessment", reader, -1));
                    break;
                case "productRelatedness":
                    position = checkElementOrder("productRelatedness", 3, position, false);
                    builder.productRelatedness(parseString("productRelatedness", reader, -1));
                    break;
                case "author":
                    position = checkElementOrder("author", 4, position, false);
                    builder.author(parseReference("author", reader, -1));
                    break;
                case "method":
                    position = checkElementOrder("method", 5, position, false);
                    builder.method(parseCodeableConcept("method", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private AllergyIntolerance parseAllergyIntolerance(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        AllergyIntolerance.Builder builder = AllergyIntolerance.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, categoryElementIndex = 0, noteElementIndex = 0, reactionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "clinicalStatus":
                    position = checkElementOrder("clinicalStatus", 9, position, false);
                    builder.clinicalStatus(parseCodeableConcept("clinicalStatus", reader, -1));
                    break;
                case "verificationStatus":
                    position = checkElementOrder("verificationStatus", 10, position, false);
                    builder.verificationStatus(parseCodeableConcept("verificationStatus", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 11, position, false);
                    builder.type((AllergyIntoleranceType) parseString(AllergyIntoleranceType.builder(), "type", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 12, position, true);
                    builder.category((AllergyIntoleranceCategory) parseString(AllergyIntoleranceCategory.builder(), "category", reader, categoryElementIndex++));
                    break;
                case "criticality":
                    position = checkElementOrder("criticality", 13, position, false);
                    builder.criticality((AllergyIntoleranceCriticality) parseString(AllergyIntoleranceCriticality.builder(), "criticality", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 14, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "patient":
                    position = checkElementOrder("patient", 15, position, false);
                    builder.patient(parseReference("patient", reader, -1));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 16, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "onsetDateTime":
                    position = checkElementOrder("onset[x]", 17, position, false);
                    builder.onset(parseDateTime("onsetDateTime", reader, -1));
                    break;
                case "onsetAge":
                    position = checkElementOrder("onset[x]", 17, position, false);
                    builder.onset((Age) parseQuantity(Age.builder(), "onsetAge", reader, -1));
                    break;
                case "onsetPeriod":
                    position = checkElementOrder("onset[x]", 17, position, false);
                    builder.onset(parsePeriod("onsetPeriod", reader, -1));
                    break;
                case "onsetRange":
                    position = checkElementOrder("onset[x]", 17, position, false);
                    builder.onset(parseRange("onsetRange", reader, -1));
                    break;
                case "onsetString":
                    position = checkElementOrder("onset[x]", 17, position, false);
                    builder.onset(parseString("onsetString", reader, -1));
                    break;
                case "recordedDate":
                    position = checkElementOrder("recordedDate", 18, position, false);
                    builder.recordedDate(parseDateTime("recordedDate", reader, -1));
                    break;
                case "recorder":
                    position = checkElementOrder("recorder", 19, position, false);
                    builder.recorder(parseReference("recorder", reader, -1));
                    break;
                case "asserter":
                    position = checkElementOrder("asserter", 20, position, false);
                    builder.asserter(parseReference("asserter", reader, -1));
                    break;
                case "lastOccurrence":
                    position = checkElementOrder("lastOccurrence", 21, position, false);
                    builder.lastOccurrence(parseDateTime("lastOccurrence", reader, -1));
                    break;
                case "note":
                    position = checkElementOrder("note", 22, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "reaction":
                    position = checkElementOrder("reaction", 23, position, true);
                    builder.reaction(parseAllergyIntoleranceReaction("reaction", reader, reactionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private AllergyIntolerance.Reaction parseAllergyIntoleranceReaction(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        AllergyIntolerance.Reaction.Builder builder = AllergyIntolerance.Reaction.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, manifestationElementIndex = 0, noteElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "substance":
                    position = checkElementOrder("substance", 2, position, false);
                    builder.substance(parseCodeableConcept("substance", reader, -1));
                    break;
                case "manifestation":
                    position = checkElementOrder("manifestation", 3, position, true);
                    builder.manifestation(parseCodeableConcept("manifestation", reader, manifestationElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 4, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "onset":
                    position = checkElementOrder("onset", 5, position, false);
                    builder.onset(parseDateTime("onset", reader, -1));
                    break;
                case "severity":
                    position = checkElementOrder("severity", 6, position, false);
                    builder.severity((AllergyIntoleranceSeverity) parseString(AllergyIntoleranceSeverity.builder(), "severity", reader, -1));
                    break;
                case "exposureRoute":
                    position = checkElementOrder("exposureRoute", 7, position, false);
                    builder.exposureRoute(parseCodeableConcept("exposureRoute", reader, -1));
                    break;
                case "note":
                    position = checkElementOrder("note", 8, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Annotation parseAnnotation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Annotation.Builder builder = Annotation.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "authorReference":
                    position = checkElementOrder("author[x]", 1, position, false);
                    builder.author(parseReference("authorReference", reader, -1));
                    break;
                case "authorString":
                    position = checkElementOrder("author[x]", 1, position, false);
                    builder.author(parseString("authorString", reader, -1));
                    break;
                case "time":
                    position = checkElementOrder("time", 2, position, false);
                    builder.time(parseDateTime("time", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 3, position, false);
                    builder.text((Markdown) parseString(Markdown.builder(), "text", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Appointment parseAppointment(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Appointment.Builder builder = Appointment.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, serviceCategoryElementIndex = 0, serviceTypeElementIndex = 0, specialtyElementIndex = 0, reasonCodeElementIndex = 0, reasonReferenceElementIndex = 0, supportingInformationElementIndex = 0, slotElementIndex = 0, basedOnElementIndex = 0, participantElementIndex = 0, requestedPeriodElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((AppointmentStatus) parseString(AppointmentStatus.builder(), "status", reader, -1));
                    break;
                case "cancelationReason":
                    position = checkElementOrder("cancelationReason", 10, position, false);
                    builder.cancelationReason(parseCodeableConcept("cancelationReason", reader, -1));
                    break;
                case "serviceCategory":
                    position = checkElementOrder("serviceCategory", 11, position, true);
                    builder.serviceCategory(parseCodeableConcept("serviceCategory", reader, serviceCategoryElementIndex++));
                    break;
                case "serviceType":
                    position = checkElementOrder("serviceType", 12, position, true);
                    builder.serviceType(parseCodeableConcept("serviceType", reader, serviceTypeElementIndex++));
                    break;
                case "specialty":
                    position = checkElementOrder("specialty", 13, position, true);
                    builder.specialty(parseCodeableConcept("specialty", reader, specialtyElementIndex++));
                    break;
                case "appointmentType":
                    position = checkElementOrder("appointmentType", 14, position, false);
                    builder.appointmentType(parseCodeableConcept("appointmentType", reader, -1));
                    break;
                case "reasonCode":
                    position = checkElementOrder("reasonCode", 15, position, true);
                    builder.reasonCode(parseCodeableConcept("reasonCode", reader, reasonCodeElementIndex++));
                    break;
                case "reasonReference":
                    position = checkElementOrder("reasonReference", 16, position, true);
                    builder.reasonReference(parseReference("reasonReference", reader, reasonReferenceElementIndex++));
                    break;
                case "priority":
                    position = checkElementOrder("priority", 17, position, false);
                    builder.priority((UnsignedInt) parseInteger(UnsignedInt.builder(), "priority", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 18, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "supportingInformation":
                    position = checkElementOrder("supportingInformation", 19, position, true);
                    builder.supportingInformation(parseReference("supportingInformation", reader, supportingInformationElementIndex++));
                    break;
                case "start":
                    position = checkElementOrder("start", 20, position, false);
                    builder.start(parseInstant("start", reader, -1));
                    break;
                case "end":
                    position = checkElementOrder("end", 21, position, false);
                    builder.end(parseInstant("end", reader, -1));
                    break;
                case "minutesDuration":
                    position = checkElementOrder("minutesDuration", 22, position, false);
                    builder.minutesDuration((PositiveInt) parseInteger(PositiveInt.builder(), "minutesDuration", reader, -1));
                    break;
                case "slot":
                    position = checkElementOrder("slot", 23, position, true);
                    builder.slot(parseReference("slot", reader, slotElementIndex++));
                    break;
                case "created":
                    position = checkElementOrder("created", 24, position, false);
                    builder.created(parseDateTime("created", reader, -1));
                    break;
                case "comment":
                    position = checkElementOrder("comment", 25, position, false);
                    builder.comment(parseString("comment", reader, -1));
                    break;
                case "patientInstruction":
                    position = checkElementOrder("patientInstruction", 26, position, false);
                    builder.patientInstruction(parseString("patientInstruction", reader, -1));
                    break;
                case "basedOn":
                    position = checkElementOrder("basedOn", 27, position, true);
                    builder.basedOn(parseReference("basedOn", reader, basedOnElementIndex++));
                    break;
                case "participant":
                    position = checkElementOrder("participant", 28, position, true);
                    builder.participant(parseAppointmentParticipant("participant", reader, participantElementIndex++));
                    break;
                case "requestedPeriod":
                    position = checkElementOrder("requestedPeriod", 29, position, true);
                    builder.requestedPeriod(parsePeriod("requestedPeriod", reader, requestedPeriodElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Appointment.Participant parseAppointmentParticipant(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Appointment.Participant.Builder builder = Appointment.Participant.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, typeElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, true);
                    builder.type(parseCodeableConcept("type", reader, typeElementIndex++));
                    break;
                case "actor":
                    position = checkElementOrder("actor", 3, position, false);
                    builder.actor(parseReference("actor", reader, -1));
                    break;
                case "required":
                    position = checkElementOrder("required", 4, position, false);
                    builder.required((ParticipantRequired) parseString(ParticipantRequired.builder(), "required", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 5, position, false);
                    builder.status((ParticipationStatus) parseString(ParticipationStatus.builder(), "status", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 6, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private AppointmentResponse parseAppointmentResponse(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        AppointmentResponse.Builder builder = AppointmentResponse.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, participantTypeElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "appointment":
                    position = checkElementOrder("appointment", 9, position, false);
                    builder.appointment(parseReference("appointment", reader, -1));
                    break;
                case "start":
                    position = checkElementOrder("start", 10, position, false);
                    builder.start(parseInstant("start", reader, -1));
                    break;
                case "end":
                    position = checkElementOrder("end", 11, position, false);
                    builder.end(parseInstant("end", reader, -1));
                    break;
                case "participantType":
                    position = checkElementOrder("participantType", 12, position, true);
                    builder.participantType(parseCodeableConcept("participantType", reader, participantTypeElementIndex++));
                    break;
                case "actor":
                    position = checkElementOrder("actor", 13, position, false);
                    builder.actor(parseReference("actor", reader, -1));
                    break;
                case "participantStatus":
                    position = checkElementOrder("participantStatus", 14, position, false);
                    builder.participantStatus((ParticipantStatus) parseString(ParticipantStatus.builder(), "participantStatus", reader, -1));
                    break;
                case "comment":
                    position = checkElementOrder("comment", 15, position, false);
                    builder.comment(parseString("comment", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Attachment parseAttachment(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Attachment.Builder builder = Attachment.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "contentType":
                    position = checkElementOrder("contentType", 1, position, false);
                    builder.contentType((Code) parseString(Code.builder(), "contentType", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 2, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "data":
                    position = checkElementOrder("data", 3, position, false);
                    builder.data(parseBase64Binary("data", reader, -1));
                    break;
                case "url":
                    position = checkElementOrder("url", 4, position, false);
                    builder.url((Url) parseUri(Url.builder(), "url", reader, -1));
                    break;
                case "size":
                    position = checkElementOrder("size", 5, position, false);
                    builder.size((UnsignedInt) parseInteger(UnsignedInt.builder(), "size", reader, -1));
                    break;
                case "hash":
                    position = checkElementOrder("hash", 6, position, false);
                    builder.hash(parseBase64Binary("hash", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 7, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "creation":
                    position = checkElementOrder("creation", 8, position, false);
                    builder.creation(parseDateTime("creation", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private AuditEvent parseAuditEvent(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        AuditEvent.Builder builder = AuditEvent.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, subtypeElementIndex = 0, purposeOfEventElementIndex = 0, agentElementIndex = 0, entityElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 8, position, false);
                    builder.type(parseCoding("type", reader, -1));
                    break;
                case "subtype":
                    position = checkElementOrder("subtype", 9, position, true);
                    builder.subtype(parseCoding("subtype", reader, subtypeElementIndex++));
                    break;
                case "action":
                    position = checkElementOrder("action", 10, position, false);
                    builder.action((AuditEventAction) parseString(AuditEventAction.builder(), "action", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 11, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                case "recorded":
                    position = checkElementOrder("recorded", 12, position, false);
                    builder.recorded(parseInstant("recorded", reader, -1));
                    break;
                case "outcome":
                    position = checkElementOrder("outcome", 13, position, false);
                    builder.outcome((AuditEventOutcome) parseString(AuditEventOutcome.builder(), "outcome", reader, -1));
                    break;
                case "outcomeDesc":
                    position = checkElementOrder("outcomeDesc", 14, position, false);
                    builder.outcomeDesc(parseString("outcomeDesc", reader, -1));
                    break;
                case "purposeOfEvent":
                    position = checkElementOrder("purposeOfEvent", 15, position, true);
                    builder.purposeOfEvent(parseCodeableConcept("purposeOfEvent", reader, purposeOfEventElementIndex++));
                    break;
                case "agent":
                    position = checkElementOrder("agent", 16, position, true);
                    builder.agent(parseAuditEventAgent("agent", reader, agentElementIndex++));
                    break;
                case "source":
                    position = checkElementOrder("source", 17, position, false);
                    builder.source(parseAuditEventSource("source", reader, -1));
                    break;
                case "entity":
                    position = checkElementOrder("entity", 18, position, true);
                    builder.entity(parseAuditEventEntity("entity", reader, entityElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private AuditEvent.Agent parseAuditEventAgent(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        AuditEvent.Agent.Builder builder = AuditEvent.Agent.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, roleElementIndex = 0, policyElementIndex = 0, purposeOfUseElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "role":
                    position = checkElementOrder("role", 3, position, true);
                    builder.role(parseCodeableConcept("role", reader, roleElementIndex++));
                    break;
                case "who":
                    position = checkElementOrder("who", 4, position, false);
                    builder.who(parseReference("who", reader, -1));
                    break;
                case "altId":
                    position = checkElementOrder("altId", 5, position, false);
                    builder.altId(parseString("altId", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 6, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "requestor":
                    position = checkElementOrder("requestor", 7, position, false);
                    builder.requestor(parseBoolean("requestor", reader, -1));
                    break;
                case "location":
                    position = checkElementOrder("location", 8, position, false);
                    builder.location(parseReference("location", reader, -1));
                    break;
                case "policy":
                    position = checkElementOrder("policy", 9, position, true);
                    builder.policy(parseUri("policy", reader, policyElementIndex++));
                    break;
                case "media":
                    position = checkElementOrder("media", 10, position, false);
                    builder.media(parseCoding("media", reader, -1));
                    break;
                case "network":
                    position = checkElementOrder("network", 11, position, false);
                    builder.network(parseAuditEventAgentNetwork("network", reader, -1));
                    break;
                case "purposeOfUse":
                    position = checkElementOrder("purposeOfUse", 12, position, true);
                    builder.purposeOfUse(parseCodeableConcept("purposeOfUse", reader, purposeOfUseElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private AuditEvent.Agent.Network parseAuditEventAgentNetwork(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        AuditEvent.Agent.Network.Builder builder = AuditEvent.Agent.Network.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "address":
                    position = checkElementOrder("address", 2, position, false);
                    builder.address(parseString("address", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type((AuditEventAgentNetworkType) parseString(AuditEventAgentNetworkType.builder(), "type", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private AuditEvent.Entity parseAuditEventEntity(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        AuditEvent.Entity.Builder builder = AuditEvent.Entity.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, securityLabelElementIndex = 0, detailElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "what":
                    position = checkElementOrder("what", 2, position, false);
                    builder.what(parseReference("what", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type(parseCoding("type", reader, -1));
                    break;
                case "role":
                    position = checkElementOrder("role", 4, position, false);
                    builder.role(parseCoding("role", reader, -1));
                    break;
                case "lifecycle":
                    position = checkElementOrder("lifecycle", 5, position, false);
                    builder.lifecycle(parseCoding("lifecycle", reader, -1));
                    break;
                case "securityLabel":
                    position = checkElementOrder("securityLabel", 6, position, true);
                    builder.securityLabel(parseCoding("securityLabel", reader, securityLabelElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 7, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 8, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "query":
                    position = checkElementOrder("query", 9, position, false);
                    builder.query(parseBase64Binary("query", reader, -1));
                    break;
                case "detail":
                    position = checkElementOrder("detail", 10, position, true);
                    builder.detail(parseAuditEventEntityDetail("detail", reader, detailElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private AuditEvent.Entity.Detail parseAuditEventEntityDetail(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        AuditEvent.Entity.Detail.Builder builder = AuditEvent.Entity.Detail.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseString("type", reader, -1));
                    break;
                case "valueString":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseString("valueString", reader, -1));
                    break;
                case "valueBase64Binary":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBase64Binary("valueBase64Binary", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private AuditEvent.Source parseAuditEventSource(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        AuditEvent.Source.Builder builder = AuditEvent.Source.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, typeElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "site":
                    position = checkElementOrder("site", 2, position, false);
                    builder.site(parseString("site", reader, -1));
                    break;
                case "observer":
                    position = checkElementOrder("observer", 3, position, false);
                    builder.observer(parseReference("observer", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 4, position, true);
                    builder.type(parseCoding("type", reader, typeElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Base64Binary parseBase64Binary(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Base64Binary.Builder builder = Base64Binary.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        java.lang.String value = reader.getAttributeValue(null, "value");
        if (value != null) {
            builder.value(value);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Basic parseBasic(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Basic.Builder builder = Basic.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 9, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 10, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "created":
                    position = checkElementOrder("created", 11, position, false);
                    builder.created(parseDate("created", reader, -1));
                    break;
                case "author":
                    position = checkElementOrder("author", 12, position, false);
                    builder.author(parseReference("author", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Binary parseBinary(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Binary.Builder builder = Binary.builder();
        builder.setValidating(validating);
        int position = -1;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "contentType":
                    position = checkElementOrder("contentType", 4, position, false);
                    builder.contentType((Code) parseString(Code.builder(), "contentType", reader, -1));
                    break;
                case "securityContext":
                    position = checkElementOrder("securityContext", 5, position, false);
                    builder.securityContext(parseReference("securityContext", reader, -1));
                    break;
                case "data":
                    position = checkElementOrder("data", 6, position, false);
                    builder.data(parseBase64Binary("data", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private BiologicallyDerivedProduct parseBiologicallyDerivedProduct(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        BiologicallyDerivedProduct.Builder builder = BiologicallyDerivedProduct.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, requestElementIndex = 0, parentElementIndex = 0, processingElementIndex = 0, storageElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "productCategory":
                    position = checkElementOrder("productCategory", 9, position, false);
                    builder.productCategory((BiologicallyDerivedProductCategory) parseString(BiologicallyDerivedProductCategory.builder(), "productCategory", reader, -1));
                    break;
                case "productCode":
                    position = checkElementOrder("productCode", 10, position, false);
                    builder.productCode(parseCodeableConcept("productCode", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 11, position, false);
                    builder.status((BiologicallyDerivedProductStatus) parseString(BiologicallyDerivedProductStatus.builder(), "status", reader, -1));
                    break;
                case "request":
                    position = checkElementOrder("request", 12, position, true);
                    builder.request(parseReference("request", reader, requestElementIndex++));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 13, position, false);
                    builder.quantity(parseInteger("quantity", reader, -1));
                    break;
                case "parent":
                    position = checkElementOrder("parent", 14, position, true);
                    builder.parent(parseReference("parent", reader, parentElementIndex++));
                    break;
                case "collection":
                    position = checkElementOrder("collection", 15, position, false);
                    builder.collection(parseBiologicallyDerivedProductCollection("collection", reader, -1));
                    break;
                case "processing":
                    position = checkElementOrder("processing", 16, position, true);
                    builder.processing(parseBiologicallyDerivedProductProcessing("processing", reader, processingElementIndex++));
                    break;
                case "manipulation":
                    position = checkElementOrder("manipulation", 17, position, false);
                    builder.manipulation(parseBiologicallyDerivedProductManipulation("manipulation", reader, -1));
                    break;
                case "storage":
                    position = checkElementOrder("storage", 18, position, true);
                    builder.storage(parseBiologicallyDerivedProductStorage("storage", reader, storageElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private BiologicallyDerivedProduct.Collection parseBiologicallyDerivedProductCollection(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        BiologicallyDerivedProduct.Collection.Builder builder = BiologicallyDerivedProduct.Collection.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "collector":
                    position = checkElementOrder("collector", 2, position, false);
                    builder.collector(parseReference("collector", reader, -1));
                    break;
                case "source":
                    position = checkElementOrder("source", 3, position, false);
                    builder.source(parseReference("source", reader, -1));
                    break;
                case "collectedDateTime":
                    position = checkElementOrder("collected[x]", 4, position, false);
                    builder.collected(parseDateTime("collectedDateTime", reader, -1));
                    break;
                case "collectedPeriod":
                    position = checkElementOrder("collected[x]", 4, position, false);
                    builder.collected(parsePeriod("collectedPeriod", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private BiologicallyDerivedProduct.Manipulation parseBiologicallyDerivedProductManipulation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        BiologicallyDerivedProduct.Manipulation.Builder builder = BiologicallyDerivedProduct.Manipulation.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 2, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "timeDateTime":
                    position = checkElementOrder("time[x]", 3, position, false);
                    builder.time(parseDateTime("timeDateTime", reader, -1));
                    break;
                case "timePeriod":
                    position = checkElementOrder("time[x]", 3, position, false);
                    builder.time(parsePeriod("timePeriod", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private BiologicallyDerivedProduct.Processing parseBiologicallyDerivedProductProcessing(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        BiologicallyDerivedProduct.Processing.Builder builder = BiologicallyDerivedProduct.Processing.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 2, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "procedure":
                    position = checkElementOrder("procedure", 3, position, false);
                    builder.procedure(parseCodeableConcept("procedure", reader, -1));
                    break;
                case "additive":
                    position = checkElementOrder("additive", 4, position, false);
                    builder.additive(parseReference("additive", reader, -1));
                    break;
                case "timeDateTime":
                    position = checkElementOrder("time[x]", 5, position, false);
                    builder.time(parseDateTime("timeDateTime", reader, -1));
                    break;
                case "timePeriod":
                    position = checkElementOrder("time[x]", 5, position, false);
                    builder.time(parsePeriod("timePeriod", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private BiologicallyDerivedProduct.Storage parseBiologicallyDerivedProductStorage(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        BiologicallyDerivedProduct.Storage.Builder builder = BiologicallyDerivedProduct.Storage.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 2, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "temperature":
                    position = checkElementOrder("temperature", 3, position, false);
                    builder.temperature(parseDecimal("temperature", reader, -1));
                    break;
                case "scale":
                    position = checkElementOrder("scale", 4, position, false);
                    builder.scale((BiologicallyDerivedProductStorageScale) parseString(BiologicallyDerivedProductStorageScale.builder(), "scale", reader, -1));
                    break;
                case "duration":
                    position = checkElementOrder("duration", 5, position, false);
                    builder.duration(parsePeriod("duration", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private BodyStructure parseBodyStructure(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        BodyStructure.Builder builder = BodyStructure.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, locationQualifierElementIndex = 0, imageElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "active":
                    position = checkElementOrder("active", 9, position, false);
                    builder.active(parseBoolean("active", reader, -1));
                    break;
                case "morphology":
                    position = checkElementOrder("morphology", 10, position, false);
                    builder.morphology(parseCodeableConcept("morphology", reader, -1));
                    break;
                case "location":
                    position = checkElementOrder("location", 11, position, false);
                    builder.location(parseCodeableConcept("location", reader, -1));
                    break;
                case "locationQualifier":
                    position = checkElementOrder("locationQualifier", 12, position, true);
                    builder.locationQualifier(parseCodeableConcept("locationQualifier", reader, locationQualifierElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 13, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "image":
                    position = checkElementOrder("image", 14, position, true);
                    builder.image(parseAttachment("image", reader, imageElementIndex++));
                    break;
                case "patient":
                    position = checkElementOrder("patient", 15, position, false);
                    builder.patient(parseReference("patient", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Boolean parseBoolean(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Boolean.Builder builder = Boolean.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        java.lang.String value = reader.getAttributeValue(null, "value");
        if (value != null) {
            builder.value(value);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Bundle parseBundle(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Bundle.Builder builder = Bundle.builder();
        builder.setValidating(validating);
        int position = -1;
        int linkElementIndex = 0, entryElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 4, position, false);
                    builder.identifier(parseIdentifier("identifier", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 5, position, false);
                    builder.type((BundleType) parseString(BundleType.builder(), "type", reader, -1));
                    break;
                case "timestamp":
                    position = checkElementOrder("timestamp", 6, position, false);
                    builder.timestamp(parseInstant("timestamp", reader, -1));
                    break;
                case "total":
                    position = checkElementOrder("total", 7, position, false);
                    builder.total((UnsignedInt) parseInteger(UnsignedInt.builder(), "total", reader, -1));
                    break;
                case "link":
                    position = checkElementOrder("link", 8, position, true);
                    builder.link(parseBundleLink("link", reader, linkElementIndex++));
                    break;
                case "entry":
                    position = checkElementOrder("entry", 9, position, true);
                    builder.entry(parseBundleEntry("entry", reader, entryElementIndex++));
                    break;
                case "signature":
                    position = checkElementOrder("signature", 10, position, false);
                    builder.signature(parseSignature("signature", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Bundle.Entry parseBundleEntry(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Bundle.Entry.Builder builder = Bundle.Entry.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, linkElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "link":
                    position = checkElementOrder("link", 2, position, true);
                    builder.link(parseBundleLink("link", reader, linkElementIndex++));
                    break;
                case "fullUrl":
                    position = checkElementOrder("fullUrl", 3, position, false);
                    builder.fullUrl(parseUri("fullUrl", reader, -1));
                    break;
                case "resource":
                    position = checkElementOrder("resource", 4, position, false);
                    builder.resource(parseResource("resource", reader, -1));
                    break;
                case "search":
                    position = checkElementOrder("search", 5, position, false);
                    builder.search(parseBundleEntrySearch("search", reader, -1));
                    break;
                case "request":
                    position = checkElementOrder("request", 6, position, false);
                    builder.request(parseBundleEntryRequest("request", reader, -1));
                    break;
                case "response":
                    position = checkElementOrder("response", 7, position, false);
                    builder.response(parseBundleEntryResponse("response", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Bundle.Entry.Request parseBundleEntryRequest(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Bundle.Entry.Request.Builder builder = Bundle.Entry.Request.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "method":
                    position = checkElementOrder("method", 2, position, false);
                    builder.method((HTTPVerb) parseString(HTTPVerb.builder(), "method", reader, -1));
                    break;
                case "url":
                    position = checkElementOrder("url", 3, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "ifNoneMatch":
                    position = checkElementOrder("ifNoneMatch", 4, position, false);
                    builder.ifNoneMatch(parseString("ifNoneMatch", reader, -1));
                    break;
                case "ifModifiedSince":
                    position = checkElementOrder("ifModifiedSince", 5, position, false);
                    builder.ifModifiedSince(parseInstant("ifModifiedSince", reader, -1));
                    break;
                case "ifMatch":
                    position = checkElementOrder("ifMatch", 6, position, false);
                    builder.ifMatch(parseString("ifMatch", reader, -1));
                    break;
                case "ifNoneExist":
                    position = checkElementOrder("ifNoneExist", 7, position, false);
                    builder.ifNoneExist(parseString("ifNoneExist", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Bundle.Entry.Response parseBundleEntryResponse(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Bundle.Entry.Response.Builder builder = Bundle.Entry.Response.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 2, position, false);
                    builder.status(parseString("status", reader, -1));
                    break;
                case "location":
                    position = checkElementOrder("location", 3, position, false);
                    builder.location(parseUri("location", reader, -1));
                    break;
                case "etag":
                    position = checkElementOrder("etag", 4, position, false);
                    builder.etag(parseString("etag", reader, -1));
                    break;
                case "lastModified":
                    position = checkElementOrder("lastModified", 5, position, false);
                    builder.lastModified(parseInstant("lastModified", reader, -1));
                    break;
                case "outcome":
                    position = checkElementOrder("outcome", 6, position, false);
                    builder.outcome(parseResource("outcome", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Bundle.Entry.Search parseBundleEntrySearch(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Bundle.Entry.Search.Builder builder = Bundle.Entry.Search.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "mode":
                    position = checkElementOrder("mode", 2, position, false);
                    builder.mode((SearchEntryMode) parseString(SearchEntryMode.builder(), "mode", reader, -1));
                    break;
                case "score":
                    position = checkElementOrder("score", 3, position, false);
                    builder.score(parseDecimal("score", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Bundle.Link parseBundleLink(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Bundle.Link.Builder builder = Bundle.Link.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "relation":
                    position = checkElementOrder("relation", 2, position, false);
                    builder.relation(parseString("relation", reader, -1));
                    break;
                case "url":
                    position = checkElementOrder("url", 3, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CapabilityStatement parseCapabilityStatement(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CapabilityStatement.Builder builder = CapabilityStatement.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, contactElementIndex = 0, useContextElementIndex = 0, jurisdictionElementIndex = 0, instantiatesElementIndex = 0, importsElementIndex = 0, formatElementIndex = 0, patchFormatElementIndex = 0, implementationGuideElementIndex = 0, restElementIndex = 0, messagingElementIndex = 0, documentElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "version":
                    position = checkElementOrder("version", 9, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 10, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 11, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 12, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 13, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 14, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 15, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 16, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 17, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 18, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 19, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 20, position, false);
                    builder.purpose((Markdown) parseString(Markdown.builder(), "purpose", reader, -1));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 21, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                case "kind":
                    position = checkElementOrder("kind", 22, position, false);
                    builder.kind((CapabilityStatementKind) parseString(CapabilityStatementKind.builder(), "kind", reader, -1));
                    break;
                case "instantiates":
                    position = checkElementOrder("instantiates", 23, position, true);
                    builder.instantiates((Canonical) parseUri(Canonical.builder(), "instantiates", reader, instantiatesElementIndex++));
                    break;
                case "imports":
                    position = checkElementOrder("imports", 24, position, true);
                    builder.imports((Canonical) parseUri(Canonical.builder(), "imports", reader, importsElementIndex++));
                    break;
                case "software":
                    position = checkElementOrder("software", 25, position, false);
                    builder.software(parseCapabilityStatementSoftware("software", reader, -1));
                    break;
                case "implementation":
                    position = checkElementOrder("implementation", 26, position, false);
                    builder.implementation(parseCapabilityStatementImplementation("implementation", reader, -1));
                    break;
                case "fhirVersion":
                    position = checkElementOrder("fhirVersion", 27, position, false);
                    builder.fhirVersion((FHIRVersion) parseString(FHIRVersion.builder(), "fhirVersion", reader, -1));
                    break;
                case "format":
                    position = checkElementOrder("format", 28, position, true);
                    builder.format((Code) parseString(Code.builder(), "format", reader, formatElementIndex++));
                    break;
                case "patchFormat":
                    position = checkElementOrder("patchFormat", 29, position, true);
                    builder.patchFormat((Code) parseString(Code.builder(), "patchFormat", reader, patchFormatElementIndex++));
                    break;
                case "implementationGuide":
                    position = checkElementOrder("implementationGuide", 30, position, true);
                    builder.implementationGuide((Canonical) parseUri(Canonical.builder(), "implementationGuide", reader, implementationGuideElementIndex++));
                    break;
                case "rest":
                    position = checkElementOrder("rest", 31, position, true);
                    builder.rest(parseCapabilityStatementRest("rest", reader, restElementIndex++));
                    break;
                case "messaging":
                    position = checkElementOrder("messaging", 32, position, true);
                    builder.messaging(parseCapabilityStatementMessaging("messaging", reader, messagingElementIndex++));
                    break;
                case "document":
                    position = checkElementOrder("document", 33, position, true);
                    builder.document(parseCapabilityStatementDocument("document", reader, documentElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CapabilityStatement.Document parseCapabilityStatementDocument(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CapabilityStatement.Document.Builder builder = CapabilityStatement.Document.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "mode":
                    position = checkElementOrder("mode", 2, position, false);
                    builder.mode((DocumentMode) parseString(DocumentMode.builder(), "mode", reader, -1));
                    break;
                case "documentation":
                    position = checkElementOrder("documentation", 3, position, false);
                    builder.documentation((Markdown) parseString(Markdown.builder(), "documentation", reader, -1));
                    break;
                case "profile":
                    position = checkElementOrder("profile", 4, position, false);
                    builder.profile((Canonical) parseUri(Canonical.builder(), "profile", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CapabilityStatement.Implementation parseCapabilityStatementImplementation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CapabilityStatement.Implementation.Builder builder = CapabilityStatement.Implementation.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 2, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "url":
                    position = checkElementOrder("url", 3, position, false);
                    builder.url((Url) parseUri(Url.builder(), "url", reader, -1));
                    break;
                case "custodian":
                    position = checkElementOrder("custodian", 4, position, false);
                    builder.custodian(parseReference("custodian", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CapabilityStatement.Messaging parseCapabilityStatementMessaging(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CapabilityStatement.Messaging.Builder builder = CapabilityStatement.Messaging.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, endpointElementIndex = 0, supportedMessageElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "endpoint":
                    position = checkElementOrder("endpoint", 2, position, true);
                    builder.endpoint(parseCapabilityStatementMessagingEndpoint("endpoint", reader, endpointElementIndex++));
                    break;
                case "reliableCache":
                    position = checkElementOrder("reliableCache", 3, position, false);
                    builder.reliableCache((UnsignedInt) parseInteger(UnsignedInt.builder(), "reliableCache", reader, -1));
                    break;
                case "documentation":
                    position = checkElementOrder("documentation", 4, position, false);
                    builder.documentation((Markdown) parseString(Markdown.builder(), "documentation", reader, -1));
                    break;
                case "supportedMessage":
                    position = checkElementOrder("supportedMessage", 5, position, true);
                    builder.supportedMessage(parseCapabilityStatementMessagingSupportedMessage("supportedMessage", reader, supportedMessageElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CapabilityStatement.Messaging.Endpoint parseCapabilityStatementMessagingEndpoint(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CapabilityStatement.Messaging.Endpoint.Builder builder = CapabilityStatement.Messaging.Endpoint.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "protocol":
                    position = checkElementOrder("protocol", 2, position, false);
                    builder.protocol(parseCoding("protocol", reader, -1));
                    break;
                case "address":
                    position = checkElementOrder("address", 3, position, false);
                    builder.address((Url) parseUri(Url.builder(), "address", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CapabilityStatement.Messaging.SupportedMessage parseCapabilityStatementMessagingSupportedMessage(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CapabilityStatement.Messaging.SupportedMessage.Builder builder = CapabilityStatement.Messaging.SupportedMessage.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "mode":
                    position = checkElementOrder("mode", 2, position, false);
                    builder.mode((EventCapabilityMode) parseString(EventCapabilityMode.builder(), "mode", reader, -1));
                    break;
                case "definition":
                    position = checkElementOrder("definition", 3, position, false);
                    builder.definition((Canonical) parseUri(Canonical.builder(), "definition", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CapabilityStatement.Rest parseCapabilityStatementRest(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CapabilityStatement.Rest.Builder builder = CapabilityStatement.Rest.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, resourceElementIndex = 0, interactionElementIndex = 0, searchParamElementIndex = 0, operationElementIndex = 0, compartmentElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "mode":
                    position = checkElementOrder("mode", 2, position, false);
                    builder.mode((RestfulCapabilityMode) parseString(RestfulCapabilityMode.builder(), "mode", reader, -1));
                    break;
                case "documentation":
                    position = checkElementOrder("documentation", 3, position, false);
                    builder.documentation((Markdown) parseString(Markdown.builder(), "documentation", reader, -1));
                    break;
                case "security":
                    position = checkElementOrder("security", 4, position, false);
                    builder.security(parseCapabilityStatementRestSecurity("security", reader, -1));
                    break;
                case "resource":
                    position = checkElementOrder("resource", 5, position, true);
                    builder.resource(parseCapabilityStatementRestResource("resource", reader, resourceElementIndex++));
                    break;
                case "interaction":
                    position = checkElementOrder("interaction", 6, position, true);
                    builder.interaction(parseCapabilityStatementRestInteraction("interaction", reader, interactionElementIndex++));
                    break;
                case "searchParam":
                    position = checkElementOrder("searchParam", 7, position, true);
                    builder.searchParam(parseCapabilityStatementRestResourceSearchParam("searchParam", reader, searchParamElementIndex++));
                    break;
                case "operation":
                    position = checkElementOrder("operation", 8, position, true);
                    builder.operation(parseCapabilityStatementRestResourceOperation("operation", reader, operationElementIndex++));
                    break;
                case "compartment":
                    position = checkElementOrder("compartment", 9, position, true);
                    builder.compartment((Canonical) parseUri(Canonical.builder(), "compartment", reader, compartmentElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CapabilityStatement.Rest.Interaction parseCapabilityStatementRestInteraction(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CapabilityStatement.Rest.Interaction.Builder builder = CapabilityStatement.Rest.Interaction.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code((SystemRestfulInteraction) parseString(SystemRestfulInteraction.builder(), "code", reader, -1));
                    break;
                case "documentation":
                    position = checkElementOrder("documentation", 3, position, false);
                    builder.documentation((Markdown) parseString(Markdown.builder(), "documentation", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CapabilityStatement.Rest.Resource parseCapabilityStatementRestResource(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CapabilityStatement.Rest.Resource.Builder builder = CapabilityStatement.Rest.Resource.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, supportedProfileElementIndex = 0, interactionElementIndex = 0, referencePolicyElementIndex = 0, searchIncludeElementIndex = 0, searchRevIncludeElementIndex = 0, searchParamElementIndex = 0, operationElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type((ResourceTypeCode) parseString(ResourceTypeCode.builder(), "type", reader, -1));
                    break;
                case "profile":
                    position = checkElementOrder("profile", 3, position, false);
                    builder.profile((Canonical) parseUri(Canonical.builder(), "profile", reader, -1));
                    break;
                case "supportedProfile":
                    position = checkElementOrder("supportedProfile", 4, position, true);
                    builder.supportedProfile((Canonical) parseUri(Canonical.builder(), "supportedProfile", reader, supportedProfileElementIndex++));
                    break;
                case "documentation":
                    position = checkElementOrder("documentation", 5, position, false);
                    builder.documentation((Markdown) parseString(Markdown.builder(), "documentation", reader, -1));
                    break;
                case "interaction":
                    position = checkElementOrder("interaction", 6, position, true);
                    builder.interaction(parseCapabilityStatementRestResourceInteraction("interaction", reader, interactionElementIndex++));
                    break;
                case "versioning":
                    position = checkElementOrder("versioning", 7, position, false);
                    builder.versioning((ResourceVersionPolicy) parseString(ResourceVersionPolicy.builder(), "versioning", reader, -1));
                    break;
                case "readHistory":
                    position = checkElementOrder("readHistory", 8, position, false);
                    builder.readHistory(parseBoolean("readHistory", reader, -1));
                    break;
                case "updateCreate":
                    position = checkElementOrder("updateCreate", 9, position, false);
                    builder.updateCreate(parseBoolean("updateCreate", reader, -1));
                    break;
                case "conditionalCreate":
                    position = checkElementOrder("conditionalCreate", 10, position, false);
                    builder.conditionalCreate(parseBoolean("conditionalCreate", reader, -1));
                    break;
                case "conditionalRead":
                    position = checkElementOrder("conditionalRead", 11, position, false);
                    builder.conditionalRead((ConditionalReadStatus) parseString(ConditionalReadStatus.builder(), "conditionalRead", reader, -1));
                    break;
                case "conditionalUpdate":
                    position = checkElementOrder("conditionalUpdate", 12, position, false);
                    builder.conditionalUpdate(parseBoolean("conditionalUpdate", reader, -1));
                    break;
                case "conditionalDelete":
                    position = checkElementOrder("conditionalDelete", 13, position, false);
                    builder.conditionalDelete((ConditionalDeleteStatus) parseString(ConditionalDeleteStatus.builder(), "conditionalDelete", reader, -1));
                    break;
                case "referencePolicy":
                    position = checkElementOrder("referencePolicy", 14, position, true);
                    builder.referencePolicy((ReferenceHandlingPolicy) parseString(ReferenceHandlingPolicy.builder(), "referencePolicy", reader, referencePolicyElementIndex++));
                    break;
                case "searchInclude":
                    position = checkElementOrder("searchInclude", 15, position, true);
                    builder.searchInclude(parseString("searchInclude", reader, searchIncludeElementIndex++));
                    break;
                case "searchRevInclude":
                    position = checkElementOrder("searchRevInclude", 16, position, true);
                    builder.searchRevInclude(parseString("searchRevInclude", reader, searchRevIncludeElementIndex++));
                    break;
                case "searchParam":
                    position = checkElementOrder("searchParam", 17, position, true);
                    builder.searchParam(parseCapabilityStatementRestResourceSearchParam("searchParam", reader, searchParamElementIndex++));
                    break;
                case "operation":
                    position = checkElementOrder("operation", 18, position, true);
                    builder.operation(parseCapabilityStatementRestResourceOperation("operation", reader, operationElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CapabilityStatement.Rest.Resource.Interaction parseCapabilityStatementRestResourceInteraction(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CapabilityStatement.Rest.Resource.Interaction.Builder builder = CapabilityStatement.Rest.Resource.Interaction.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code((TypeRestfulInteraction) parseString(TypeRestfulInteraction.builder(), "code", reader, -1));
                    break;
                case "documentation":
                    position = checkElementOrder("documentation", 3, position, false);
                    builder.documentation((Markdown) parseString(Markdown.builder(), "documentation", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CapabilityStatement.Rest.Resource.Operation parseCapabilityStatementRestResourceOperation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CapabilityStatement.Rest.Resource.Operation.Builder builder = CapabilityStatement.Rest.Resource.Operation.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "definition":
                    position = checkElementOrder("definition", 3, position, false);
                    builder.definition((Canonical) parseUri(Canonical.builder(), "definition", reader, -1));
                    break;
                case "documentation":
                    position = checkElementOrder("documentation", 4, position, false);
                    builder.documentation((Markdown) parseString(Markdown.builder(), "documentation", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CapabilityStatement.Rest.Resource.SearchParam parseCapabilityStatementRestResourceSearchParam(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CapabilityStatement.Rest.Resource.SearchParam.Builder builder = CapabilityStatement.Rest.Resource.SearchParam.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "definition":
                    position = checkElementOrder("definition", 3, position, false);
                    builder.definition((Canonical) parseUri(Canonical.builder(), "definition", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 4, position, false);
                    builder.type((SearchParamType) parseString(SearchParamType.builder(), "type", reader, -1));
                    break;
                case "documentation":
                    position = checkElementOrder("documentation", 5, position, false);
                    builder.documentation((Markdown) parseString(Markdown.builder(), "documentation", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CapabilityStatement.Rest.Security parseCapabilityStatementRestSecurity(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CapabilityStatement.Rest.Security.Builder builder = CapabilityStatement.Rest.Security.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, serviceElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "cors":
                    position = checkElementOrder("cors", 2, position, false);
                    builder.cors(parseBoolean("cors", reader, -1));
                    break;
                case "service":
                    position = checkElementOrder("service", 3, position, true);
                    builder.service(parseCodeableConcept("service", reader, serviceElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 4, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CapabilityStatement.Software parseCapabilityStatementSoftware(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CapabilityStatement.Software.Builder builder = CapabilityStatement.Software.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "version":
                    position = checkElementOrder("version", 3, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "releaseDate":
                    position = checkElementOrder("releaseDate", 4, position, false);
                    builder.releaseDate(parseDateTime("releaseDate", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CarePlan parseCarePlan(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CarePlan.Builder builder = CarePlan.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, instantiatesCanonicalElementIndex = 0, instantiatesUriElementIndex = 0, basedOnElementIndex = 0, replacesElementIndex = 0, partOfElementIndex = 0, categoryElementIndex = 0, contributorElementIndex = 0, careTeamElementIndex = 0, addressesElementIndex = 0, supportingInfoElementIndex = 0, goalElementIndex = 0, activityElementIndex = 0, noteElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "instantiatesCanonical":
                    position = checkElementOrder("instantiatesCanonical", 9, position, true);
                    builder.instantiatesCanonical((Canonical) parseUri(Canonical.builder(), "instantiatesCanonical", reader, instantiatesCanonicalElementIndex++));
                    break;
                case "instantiatesUri":
                    position = checkElementOrder("instantiatesUri", 10, position, true);
                    builder.instantiatesUri(parseUri("instantiatesUri", reader, instantiatesUriElementIndex++));
                    break;
                case "basedOn":
                    position = checkElementOrder("basedOn", 11, position, true);
                    builder.basedOn(parseReference("basedOn", reader, basedOnElementIndex++));
                    break;
                case "replaces":
                    position = checkElementOrder("replaces", 12, position, true);
                    builder.replaces(parseReference("replaces", reader, replacesElementIndex++));
                    break;
                case "partOf":
                    position = checkElementOrder("partOf", 13, position, true);
                    builder.partOf(parseReference("partOf", reader, partOfElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 14, position, false);
                    builder.status((CarePlanStatus) parseString(CarePlanStatus.builder(), "status", reader, -1));
                    break;
                case "intent":
                    position = checkElementOrder("intent", 15, position, false);
                    builder.intent((CarePlanIntent) parseString(CarePlanIntent.builder(), "intent", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 16, position, true);
                    builder.category(parseCodeableConcept("category", reader, categoryElementIndex++));
                    break;
                case "title":
                    position = checkElementOrder("title", 17, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 18, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 19, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 20, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 21, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                case "created":
                    position = checkElementOrder("created", 22, position, false);
                    builder.created(parseDateTime("created", reader, -1));
                    break;
                case "author":
                    position = checkElementOrder("author", 23, position, false);
                    builder.author(parseReference("author", reader, -1));
                    break;
                case "contributor":
                    position = checkElementOrder("contributor", 24, position, true);
                    builder.contributor(parseReference("contributor", reader, contributorElementIndex++));
                    break;
                case "careTeam":
                    position = checkElementOrder("careTeam", 25, position, true);
                    builder.careTeam(parseReference("careTeam", reader, careTeamElementIndex++));
                    break;
                case "addresses":
                    position = checkElementOrder("addresses", 26, position, true);
                    builder.addresses(parseReference("addresses", reader, addressesElementIndex++));
                    break;
                case "supportingInfo":
                    position = checkElementOrder("supportingInfo", 27, position, true);
                    builder.supportingInfo(parseReference("supportingInfo", reader, supportingInfoElementIndex++));
                    break;
                case "goal":
                    position = checkElementOrder("goal", 28, position, true);
                    builder.goal(parseReference("goal", reader, goalElementIndex++));
                    break;
                case "activity":
                    position = checkElementOrder("activity", 29, position, true);
                    builder.activity(parseCarePlanActivity("activity", reader, activityElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 30, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CarePlan.Activity parseCarePlanActivity(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CarePlan.Activity.Builder builder = CarePlan.Activity.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, outcomeCodeableConceptElementIndex = 0, outcomeReferenceElementIndex = 0, progressElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "outcomeCodeableConcept":
                    position = checkElementOrder("outcomeCodeableConcept", 2, position, true);
                    builder.outcomeCodeableConcept(parseCodeableConcept("outcomeCodeableConcept", reader, outcomeCodeableConceptElementIndex++));
                    break;
                case "outcomeReference":
                    position = checkElementOrder("outcomeReference", 3, position, true);
                    builder.outcomeReference(parseReference("outcomeReference", reader, outcomeReferenceElementIndex++));
                    break;
                case "progress":
                    position = checkElementOrder("progress", 4, position, true);
                    builder.progress(parseAnnotation("progress", reader, progressElementIndex++));
                    break;
                case "reference":
                    position = checkElementOrder("reference", 5, position, false);
                    builder.reference(parseReference("reference", reader, -1));
                    break;
                case "detail":
                    position = checkElementOrder("detail", 6, position, false);
                    builder.detail(parseCarePlanActivityDetail("detail", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CarePlan.Activity.Detail parseCarePlanActivityDetail(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CarePlan.Activity.Detail.Builder builder = CarePlan.Activity.Detail.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, instantiatesCanonicalElementIndex = 0, instantiatesUriElementIndex = 0, reasonCodeElementIndex = 0, reasonReferenceElementIndex = 0, goalElementIndex = 0, performerElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "kind":
                    position = checkElementOrder("kind", 2, position, false);
                    builder.kind((CarePlanActivityKind) parseString(CarePlanActivityKind.builder(), "kind", reader, -1));
                    break;
                case "instantiatesCanonical":
                    position = checkElementOrder("instantiatesCanonical", 3, position, true);
                    builder.instantiatesCanonical((Canonical) parseUri(Canonical.builder(), "instantiatesCanonical", reader, instantiatesCanonicalElementIndex++));
                    break;
                case "instantiatesUri":
                    position = checkElementOrder("instantiatesUri", 4, position, true);
                    builder.instantiatesUri(parseUri("instantiatesUri", reader, instantiatesUriElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 5, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "reasonCode":
                    position = checkElementOrder("reasonCode", 6, position, true);
                    builder.reasonCode(parseCodeableConcept("reasonCode", reader, reasonCodeElementIndex++));
                    break;
                case "reasonReference":
                    position = checkElementOrder("reasonReference", 7, position, true);
                    builder.reasonReference(parseReference("reasonReference", reader, reasonReferenceElementIndex++));
                    break;
                case "goal":
                    position = checkElementOrder("goal", 8, position, true);
                    builder.goal(parseReference("goal", reader, goalElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((CarePlanActivityStatus) parseString(CarePlanActivityStatus.builder(), "status", reader, -1));
                    break;
                case "statusReason":
                    position = checkElementOrder("statusReason", 10, position, false);
                    builder.statusReason(parseCodeableConcept("statusReason", reader, -1));
                    break;
                case "doNotPerform":
                    position = checkElementOrder("doNotPerform", 11, position, false);
                    builder.doNotPerform(parseBoolean("doNotPerform", reader, -1));
                    break;
                case "scheduledTiming":
                    position = checkElementOrder("scheduled[x]", 12, position, false);
                    builder.scheduled(parseTiming("scheduledTiming", reader, -1));
                    break;
                case "scheduledPeriod":
                    position = checkElementOrder("scheduled[x]", 12, position, false);
                    builder.scheduled(parsePeriod("scheduledPeriod", reader, -1));
                    break;
                case "scheduledString":
                    position = checkElementOrder("scheduled[x]", 12, position, false);
                    builder.scheduled(parseString("scheduledString", reader, -1));
                    break;
                case "location":
                    position = checkElementOrder("location", 13, position, false);
                    builder.location(parseReference("location", reader, -1));
                    break;
                case "performer":
                    position = checkElementOrder("performer", 14, position, true);
                    builder.performer(parseReference("performer", reader, performerElementIndex++));
                    break;
                case "productCodeableConcept":
                    position = checkElementOrder("product[x]", 15, position, false);
                    builder.product(parseCodeableConcept("productCodeableConcept", reader, -1));
                    break;
                case "productReference":
                    position = checkElementOrder("product[x]", 15, position, false);
                    builder.product(parseReference("productReference", reader, -1));
                    break;
                case "dailyAmount":
                    position = checkElementOrder("dailyAmount", 16, position, false);
                    builder.dailyAmount((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "dailyAmount", reader, -1));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 17, position, false);
                    builder.quantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "quantity", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 18, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CareTeam parseCareTeam(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CareTeam.Builder builder = CareTeam.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, categoryElementIndex = 0, participantElementIndex = 0, reasonCodeElementIndex = 0, reasonReferenceElementIndex = 0, managingOrganizationElementIndex = 0, telecomElementIndex = 0, noteElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((CareTeamStatus) parseString(CareTeamStatus.builder(), "status", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 10, position, true);
                    builder.category(parseCodeableConcept("category", reader, categoryElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 11, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 12, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 13, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 14, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                case "participant":
                    position = checkElementOrder("participant", 15, position, true);
                    builder.participant(parseCareTeamParticipant("participant", reader, participantElementIndex++));
                    break;
                case "reasonCode":
                    position = checkElementOrder("reasonCode", 16, position, true);
                    builder.reasonCode(parseCodeableConcept("reasonCode", reader, reasonCodeElementIndex++));
                    break;
                case "reasonReference":
                    position = checkElementOrder("reasonReference", 17, position, true);
                    builder.reasonReference(parseReference("reasonReference", reader, reasonReferenceElementIndex++));
                    break;
                case "managingOrganization":
                    position = checkElementOrder("managingOrganization", 18, position, true);
                    builder.managingOrganization(parseReference("managingOrganization", reader, managingOrganizationElementIndex++));
                    break;
                case "telecom":
                    position = checkElementOrder("telecom", 19, position, true);
                    builder.telecom(parseContactPoint("telecom", reader, telecomElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 20, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CareTeam.Participant parseCareTeamParticipant(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CareTeam.Participant.Builder builder = CareTeam.Participant.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, roleElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "role":
                    position = checkElementOrder("role", 2, position, true);
                    builder.role(parseCodeableConcept("role", reader, roleElementIndex++));
                    break;
                case "member":
                    position = checkElementOrder("member", 3, position, false);
                    builder.member(parseReference("member", reader, -1));
                    break;
                case "onBehalfOf":
                    position = checkElementOrder("onBehalfOf", 4, position, false);
                    builder.onBehalfOf(parseReference("onBehalfOf", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 5, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CatalogEntry parseCatalogEntry(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CatalogEntry.Builder builder = CatalogEntry.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, additionalIdentifierElementIndex = 0, classificationElementIndex = 0, additionalCharacteristicElementIndex = 0, additionalClassificationElementIndex = 0, relatedEntryElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 9, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "orderable":
                    position = checkElementOrder("orderable", 10, position, false);
                    builder.orderable(parseBoolean("orderable", reader, -1));
                    break;
                case "referencedItem":
                    position = checkElementOrder("referencedItem", 11, position, false);
                    builder.referencedItem(parseReference("referencedItem", reader, -1));
                    break;
                case "additionalIdentifier":
                    position = checkElementOrder("additionalIdentifier", 12, position, true);
                    builder.additionalIdentifier(parseIdentifier("additionalIdentifier", reader, additionalIdentifierElementIndex++));
                    break;
                case "classification":
                    position = checkElementOrder("classification", 13, position, true);
                    builder.classification(parseCodeableConcept("classification", reader, classificationElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 14, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "validityPeriod":
                    position = checkElementOrder("validityPeriod", 15, position, false);
                    builder.validityPeriod(parsePeriod("validityPeriod", reader, -1));
                    break;
                case "validTo":
                    position = checkElementOrder("validTo", 16, position, false);
                    builder.validTo(parseDateTime("validTo", reader, -1));
                    break;
                case "lastUpdated":
                    position = checkElementOrder("lastUpdated", 17, position, false);
                    builder.lastUpdated(parseDateTime("lastUpdated", reader, -1));
                    break;
                case "additionalCharacteristic":
                    position = checkElementOrder("additionalCharacteristic", 18, position, true);
                    builder.additionalCharacteristic(parseCodeableConcept("additionalCharacteristic", reader, additionalCharacteristicElementIndex++));
                    break;
                case "additionalClassification":
                    position = checkElementOrder("additionalClassification", 19, position, true);
                    builder.additionalClassification(parseCodeableConcept("additionalClassification", reader, additionalClassificationElementIndex++));
                    break;
                case "relatedEntry":
                    position = checkElementOrder("relatedEntry", 20, position, true);
                    builder.relatedEntry(parseCatalogEntryRelatedEntry("relatedEntry", reader, relatedEntryElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CatalogEntry.RelatedEntry parseCatalogEntryRelatedEntry(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CatalogEntry.RelatedEntry.Builder builder = CatalogEntry.RelatedEntry.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "relationtype":
                    position = checkElementOrder("relationtype", 2, position, false);
                    builder.relationtype((CatalogEntryRelationType) parseString(CatalogEntryRelationType.builder(), "relationtype", reader, -1));
                    break;
                case "item":
                    position = checkElementOrder("item", 3, position, false);
                    builder.item(parseReference("item", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ChargeItem parseChargeItem(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ChargeItem.Builder builder = ChargeItem.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, definitionUriElementIndex = 0, definitionCanonicalElementIndex = 0, partOfElementIndex = 0, performerElementIndex = 0, bodysiteElementIndex = 0, reasonElementIndex = 0, serviceElementIndex = 0, accountElementIndex = 0, noteElementIndex = 0, supportingInformationElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "definitionUri":
                    position = checkElementOrder("definitionUri", 9, position, true);
                    builder.definitionUri(parseUri("definitionUri", reader, definitionUriElementIndex++));
                    break;
                case "definitionCanonical":
                    position = checkElementOrder("definitionCanonical", 10, position, true);
                    builder.definitionCanonical((Canonical) parseUri(Canonical.builder(), "definitionCanonical", reader, definitionCanonicalElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 11, position, false);
                    builder.status((ChargeItemStatus) parseString(ChargeItemStatus.builder(), "status", reader, -1));
                    break;
                case "partOf":
                    position = checkElementOrder("partOf", 12, position, true);
                    builder.partOf(parseReference("partOf", reader, partOfElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 13, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 14, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "context":
                    position = checkElementOrder("context", 15, position, false);
                    builder.context(parseReference("context", reader, -1));
                    break;
                case "occurrenceDateTime":
                    position = checkElementOrder("occurrence[x]", 16, position, false);
                    builder.occurrence(parseDateTime("occurrenceDateTime", reader, -1));
                    break;
                case "occurrencePeriod":
                    position = checkElementOrder("occurrence[x]", 16, position, false);
                    builder.occurrence(parsePeriod("occurrencePeriod", reader, -1));
                    break;
                case "occurrenceTiming":
                    position = checkElementOrder("occurrence[x]", 16, position, false);
                    builder.occurrence(parseTiming("occurrenceTiming", reader, -1));
                    break;
                case "performer":
                    position = checkElementOrder("performer", 17, position, true);
                    builder.performer(parseChargeItemPerformer("performer", reader, performerElementIndex++));
                    break;
                case "performingOrganization":
                    position = checkElementOrder("performingOrganization", 18, position, false);
                    builder.performingOrganization(parseReference("performingOrganization", reader, -1));
                    break;
                case "requestingOrganization":
                    position = checkElementOrder("requestingOrganization", 19, position, false);
                    builder.requestingOrganization(parseReference("requestingOrganization", reader, -1));
                    break;
                case "costCenter":
                    position = checkElementOrder("costCenter", 20, position, false);
                    builder.costCenter(parseReference("costCenter", reader, -1));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 21, position, false);
                    builder.quantity(parseQuantity("quantity", reader, -1));
                    break;
                case "bodysite":
                    position = checkElementOrder("bodysite", 22, position, true);
                    builder.bodysite(parseCodeableConcept("bodysite", reader, bodysiteElementIndex++));
                    break;
                case "factorOverride":
                    position = checkElementOrder("factorOverride", 23, position, false);
                    builder.factorOverride(parseDecimal("factorOverride", reader, -1));
                    break;
                case "priceOverride":
                    position = checkElementOrder("priceOverride", 24, position, false);
                    builder.priceOverride(parseMoney("priceOverride", reader, -1));
                    break;
                case "overrideReason":
                    position = checkElementOrder("overrideReason", 25, position, false);
                    builder.overrideReason(parseString("overrideReason", reader, -1));
                    break;
                case "enterer":
                    position = checkElementOrder("enterer", 26, position, false);
                    builder.enterer(parseReference("enterer", reader, -1));
                    break;
                case "enteredDate":
                    position = checkElementOrder("enteredDate", 27, position, false);
                    builder.enteredDate(parseDateTime("enteredDate", reader, -1));
                    break;
                case "reason":
                    position = checkElementOrder("reason", 28, position, true);
                    builder.reason(parseCodeableConcept("reason", reader, reasonElementIndex++));
                    break;
                case "service":
                    position = checkElementOrder("service", 29, position, true);
                    builder.service(parseReference("service", reader, serviceElementIndex++));
                    break;
                case "productReference":
                    position = checkElementOrder("product[x]", 30, position, false);
                    builder.product(parseReference("productReference", reader, -1));
                    break;
                case "productCodeableConcept":
                    position = checkElementOrder("product[x]", 30, position, false);
                    builder.product(parseCodeableConcept("productCodeableConcept", reader, -1));
                    break;
                case "account":
                    position = checkElementOrder("account", 31, position, true);
                    builder.account(parseReference("account", reader, accountElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 32, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "supportingInformation":
                    position = checkElementOrder("supportingInformation", 33, position, true);
                    builder.supportingInformation(parseReference("supportingInformation", reader, supportingInformationElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ChargeItem.Performer parseChargeItemPerformer(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ChargeItem.Performer.Builder builder = ChargeItem.Performer.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "function":
                    position = checkElementOrder("function", 2, position, false);
                    builder.function(parseCodeableConcept("function", reader, -1));
                    break;
                case "actor":
                    position = checkElementOrder("actor", 3, position, false);
                    builder.actor(parseReference("actor", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ChargeItemDefinition parseChargeItemDefinition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ChargeItemDefinition.Builder builder = ChargeItemDefinition.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, derivedFromUriElementIndex = 0, partOfElementIndex = 0, replacesElementIndex = 0, contactElementIndex = 0, useContextElementIndex = 0, jurisdictionElementIndex = 0, instanceElementIndex = 0, applicabilityElementIndex = 0, propertyGroupElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 10, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 11, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "derivedFromUri":
                    position = checkElementOrder("derivedFromUri", 12, position, true);
                    builder.derivedFromUri(parseUri("derivedFromUri", reader, derivedFromUriElementIndex++));
                    break;
                case "partOf":
                    position = checkElementOrder("partOf", 13, position, true);
                    builder.partOf((Canonical) parseUri(Canonical.builder(), "partOf", reader, partOfElementIndex++));
                    break;
                case "replaces":
                    position = checkElementOrder("replaces", 14, position, true);
                    builder.replaces((Canonical) parseUri(Canonical.builder(), "replaces", reader, replacesElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 15, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 16, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 17, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 18, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 19, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 20, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 21, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 22, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 23, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                case "approvalDate":
                    position = checkElementOrder("approvalDate", 24, position, false);
                    builder.approvalDate(parseDate("approvalDate", reader, -1));
                    break;
                case "lastReviewDate":
                    position = checkElementOrder("lastReviewDate", 25, position, false);
                    builder.lastReviewDate(parseDate("lastReviewDate", reader, -1));
                    break;
                case "effectivePeriod":
                    position = checkElementOrder("effectivePeriod", 26, position, false);
                    builder.effectivePeriod(parsePeriod("effectivePeriod", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 27, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "instance":
                    position = checkElementOrder("instance", 28, position, true);
                    builder.instance(parseReference("instance", reader, instanceElementIndex++));
                    break;
                case "applicability":
                    position = checkElementOrder("applicability", 29, position, true);
                    builder.applicability(parseChargeItemDefinitionApplicability("applicability", reader, applicabilityElementIndex++));
                    break;
                case "propertyGroup":
                    position = checkElementOrder("propertyGroup", 30, position, true);
                    builder.propertyGroup(parseChargeItemDefinitionPropertyGroup("propertyGroup", reader, propertyGroupElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ChargeItemDefinition.Applicability parseChargeItemDefinitionApplicability(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ChargeItemDefinition.Applicability.Builder builder = ChargeItemDefinition.Applicability.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 2, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language(parseString("language", reader, -1));
                    break;
                case "expression":
                    position = checkElementOrder("expression", 4, position, false);
                    builder.expression(parseString("expression", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ChargeItemDefinition.PropertyGroup parseChargeItemDefinitionPropertyGroup(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ChargeItemDefinition.PropertyGroup.Builder builder = ChargeItemDefinition.PropertyGroup.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, applicabilityElementIndex = 0, priceComponentElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "applicability":
                    position = checkElementOrder("applicability", 2, position, true);
                    builder.applicability(parseChargeItemDefinitionApplicability("applicability", reader, applicabilityElementIndex++));
                    break;
                case "priceComponent":
                    position = checkElementOrder("priceComponent", 3, position, true);
                    builder.priceComponent(parseChargeItemDefinitionPropertyGroupPriceComponent("priceComponent", reader, priceComponentElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ChargeItemDefinition.PropertyGroup.PriceComponent parseChargeItemDefinitionPropertyGroupPriceComponent(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ChargeItemDefinition.PropertyGroup.PriceComponent.Builder builder = ChargeItemDefinition.PropertyGroup.PriceComponent.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type((ChargeItemDefinitionPriceComponentType) parseString(ChargeItemDefinitionPriceComponentType.builder(), "type", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 3, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "factor":
                    position = checkElementOrder("factor", 4, position, false);
                    builder.factor(parseDecimal("factor", reader, -1));
                    break;
                case "amount":
                    position = checkElementOrder("amount", 5, position, false);
                    builder.amount(parseMoney("amount", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Citation parseCitation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Citation.Builder builder = Citation.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, contactElementIndex = 0, useContextElementIndex = 0, jurisdictionElementIndex = 0, authorElementIndex = 0, editorElementIndex = 0, reviewerElementIndex = 0, endorserElementIndex = 0, summaryElementIndex = 0, classificationElementIndex = 0, noteElementIndex = 0, currentStateElementIndex = 0, statusDateElementIndex = 0, relatesToElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 10, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 11, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 12, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 13, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 14, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 15, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 16, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 17, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 18, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 19, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 20, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 21, position, false);
                    builder.purpose((Markdown) parseString(Markdown.builder(), "purpose", reader, -1));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 22, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                case "approvalDate":
                    position = checkElementOrder("approvalDate", 23, position, false);
                    builder.approvalDate(parseDate("approvalDate", reader, -1));
                    break;
                case "lastReviewDate":
                    position = checkElementOrder("lastReviewDate", 24, position, false);
                    builder.lastReviewDate(parseDate("lastReviewDate", reader, -1));
                    break;
                case "effectivePeriod":
                    position = checkElementOrder("effectivePeriod", 25, position, false);
                    builder.effectivePeriod(parsePeriod("effectivePeriod", reader, -1));
                    break;
                case "author":
                    position = checkElementOrder("author", 26, position, true);
                    builder.author(parseContactDetail("author", reader, authorElementIndex++));
                    break;
                case "editor":
                    position = checkElementOrder("editor", 27, position, true);
                    builder.editor(parseContactDetail("editor", reader, editorElementIndex++));
                    break;
                case "reviewer":
                    position = checkElementOrder("reviewer", 28, position, true);
                    builder.reviewer(parseContactDetail("reviewer", reader, reviewerElementIndex++));
                    break;
                case "endorser":
                    position = checkElementOrder("endorser", 29, position, true);
                    builder.endorser(parseContactDetail("endorser", reader, endorserElementIndex++));
                    break;
                case "summary":
                    position = checkElementOrder("summary", 30, position, true);
                    builder.summary(parseContactDetail("summary", reader, summaryElementIndex++));
                    break;
                case "classification":
                    position = checkElementOrder("classification", 31, position, true);
                    builder.classification(parseCitationClassification("classification", reader, classificationElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 32, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "currentState":
                    position = checkElementOrder("currentState", 33, position, true);
                    builder.currentState(parseCodeableConcept("currentState", reader, currentStateElementIndex++));
                    break;
                case "statusDate":
                    position = checkElementOrder("statusDate", 34, position, true);
                    builder.statusDate(parseCitationStatusDate("statusDate", reader, statusDateElementIndex++));
                    break;
                case "relatesTo":
                    position = checkElementOrder("relatesTo", 35, position, true);
                    builder.relatesTo(parseCitationRelatesTo("relatesTo", reader, relatesToElementIndex++));
                    break;
                case "citedArtifact":
                    position = checkElementOrder("citedArtifact", 36, position, false);
                    builder.citedArtifact(parseCitationCitedArtifact("citedArtifact", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Citation.CitedArtifact parseCitationCitedArtifact(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Citation.CitedArtifact.Builder builder = Citation.CitedArtifact.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, relatedIdentifierElementIndex = 0, currentStateElementIndex = 0, statusDateElementIndex = 0, titleElementIndex = 0, abstractElementIndex = 0, relatesToElementIndex = 0, publicationFormElementIndex = 0, webLocationElementIndex = 0, classificationElementIndex = 0, noteElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 2, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "relatedIdentifier":
                    position = checkElementOrder("relatedIdentifier", 3, position, true);
                    builder.relatedIdentifier(parseIdentifier("relatedIdentifier", reader, relatedIdentifierElementIndex++));
                    break;
                case "dateAccessed":
                    position = checkElementOrder("dateAccessed", 4, position, false);
                    builder.dateAccessed(parseDateTime("dateAccessed", reader, -1));
                    break;
                case "version":
                    position = checkElementOrder("version", 5, position, false);
                    builder.version(parseCitationCitedArtifactVersion("version", reader, -1));
                    break;
                case "currentState":
                    position = checkElementOrder("currentState", 6, position, true);
                    builder.currentState(parseCodeableConcept("currentState", reader, currentStateElementIndex++));
                    break;
                case "statusDate":
                    position = checkElementOrder("statusDate", 7, position, true);
                    builder.statusDate(parseCitationCitedArtifactStatusDate("statusDate", reader, statusDateElementIndex++));
                    break;
                case "title":
                    position = checkElementOrder("title", 8, position, true);
                    builder.title(parseCitationCitedArtifactTitle("title", reader, titleElementIndex++));
                    break;
                case "abstract":
                    position = checkElementOrder("abstract", 9, position, true);
                    builder._abstract(parseCitationCitedArtifactAbstract("abstract", reader, abstractElementIndex++));
                    break;
                case "part":
                    position = checkElementOrder("part", 10, position, false);
                    builder.part(parseCitationCitedArtifactPart("part", reader, -1));
                    break;
                case "relatesTo":
                    position = checkElementOrder("relatesTo", 11, position, true);
                    builder.relatesTo(parseCitationCitedArtifactRelatesTo("relatesTo", reader, relatesToElementIndex++));
                    break;
                case "publicationForm":
                    position = checkElementOrder("publicationForm", 12, position, true);
                    builder.publicationForm(parseCitationCitedArtifactPublicationForm("publicationForm", reader, publicationFormElementIndex++));
                    break;
                case "webLocation":
                    position = checkElementOrder("webLocation", 13, position, true);
                    builder.webLocation(parseCitationCitedArtifactWebLocation("webLocation", reader, webLocationElementIndex++));
                    break;
                case "classification":
                    position = checkElementOrder("classification", 14, position, true);
                    builder.classification(parseCitationCitedArtifactClassification("classification", reader, classificationElementIndex++));
                    break;
                case "contributorship":
                    position = checkElementOrder("contributorship", 15, position, false);
                    builder.contributorship(parseCitationCitedArtifactContributorship("contributorship", reader, -1));
                    break;
                case "note":
                    position = checkElementOrder("note", 16, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Citation.CitedArtifact.Abstract parseCitationCitedArtifactAbstract(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Citation.CitedArtifact.Abstract.Builder builder = Citation.CitedArtifact.Abstract.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language(parseCodeableConcept("language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text((Markdown) parseString(Markdown.builder(), "text", reader, -1));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 5, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Citation.CitedArtifact.Classification parseCitationCitedArtifactClassification(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Citation.CitedArtifact.Classification.Builder builder = Citation.CitedArtifact.Classification.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, classifierElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "classifier":
                    position = checkElementOrder("classifier", 3, position, true);
                    builder.classifier(parseCodeableConcept("classifier", reader, classifierElementIndex++));
                    break;
                case "whoClassified":
                    position = checkElementOrder("whoClassified", 4, position, false);
                    builder.whoClassified(parseCitationCitedArtifactClassificationWhoClassified("whoClassified", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Citation.CitedArtifact.Classification.WhoClassified parseCitationCitedArtifactClassificationWhoClassified(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Citation.CitedArtifact.Classification.WhoClassified.Builder builder = Citation.CitedArtifact.Classification.WhoClassified.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "person":
                    position = checkElementOrder("person", 2, position, false);
                    builder.person(parseReference("person", reader, -1));
                    break;
                case "organization":
                    position = checkElementOrder("organization", 3, position, false);
                    builder.organization(parseReference("organization", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 4, position, false);
                    builder.publisher(parseReference("publisher", reader, -1));
                    break;
                case "classifierCopyright":
                    position = checkElementOrder("classifierCopyright", 5, position, false);
                    builder.classifierCopyright(parseString("classifierCopyright", reader, -1));
                    break;
                case "freeToShare":
                    position = checkElementOrder("freeToShare", 6, position, false);
                    builder.freeToShare(parseBoolean("freeToShare", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Citation.CitedArtifact.Contributorship parseCitationCitedArtifactContributorship(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Citation.CitedArtifact.Contributorship.Builder builder = Citation.CitedArtifact.Contributorship.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, entryElementIndex = 0, summaryElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "complete":
                    position = checkElementOrder("complete", 2, position, false);
                    builder.complete(parseBoolean("complete", reader, -1));
                    break;
                case "entry":
                    position = checkElementOrder("entry", 3, position, true);
                    builder.entry(parseCitationCitedArtifactContributorshipEntry("entry", reader, entryElementIndex++));
                    break;
                case "summary":
                    position = checkElementOrder("summary", 4, position, true);
                    builder.summary(parseCitationCitedArtifactContributorshipSummary("summary", reader, summaryElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Citation.CitedArtifact.Contributorship.Entry parseCitationCitedArtifactContributorshipEntry(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Citation.CitedArtifact.Contributorship.Entry.Builder builder = Citation.CitedArtifact.Contributorship.Entry.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, affiliationInfoElementIndex = 0, addressElementIndex = 0, telecomElementIndex = 0, contributionTypeElementIndex = 0, contributionInstanceElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name(parseHumanName("name", reader, -1));
                    break;
                case "initials":
                    position = checkElementOrder("initials", 3, position, false);
                    builder.initials(parseString("initials", reader, -1));
                    break;
                case "collectiveName":
                    position = checkElementOrder("collectiveName", 4, position, false);
                    builder.collectiveName(parseString("collectiveName", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 5, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "affiliationInfo":
                    position = checkElementOrder("affiliationInfo", 6, position, true);
                    builder.affiliationInfo(parseCitationCitedArtifactContributorshipEntryAffiliationInfo("affiliationInfo", reader, affiliationInfoElementIndex++));
                    break;
                case "address":
                    position = checkElementOrder("address", 7, position, true);
                    builder.address(parseAddress("address", reader, addressElementIndex++));
                    break;
                case "telecom":
                    position = checkElementOrder("telecom", 8, position, true);
                    builder.telecom(parseContactPoint("telecom", reader, telecomElementIndex++));
                    break;
                case "contributionType":
                    position = checkElementOrder("contributionType", 9, position, true);
                    builder.contributionType(parseCodeableConcept("contributionType", reader, contributionTypeElementIndex++));
                    break;
                case "role":
                    position = checkElementOrder("role", 10, position, false);
                    builder.role(parseCodeableConcept("role", reader, -1));
                    break;
                case "contributionInstance":
                    position = checkElementOrder("contributionInstance", 11, position, true);
                    builder.contributionInstance(parseCitationCitedArtifactContributorshipEntryContributionInstance("contributionInstance", reader, contributionInstanceElementIndex++));
                    break;
                case "correspondingContact":
                    position = checkElementOrder("correspondingContact", 12, position, false);
                    builder.correspondingContact(parseBoolean("correspondingContact", reader, -1));
                    break;
                case "listOrder":
                    position = checkElementOrder("listOrder", 13, position, false);
                    builder.listOrder((PositiveInt) parseInteger(PositiveInt.builder(), "listOrder", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Citation.CitedArtifact.Contributorship.Entry.AffiliationInfo parseCitationCitedArtifactContributorshipEntryAffiliationInfo(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Citation.CitedArtifact.Contributorship.Entry.AffiliationInfo.Builder builder = Citation.CitedArtifact.Contributorship.Entry.AffiliationInfo.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "affiliation":
                    position = checkElementOrder("affiliation", 2, position, false);
                    builder.affiliation(parseString("affiliation", reader, -1));
                    break;
                case "role":
                    position = checkElementOrder("role", 3, position, false);
                    builder.role(parseString("role", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 4, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Citation.CitedArtifact.Contributorship.Entry.ContributionInstance parseCitationCitedArtifactContributorshipEntryContributionInstance(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Citation.CitedArtifact.Contributorship.Entry.ContributionInstance.Builder builder = Citation.CitedArtifact.Contributorship.Entry.ContributionInstance.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "time":
                    position = checkElementOrder("time", 3, position, false);
                    builder.time(parseDateTime("time", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Citation.CitedArtifact.Contributorship.Summary parseCitationCitedArtifactContributorshipSummary(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Citation.CitedArtifact.Contributorship.Summary.Builder builder = Citation.CitedArtifact.Contributorship.Summary.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "style":
                    position = checkElementOrder("style", 3, position, false);
                    builder.style(parseCodeableConcept("style", reader, -1));
                    break;
                case "source":
                    position = checkElementOrder("source", 4, position, false);
                    builder.source(parseCodeableConcept("source", reader, -1));
                    break;
                case "value":
                    position = checkElementOrder("value", 5, position, false);
                    builder.value((Markdown) parseString(Markdown.builder(), "value", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Citation.CitedArtifact.Part parseCitationCitedArtifactPart(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Citation.CitedArtifact.Part.Builder builder = Citation.CitedArtifact.Part.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "value":
                    position = checkElementOrder("value", 3, position, false);
                    builder.value(parseString("value", reader, -1));
                    break;
                case "baseCitation":
                    position = checkElementOrder("baseCitation", 4, position, false);
                    builder.baseCitation(parseReference("baseCitation", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Citation.CitedArtifact.PublicationForm parseCitationCitedArtifactPublicationForm(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Citation.CitedArtifact.PublicationForm.Builder builder = Citation.CitedArtifact.PublicationForm.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, languageElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "publishedIn":
                    position = checkElementOrder("publishedIn", 2, position, false);
                    builder.publishedIn(parseCitationCitedArtifactPublicationFormPublishedIn("publishedIn", reader, -1));
                    break;
                case "periodicRelease":
                    position = checkElementOrder("periodicRelease", 3, position, false);
                    builder.periodicRelease(parseCitationCitedArtifactPublicationFormPeriodicRelease("periodicRelease", reader, -1));
                    break;
                case "articleDate":
                    position = checkElementOrder("articleDate", 4, position, false);
                    builder.articleDate(parseDateTime("articleDate", reader, -1));
                    break;
                case "lastRevisionDate":
                    position = checkElementOrder("lastRevisionDate", 5, position, false);
                    builder.lastRevisionDate(parseDateTime("lastRevisionDate", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 6, position, true);
                    builder.language(parseCodeableConcept("language", reader, languageElementIndex++));
                    break;
                case "accessionNumber":
                    position = checkElementOrder("accessionNumber", 7, position, false);
                    builder.accessionNumber(parseString("accessionNumber", reader, -1));
                    break;
                case "pageString":
                    position = checkElementOrder("pageString", 8, position, false);
                    builder.pageString(parseString("pageString", reader, -1));
                    break;
                case "firstPage":
                    position = checkElementOrder("firstPage", 9, position, false);
                    builder.firstPage(parseString("firstPage", reader, -1));
                    break;
                case "lastPage":
                    position = checkElementOrder("lastPage", 10, position, false);
                    builder.lastPage(parseString("lastPage", reader, -1));
                    break;
                case "pageCount":
                    position = checkElementOrder("pageCount", 11, position, false);
                    builder.pageCount(parseString("pageCount", reader, -1));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 12, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Citation.CitedArtifact.PublicationForm.PeriodicRelease parseCitationCitedArtifactPublicationFormPeriodicRelease(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Citation.CitedArtifact.PublicationForm.PeriodicRelease.Builder builder = Citation.CitedArtifact.PublicationForm.PeriodicRelease.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "citedMedium":
                    position = checkElementOrder("citedMedium", 2, position, false);
                    builder.citedMedium(parseCodeableConcept("citedMedium", reader, -1));
                    break;
                case "volume":
                    position = checkElementOrder("volume", 3, position, false);
                    builder.volume(parseString("volume", reader, -1));
                    break;
                case "issue":
                    position = checkElementOrder("issue", 4, position, false);
                    builder.issue(parseString("issue", reader, -1));
                    break;
                case "dateOfPublication":
                    position = checkElementOrder("dateOfPublication", 5, position, false);
                    builder.dateOfPublication(parseCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication("dateOfPublication", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Citation.CitedArtifact.PublicationForm.PeriodicRelease.DateOfPublication parseCitationCitedArtifactPublicationFormPeriodicReleaseDateOfPublication(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Citation.CitedArtifact.PublicationForm.PeriodicRelease.DateOfPublication.Builder builder = Citation.CitedArtifact.PublicationForm.PeriodicRelease.DateOfPublication.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "date":
                    position = checkElementOrder("date", 2, position, false);
                    builder.date(parseDate("date", reader, -1));
                    break;
                case "year":
                    position = checkElementOrder("year", 3, position, false);
                    builder.year(parseString("year", reader, -1));
                    break;
                case "month":
                    position = checkElementOrder("month", 4, position, false);
                    builder.month(parseString("month", reader, -1));
                    break;
                case "day":
                    position = checkElementOrder("day", 5, position, false);
                    builder.day(parseString("day", reader, -1));
                    break;
                case "season":
                    position = checkElementOrder("season", 6, position, false);
                    builder.season(parseString("season", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 7, position, false);
                    builder.text(parseString("text", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Citation.CitedArtifact.PublicationForm.PublishedIn parseCitationCitedArtifactPublicationFormPublishedIn(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Citation.CitedArtifact.PublicationForm.PublishedIn.Builder builder = Citation.CitedArtifact.PublicationForm.PublishedIn.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 3, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "title":
                    position = checkElementOrder("title", 4, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 5, position, false);
                    builder.publisher(parseReference("publisher", reader, -1));
                    break;
                case "publisherLocation":
                    position = checkElementOrder("publisherLocation", 6, position, false);
                    builder.publisherLocation(parseString("publisherLocation", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Citation.CitedArtifact.RelatesTo parseCitationCitedArtifactRelatesTo(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Citation.CitedArtifact.RelatesTo.Builder builder = Citation.CitedArtifact.RelatesTo.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, targetClassifierElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "relationshipType":
                    position = checkElementOrder("relationshipType", 2, position, false);
                    builder.relationshipType(parseCodeableConcept("relationshipType", reader, -1));
                    break;
                case "targetClassifier":
                    position = checkElementOrder("targetClassifier", 3, position, true);
                    builder.targetClassifier(parseCodeableConcept("targetClassifier", reader, targetClassifierElementIndex++));
                    break;
                case "targetUri":
                    position = checkElementOrder("target[x]", 4, position, false);
                    builder.target(parseUri("targetUri", reader, -1));
                    break;
                case "targetIdentifier":
                    position = checkElementOrder("target[x]", 4, position, false);
                    builder.target(parseIdentifier("targetIdentifier", reader, -1));
                    break;
                case "targetReference":
                    position = checkElementOrder("target[x]", 4, position, false);
                    builder.target(parseReference("targetReference", reader, -1));
                    break;
                case "targetAttachment":
                    position = checkElementOrder("target[x]", 4, position, false);
                    builder.target(parseAttachment("targetAttachment", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Citation.CitedArtifact.StatusDate parseCitationCitedArtifactStatusDate(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Citation.CitedArtifact.StatusDate.Builder builder = Citation.CitedArtifact.StatusDate.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "activity":
                    position = checkElementOrder("activity", 2, position, false);
                    builder.activity(parseCodeableConcept("activity", reader, -1));
                    break;
                case "actual":
                    position = checkElementOrder("actual", 3, position, false);
                    builder.actual(parseBoolean("actual", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 4, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Citation.CitedArtifact.Title parseCitationCitedArtifactTitle(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Citation.CitedArtifact.Title.Builder builder = Citation.CitedArtifact.Title.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, typeElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, true);
                    builder.type(parseCodeableConcept("type", reader, typeElementIndex++));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language(parseCodeableConcept("language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text((Markdown) parseString(Markdown.builder(), "text", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Citation.CitedArtifact.Version parseCitationCitedArtifactVersion(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Citation.CitedArtifact.Version.Builder builder = Citation.CitedArtifact.Version.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "value":
                    position = checkElementOrder("value", 2, position, false);
                    builder.value(parseString("value", reader, -1));
                    break;
                case "baseCitation":
                    position = checkElementOrder("baseCitation", 3, position, false);
                    builder.baseCitation(parseReference("baseCitation", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Citation.CitedArtifact.WebLocation parseCitationCitedArtifactWebLocation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Citation.CitedArtifact.WebLocation.Builder builder = Citation.CitedArtifact.WebLocation.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "url":
                    position = checkElementOrder("url", 3, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Citation.Classification parseCitationClassification(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Citation.Classification.Builder builder = Citation.Classification.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, classifierElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "classifier":
                    position = checkElementOrder("classifier", 3, position, true);
                    builder.classifier(parseCodeableConcept("classifier", reader, classifierElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Citation.RelatesTo parseCitationRelatesTo(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Citation.RelatesTo.Builder builder = Citation.RelatesTo.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, targetClassifierElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "relationshipType":
                    position = checkElementOrder("relationshipType", 2, position, false);
                    builder.relationshipType(parseCodeableConcept("relationshipType", reader, -1));
                    break;
                case "targetClassifier":
                    position = checkElementOrder("targetClassifier", 3, position, true);
                    builder.targetClassifier(parseCodeableConcept("targetClassifier", reader, targetClassifierElementIndex++));
                    break;
                case "targetUri":
                    position = checkElementOrder("target[x]", 4, position, false);
                    builder.target(parseUri("targetUri", reader, -1));
                    break;
                case "targetIdentifier":
                    position = checkElementOrder("target[x]", 4, position, false);
                    builder.target(parseIdentifier("targetIdentifier", reader, -1));
                    break;
                case "targetReference":
                    position = checkElementOrder("target[x]", 4, position, false);
                    builder.target(parseReference("targetReference", reader, -1));
                    break;
                case "targetAttachment":
                    position = checkElementOrder("target[x]", 4, position, false);
                    builder.target(parseAttachment("targetAttachment", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Citation.StatusDate parseCitationStatusDate(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Citation.StatusDate.Builder builder = Citation.StatusDate.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "activity":
                    position = checkElementOrder("activity", 2, position, false);
                    builder.activity(parseCodeableConcept("activity", reader, -1));
                    break;
                case "actual":
                    position = checkElementOrder("actual", 3, position, false);
                    builder.actual(parseBoolean("actual", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 4, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Claim parseClaim(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Claim.Builder builder = Claim.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, relatedElementIndex = 0, careTeamElementIndex = 0, supportingInfoElementIndex = 0, diagnosisElementIndex = 0, procedureElementIndex = 0, insuranceElementIndex = 0, itemElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((ClaimStatus) parseString(ClaimStatus.builder(), "status", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 10, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "subType":
                    position = checkElementOrder("subType", 11, position, false);
                    builder.subType(parseCodeableConcept("subType", reader, -1));
                    break;
                case "use":
                    position = checkElementOrder("use", 12, position, false);
                    builder.use((Use) parseString(Use.builder(), "use", reader, -1));
                    break;
                case "patient":
                    position = checkElementOrder("patient", 13, position, false);
                    builder.patient(parseReference("patient", reader, -1));
                    break;
                case "billablePeriod":
                    position = checkElementOrder("billablePeriod", 14, position, false);
                    builder.billablePeriod(parsePeriod("billablePeriod", reader, -1));
                    break;
                case "created":
                    position = checkElementOrder("created", 15, position, false);
                    builder.created(parseDateTime("created", reader, -1));
                    break;
                case "enterer":
                    position = checkElementOrder("enterer", 16, position, false);
                    builder.enterer(parseReference("enterer", reader, -1));
                    break;
                case "insurer":
                    position = checkElementOrder("insurer", 17, position, false);
                    builder.insurer(parseReference("insurer", reader, -1));
                    break;
                case "provider":
                    position = checkElementOrder("provider", 18, position, false);
                    builder.provider(parseReference("provider", reader, -1));
                    break;
                case "priority":
                    position = checkElementOrder("priority", 19, position, false);
                    builder.priority(parseCodeableConcept("priority", reader, -1));
                    break;
                case "fundsReserve":
                    position = checkElementOrder("fundsReserve", 20, position, false);
                    builder.fundsReserve(parseCodeableConcept("fundsReserve", reader, -1));
                    break;
                case "related":
                    position = checkElementOrder("related", 21, position, true);
                    builder.related(parseClaimRelated("related", reader, relatedElementIndex++));
                    break;
                case "prescription":
                    position = checkElementOrder("prescription", 22, position, false);
                    builder.prescription(parseReference("prescription", reader, -1));
                    break;
                case "originalPrescription":
                    position = checkElementOrder("originalPrescription", 23, position, false);
                    builder.originalPrescription(parseReference("originalPrescription", reader, -1));
                    break;
                case "payee":
                    position = checkElementOrder("payee", 24, position, false);
                    builder.payee(parseClaimPayee("payee", reader, -1));
                    break;
                case "referral":
                    position = checkElementOrder("referral", 25, position, false);
                    builder.referral(parseReference("referral", reader, -1));
                    break;
                case "facility":
                    position = checkElementOrder("facility", 26, position, false);
                    builder.facility(parseReference("facility", reader, -1));
                    break;
                case "careTeam":
                    position = checkElementOrder("careTeam", 27, position, true);
                    builder.careTeam(parseClaimCareTeam("careTeam", reader, careTeamElementIndex++));
                    break;
                case "supportingInfo":
                    position = checkElementOrder("supportingInfo", 28, position, true);
                    builder.supportingInfo(parseClaimSupportingInfo("supportingInfo", reader, supportingInfoElementIndex++));
                    break;
                case "diagnosis":
                    position = checkElementOrder("diagnosis", 29, position, true);
                    builder.diagnosis(parseClaimDiagnosis("diagnosis", reader, diagnosisElementIndex++));
                    break;
                case "procedure":
                    position = checkElementOrder("procedure", 30, position, true);
                    builder.procedure(parseClaimProcedure("procedure", reader, procedureElementIndex++));
                    break;
                case "insurance":
                    position = checkElementOrder("insurance", 31, position, true);
                    builder.insurance(parseClaimInsurance("insurance", reader, insuranceElementIndex++));
                    break;
                case "accident":
                    position = checkElementOrder("accident", 32, position, false);
                    builder.accident(parseClaimAccident("accident", reader, -1));
                    break;
                case "item":
                    position = checkElementOrder("item", 33, position, true);
                    builder.item(parseClaimItem("item", reader, itemElementIndex++));
                    break;
                case "total":
                    position = checkElementOrder("total", 34, position, false);
                    builder.total(parseMoney("total", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Claim.Accident parseClaimAccident(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Claim.Accident.Builder builder = Claim.Accident.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "date":
                    position = checkElementOrder("date", 2, position, false);
                    builder.date(parseDate("date", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "locationAddress":
                    position = checkElementOrder("location[x]", 4, position, false);
                    builder.location(parseAddress("locationAddress", reader, -1));
                    break;
                case "locationReference":
                    position = checkElementOrder("location[x]", 4, position, false);
                    builder.location(parseReference("locationReference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Claim.CareTeam parseClaimCareTeam(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Claim.CareTeam.Builder builder = Claim.CareTeam.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "sequence":
                    position = checkElementOrder("sequence", 2, position, false);
                    builder.sequence((PositiveInt) parseInteger(PositiveInt.builder(), "sequence", reader, -1));
                    break;
                case "provider":
                    position = checkElementOrder("provider", 3, position, false);
                    builder.provider(parseReference("provider", reader, -1));
                    break;
                case "responsible":
                    position = checkElementOrder("responsible", 4, position, false);
                    builder.responsible(parseBoolean("responsible", reader, -1));
                    break;
                case "role":
                    position = checkElementOrder("role", 5, position, false);
                    builder.role(parseCodeableConcept("role", reader, -1));
                    break;
                case "qualification":
                    position = checkElementOrder("qualification", 6, position, false);
                    builder.qualification(parseCodeableConcept("qualification", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Claim.Diagnosis parseClaimDiagnosis(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Claim.Diagnosis.Builder builder = Claim.Diagnosis.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, typeElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "sequence":
                    position = checkElementOrder("sequence", 2, position, false);
                    builder.sequence((PositiveInt) parseInteger(PositiveInt.builder(), "sequence", reader, -1));
                    break;
                case "diagnosisCodeableConcept":
                    position = checkElementOrder("diagnosis[x]", 3, position, false);
                    builder.diagnosis(parseCodeableConcept("diagnosisCodeableConcept", reader, -1));
                    break;
                case "diagnosisReference":
                    position = checkElementOrder("diagnosis[x]", 3, position, false);
                    builder.diagnosis(parseReference("diagnosisReference", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 4, position, true);
                    builder.type(parseCodeableConcept("type", reader, typeElementIndex++));
                    break;
                case "onAdmission":
                    position = checkElementOrder("onAdmission", 5, position, false);
                    builder.onAdmission(parseCodeableConcept("onAdmission", reader, -1));
                    break;
                case "packageCode":
                    position = checkElementOrder("packageCode", 6, position, false);
                    builder.packageCode(parseCodeableConcept("packageCode", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Claim.Insurance parseClaimInsurance(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Claim.Insurance.Builder builder = Claim.Insurance.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, preAuthRefElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "sequence":
                    position = checkElementOrder("sequence", 2, position, false);
                    builder.sequence((PositiveInt) parseInteger(PositiveInt.builder(), "sequence", reader, -1));
                    break;
                case "focal":
                    position = checkElementOrder("focal", 3, position, false);
                    builder.focal(parseBoolean("focal", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 4, position, false);
                    builder.identifier(parseIdentifier("identifier", reader, -1));
                    break;
                case "coverage":
                    position = checkElementOrder("coverage", 5, position, false);
                    builder.coverage(parseReference("coverage", reader, -1));
                    break;
                case "businessArrangement":
                    position = checkElementOrder("businessArrangement", 6, position, false);
                    builder.businessArrangement(parseString("businessArrangement", reader, -1));
                    break;
                case "preAuthRef":
                    position = checkElementOrder("preAuthRef", 7, position, true);
                    builder.preAuthRef(parseString("preAuthRef", reader, preAuthRefElementIndex++));
                    break;
                case "claimResponse":
                    position = checkElementOrder("claimResponse", 8, position, false);
                    builder.claimResponse(parseReference("claimResponse", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Claim.Item parseClaimItem(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Claim.Item.Builder builder = Claim.Item.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, careTeamSequenceElementIndex = 0, diagnosisSequenceElementIndex = 0, procedureSequenceElementIndex = 0, informationSequenceElementIndex = 0, modifierElementIndex = 0, programCodeElementIndex = 0, udiElementIndex = 0, subSiteElementIndex = 0, encounterElementIndex = 0, detailElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "sequence":
                    position = checkElementOrder("sequence", 2, position, false);
                    builder.sequence((PositiveInt) parseInteger(PositiveInt.builder(), "sequence", reader, -1));
                    break;
                case "careTeamSequence":
                    position = checkElementOrder("careTeamSequence", 3, position, true);
                    builder.careTeamSequence((PositiveInt) parseInteger(PositiveInt.builder(), "careTeamSequence", reader, careTeamSequenceElementIndex++));
                    break;
                case "diagnosisSequence":
                    position = checkElementOrder("diagnosisSequence", 4, position, true);
                    builder.diagnosisSequence((PositiveInt) parseInteger(PositiveInt.builder(), "diagnosisSequence", reader, diagnosisSequenceElementIndex++));
                    break;
                case "procedureSequence":
                    position = checkElementOrder("procedureSequence", 5, position, true);
                    builder.procedureSequence((PositiveInt) parseInteger(PositiveInt.builder(), "procedureSequence", reader, procedureSequenceElementIndex++));
                    break;
                case "informationSequence":
                    position = checkElementOrder("informationSequence", 6, position, true);
                    builder.informationSequence((PositiveInt) parseInteger(PositiveInt.builder(), "informationSequence", reader, informationSequenceElementIndex++));
                    break;
                case "revenue":
                    position = checkElementOrder("revenue", 7, position, false);
                    builder.revenue(parseCodeableConcept("revenue", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 8, position, false);
                    builder.category(parseCodeableConcept("category", reader, -1));
                    break;
                case "productOrService":
                    position = checkElementOrder("productOrService", 9, position, false);
                    builder.productOrService(parseCodeableConcept("productOrService", reader, -1));
                    break;
                case "modifier":
                    position = checkElementOrder("modifier", 10, position, true);
                    builder.modifier(parseCodeableConcept("modifier", reader, modifierElementIndex++));
                    break;
                case "programCode":
                    position = checkElementOrder("programCode", 11, position, true);
                    builder.programCode(parseCodeableConcept("programCode", reader, programCodeElementIndex++));
                    break;
                case "servicedDate":
                    position = checkElementOrder("serviced[x]", 12, position, false);
                    builder.serviced(parseDate("servicedDate", reader, -1));
                    break;
                case "servicedPeriod":
                    position = checkElementOrder("serviced[x]", 12, position, false);
                    builder.serviced(parsePeriod("servicedPeriod", reader, -1));
                    break;
                case "locationCodeableConcept":
                    position = checkElementOrder("location[x]", 13, position, false);
                    builder.location(parseCodeableConcept("locationCodeableConcept", reader, -1));
                    break;
                case "locationAddress":
                    position = checkElementOrder("location[x]", 13, position, false);
                    builder.location(parseAddress("locationAddress", reader, -1));
                    break;
                case "locationReference":
                    position = checkElementOrder("location[x]", 13, position, false);
                    builder.location(parseReference("locationReference", reader, -1));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 14, position, false);
                    builder.quantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "quantity", reader, -1));
                    break;
                case "unitPrice":
                    position = checkElementOrder("unitPrice", 15, position, false);
                    builder.unitPrice(parseMoney("unitPrice", reader, -1));
                    break;
                case "factor":
                    position = checkElementOrder("factor", 16, position, false);
                    builder.factor(parseDecimal("factor", reader, -1));
                    break;
                case "net":
                    position = checkElementOrder("net", 17, position, false);
                    builder.net(parseMoney("net", reader, -1));
                    break;
                case "udi":
                    position = checkElementOrder("udi", 18, position, true);
                    builder.udi(parseReference("udi", reader, udiElementIndex++));
                    break;
                case "bodySite":
                    position = checkElementOrder("bodySite", 19, position, false);
                    builder.bodySite(parseCodeableConcept("bodySite", reader, -1));
                    break;
                case "subSite":
                    position = checkElementOrder("subSite", 20, position, true);
                    builder.subSite(parseCodeableConcept("subSite", reader, subSiteElementIndex++));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 21, position, true);
                    builder.encounter(parseReference("encounter", reader, encounterElementIndex++));
                    break;
                case "detail":
                    position = checkElementOrder("detail", 22, position, true);
                    builder.detail(parseClaimItemDetail("detail", reader, detailElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Claim.Item.Detail parseClaimItemDetail(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Claim.Item.Detail.Builder builder = Claim.Item.Detail.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, modifierElementIndex = 0, programCodeElementIndex = 0, udiElementIndex = 0, subDetailElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "sequence":
                    position = checkElementOrder("sequence", 2, position, false);
                    builder.sequence((PositiveInt) parseInteger(PositiveInt.builder(), "sequence", reader, -1));
                    break;
                case "revenue":
                    position = checkElementOrder("revenue", 3, position, false);
                    builder.revenue(parseCodeableConcept("revenue", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 4, position, false);
                    builder.category(parseCodeableConcept("category", reader, -1));
                    break;
                case "productOrService":
                    position = checkElementOrder("productOrService", 5, position, false);
                    builder.productOrService(parseCodeableConcept("productOrService", reader, -1));
                    break;
                case "modifier":
                    position = checkElementOrder("modifier", 6, position, true);
                    builder.modifier(parseCodeableConcept("modifier", reader, modifierElementIndex++));
                    break;
                case "programCode":
                    position = checkElementOrder("programCode", 7, position, true);
                    builder.programCode(parseCodeableConcept("programCode", reader, programCodeElementIndex++));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 8, position, false);
                    builder.quantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "quantity", reader, -1));
                    break;
                case "unitPrice":
                    position = checkElementOrder("unitPrice", 9, position, false);
                    builder.unitPrice(parseMoney("unitPrice", reader, -1));
                    break;
                case "factor":
                    position = checkElementOrder("factor", 10, position, false);
                    builder.factor(parseDecimal("factor", reader, -1));
                    break;
                case "net":
                    position = checkElementOrder("net", 11, position, false);
                    builder.net(parseMoney("net", reader, -1));
                    break;
                case "udi":
                    position = checkElementOrder("udi", 12, position, true);
                    builder.udi(parseReference("udi", reader, udiElementIndex++));
                    break;
                case "subDetail":
                    position = checkElementOrder("subDetail", 13, position, true);
                    builder.subDetail(parseClaimItemDetailSubDetail("subDetail", reader, subDetailElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Claim.Item.Detail.SubDetail parseClaimItemDetailSubDetail(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Claim.Item.Detail.SubDetail.Builder builder = Claim.Item.Detail.SubDetail.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, modifierElementIndex = 0, programCodeElementIndex = 0, udiElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "sequence":
                    position = checkElementOrder("sequence", 2, position, false);
                    builder.sequence((PositiveInt) parseInteger(PositiveInt.builder(), "sequence", reader, -1));
                    break;
                case "revenue":
                    position = checkElementOrder("revenue", 3, position, false);
                    builder.revenue(parseCodeableConcept("revenue", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 4, position, false);
                    builder.category(parseCodeableConcept("category", reader, -1));
                    break;
                case "productOrService":
                    position = checkElementOrder("productOrService", 5, position, false);
                    builder.productOrService(parseCodeableConcept("productOrService", reader, -1));
                    break;
                case "modifier":
                    position = checkElementOrder("modifier", 6, position, true);
                    builder.modifier(parseCodeableConcept("modifier", reader, modifierElementIndex++));
                    break;
                case "programCode":
                    position = checkElementOrder("programCode", 7, position, true);
                    builder.programCode(parseCodeableConcept("programCode", reader, programCodeElementIndex++));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 8, position, false);
                    builder.quantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "quantity", reader, -1));
                    break;
                case "unitPrice":
                    position = checkElementOrder("unitPrice", 9, position, false);
                    builder.unitPrice(parseMoney("unitPrice", reader, -1));
                    break;
                case "factor":
                    position = checkElementOrder("factor", 10, position, false);
                    builder.factor(parseDecimal("factor", reader, -1));
                    break;
                case "net":
                    position = checkElementOrder("net", 11, position, false);
                    builder.net(parseMoney("net", reader, -1));
                    break;
                case "udi":
                    position = checkElementOrder("udi", 12, position, true);
                    builder.udi(parseReference("udi", reader, udiElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Claim.Payee parseClaimPayee(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Claim.Payee.Builder builder = Claim.Payee.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "party":
                    position = checkElementOrder("party", 3, position, false);
                    builder.party(parseReference("party", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Claim.Procedure parseClaimProcedure(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Claim.Procedure.Builder builder = Claim.Procedure.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, typeElementIndex = 0, udiElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "sequence":
                    position = checkElementOrder("sequence", 2, position, false);
                    builder.sequence((PositiveInt) parseInteger(PositiveInt.builder(), "sequence", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, true);
                    builder.type(parseCodeableConcept("type", reader, typeElementIndex++));
                    break;
                case "date":
                    position = checkElementOrder("date", 4, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "procedureCodeableConcept":
                    position = checkElementOrder("procedure[x]", 5, position, false);
                    builder.procedure(parseCodeableConcept("procedureCodeableConcept", reader, -1));
                    break;
                case "procedureReference":
                    position = checkElementOrder("procedure[x]", 5, position, false);
                    builder.procedure(parseReference("procedureReference", reader, -1));
                    break;
                case "udi":
                    position = checkElementOrder("udi", 6, position, true);
                    builder.udi(parseReference("udi", reader, udiElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Claim.Related parseClaimRelated(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Claim.Related.Builder builder = Claim.Related.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "claim":
                    position = checkElementOrder("claim", 2, position, false);
                    builder.claim(parseReference("claim", reader, -1));
                    break;
                case "relationship":
                    position = checkElementOrder("relationship", 3, position, false);
                    builder.relationship(parseCodeableConcept("relationship", reader, -1));
                    break;
                case "reference":
                    position = checkElementOrder("reference", 4, position, false);
                    builder.reference(parseIdentifier("reference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Claim.SupportingInfo parseClaimSupportingInfo(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Claim.SupportingInfo.Builder builder = Claim.SupportingInfo.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "sequence":
                    position = checkElementOrder("sequence", 2, position, false);
                    builder.sequence((PositiveInt) parseInteger(PositiveInt.builder(), "sequence", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 3, position, false);
                    builder.category(parseCodeableConcept("category", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 4, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "timingDate":
                    position = checkElementOrder("timing[x]", 5, position, false);
                    builder.timing(parseDate("timingDate", reader, -1));
                    break;
                case "timingPeriod":
                    position = checkElementOrder("timing[x]", 5, position, false);
                    builder.timing(parsePeriod("timingPeriod", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 6, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueString":
                    position = checkElementOrder("value[x]", 6, position, false);
                    builder.value(parseString("valueString", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 6, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueAttachment":
                    position = checkElementOrder("value[x]", 6, position, false);
                    builder.value(parseAttachment("valueAttachment", reader, -1));
                    break;
                case "valueReference":
                    position = checkElementOrder("value[x]", 6, position, false);
                    builder.value(parseReference("valueReference", reader, -1));
                    break;
                case "reason":
                    position = checkElementOrder("reason", 7, position, false);
                    builder.reason(parseCodeableConcept("reason", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ClaimResponse parseClaimResponse(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ClaimResponse.Builder builder = ClaimResponse.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, itemElementIndex = 0, addItemElementIndex = 0, adjudicationElementIndex = 0, totalElementIndex = 0, processNoteElementIndex = 0, communicationRequestElementIndex = 0, insuranceElementIndex = 0, errorElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((ClaimResponseStatus) parseString(ClaimResponseStatus.builder(), "status", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 10, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "subType":
                    position = checkElementOrder("subType", 11, position, false);
                    builder.subType(parseCodeableConcept("subType", reader, -1));
                    break;
                case "use":
                    position = checkElementOrder("use", 12, position, false);
                    builder.use((Use) parseString(Use.builder(), "use", reader, -1));
                    break;
                case "patient":
                    position = checkElementOrder("patient", 13, position, false);
                    builder.patient(parseReference("patient", reader, -1));
                    break;
                case "created":
                    position = checkElementOrder("created", 14, position, false);
                    builder.created(parseDateTime("created", reader, -1));
                    break;
                case "insurer":
                    position = checkElementOrder("insurer", 15, position, false);
                    builder.insurer(parseReference("insurer", reader, -1));
                    break;
                case "requestor":
                    position = checkElementOrder("requestor", 16, position, false);
                    builder.requestor(parseReference("requestor", reader, -1));
                    break;
                case "request":
                    position = checkElementOrder("request", 17, position, false);
                    builder.request(parseReference("request", reader, -1));
                    break;
                case "outcome":
                    position = checkElementOrder("outcome", 18, position, false);
                    builder.outcome((RemittanceOutcome) parseString(RemittanceOutcome.builder(), "outcome", reader, -1));
                    break;
                case "disposition":
                    position = checkElementOrder("disposition", 19, position, false);
                    builder.disposition(parseString("disposition", reader, -1));
                    break;
                case "preAuthRef":
                    position = checkElementOrder("preAuthRef", 20, position, false);
                    builder.preAuthRef(parseString("preAuthRef", reader, -1));
                    break;
                case "preAuthPeriod":
                    position = checkElementOrder("preAuthPeriod", 21, position, false);
                    builder.preAuthPeriod(parsePeriod("preAuthPeriod", reader, -1));
                    break;
                case "payeeType":
                    position = checkElementOrder("payeeType", 22, position, false);
                    builder.payeeType(parseCodeableConcept("payeeType", reader, -1));
                    break;
                case "item":
                    position = checkElementOrder("item", 23, position, true);
                    builder.item(parseClaimResponseItem("item", reader, itemElementIndex++));
                    break;
                case "addItem":
                    position = checkElementOrder("addItem", 24, position, true);
                    builder.addItem(parseClaimResponseAddItem("addItem", reader, addItemElementIndex++));
                    break;
                case "adjudication":
                    position = checkElementOrder("adjudication", 25, position, true);
                    builder.adjudication(parseClaimResponseItemAdjudication("adjudication", reader, adjudicationElementIndex++));
                    break;
                case "total":
                    position = checkElementOrder("total", 26, position, true);
                    builder.total(parseClaimResponseTotal("total", reader, totalElementIndex++));
                    break;
                case "payment":
                    position = checkElementOrder("payment", 27, position, false);
                    builder.payment(parseClaimResponsePayment("payment", reader, -1));
                    break;
                case "fundsReserve":
                    position = checkElementOrder("fundsReserve", 28, position, false);
                    builder.fundsReserve(parseCodeableConcept("fundsReserve", reader, -1));
                    break;
                case "formCode":
                    position = checkElementOrder("formCode", 29, position, false);
                    builder.formCode(parseCodeableConcept("formCode", reader, -1));
                    break;
                case "form":
                    position = checkElementOrder("form", 30, position, false);
                    builder.form(parseAttachment("form", reader, -1));
                    break;
                case "processNote":
                    position = checkElementOrder("processNote", 31, position, true);
                    builder.processNote(parseClaimResponseProcessNote("processNote", reader, processNoteElementIndex++));
                    break;
                case "communicationRequest":
                    position = checkElementOrder("communicationRequest", 32, position, true);
                    builder.communicationRequest(parseReference("communicationRequest", reader, communicationRequestElementIndex++));
                    break;
                case "insurance":
                    position = checkElementOrder("insurance", 33, position, true);
                    builder.insurance(parseClaimResponseInsurance("insurance", reader, insuranceElementIndex++));
                    break;
                case "error":
                    position = checkElementOrder("error", 34, position, true);
                    builder.error(parseClaimResponseError("error", reader, errorElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ClaimResponse.AddItem parseClaimResponseAddItem(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ClaimResponse.AddItem.Builder builder = ClaimResponse.AddItem.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, itemSequenceElementIndex = 0, detailSequenceElementIndex = 0, subdetailSequenceElementIndex = 0, providerElementIndex = 0, modifierElementIndex = 0, programCodeElementIndex = 0, subSiteElementIndex = 0, noteNumberElementIndex = 0, adjudicationElementIndex = 0, detailElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "itemSequence":
                    position = checkElementOrder("itemSequence", 2, position, true);
                    builder.itemSequence((PositiveInt) parseInteger(PositiveInt.builder(), "itemSequence", reader, itemSequenceElementIndex++));
                    break;
                case "detailSequence":
                    position = checkElementOrder("detailSequence", 3, position, true);
                    builder.detailSequence((PositiveInt) parseInteger(PositiveInt.builder(), "detailSequence", reader, detailSequenceElementIndex++));
                    break;
                case "subdetailSequence":
                    position = checkElementOrder("subdetailSequence", 4, position, true);
                    builder.subdetailSequence((PositiveInt) parseInteger(PositiveInt.builder(), "subdetailSequence", reader, subdetailSequenceElementIndex++));
                    break;
                case "provider":
                    position = checkElementOrder("provider", 5, position, true);
                    builder.provider(parseReference("provider", reader, providerElementIndex++));
                    break;
                case "productOrService":
                    position = checkElementOrder("productOrService", 6, position, false);
                    builder.productOrService(parseCodeableConcept("productOrService", reader, -1));
                    break;
                case "modifier":
                    position = checkElementOrder("modifier", 7, position, true);
                    builder.modifier(parseCodeableConcept("modifier", reader, modifierElementIndex++));
                    break;
                case "programCode":
                    position = checkElementOrder("programCode", 8, position, true);
                    builder.programCode(parseCodeableConcept("programCode", reader, programCodeElementIndex++));
                    break;
                case "servicedDate":
                    position = checkElementOrder("serviced[x]", 9, position, false);
                    builder.serviced(parseDate("servicedDate", reader, -1));
                    break;
                case "servicedPeriod":
                    position = checkElementOrder("serviced[x]", 9, position, false);
                    builder.serviced(parsePeriod("servicedPeriod", reader, -1));
                    break;
                case "locationCodeableConcept":
                    position = checkElementOrder("location[x]", 10, position, false);
                    builder.location(parseCodeableConcept("locationCodeableConcept", reader, -1));
                    break;
                case "locationAddress":
                    position = checkElementOrder("location[x]", 10, position, false);
                    builder.location(parseAddress("locationAddress", reader, -1));
                    break;
                case "locationReference":
                    position = checkElementOrder("location[x]", 10, position, false);
                    builder.location(parseReference("locationReference", reader, -1));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 11, position, false);
                    builder.quantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "quantity", reader, -1));
                    break;
                case "unitPrice":
                    position = checkElementOrder("unitPrice", 12, position, false);
                    builder.unitPrice(parseMoney("unitPrice", reader, -1));
                    break;
                case "factor":
                    position = checkElementOrder("factor", 13, position, false);
                    builder.factor(parseDecimal("factor", reader, -1));
                    break;
                case "net":
                    position = checkElementOrder("net", 14, position, false);
                    builder.net(parseMoney("net", reader, -1));
                    break;
                case "bodySite":
                    position = checkElementOrder("bodySite", 15, position, false);
                    builder.bodySite(parseCodeableConcept("bodySite", reader, -1));
                    break;
                case "subSite":
                    position = checkElementOrder("subSite", 16, position, true);
                    builder.subSite(parseCodeableConcept("subSite", reader, subSiteElementIndex++));
                    break;
                case "noteNumber":
                    position = checkElementOrder("noteNumber", 17, position, true);
                    builder.noteNumber((PositiveInt) parseInteger(PositiveInt.builder(), "noteNumber", reader, noteNumberElementIndex++));
                    break;
                case "adjudication":
                    position = checkElementOrder("adjudication", 18, position, true);
                    builder.adjudication(parseClaimResponseItemAdjudication("adjudication", reader, adjudicationElementIndex++));
                    break;
                case "detail":
                    position = checkElementOrder("detail", 19, position, true);
                    builder.detail(parseClaimResponseAddItemDetail("detail", reader, detailElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ClaimResponse.AddItem.Detail parseClaimResponseAddItemDetail(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ClaimResponse.AddItem.Detail.Builder builder = ClaimResponse.AddItem.Detail.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, modifierElementIndex = 0, noteNumberElementIndex = 0, adjudicationElementIndex = 0, subDetailElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "productOrService":
                    position = checkElementOrder("productOrService", 2, position, false);
                    builder.productOrService(parseCodeableConcept("productOrService", reader, -1));
                    break;
                case "modifier":
                    position = checkElementOrder("modifier", 3, position, true);
                    builder.modifier(parseCodeableConcept("modifier", reader, modifierElementIndex++));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 4, position, false);
                    builder.quantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "quantity", reader, -1));
                    break;
                case "unitPrice":
                    position = checkElementOrder("unitPrice", 5, position, false);
                    builder.unitPrice(parseMoney("unitPrice", reader, -1));
                    break;
                case "factor":
                    position = checkElementOrder("factor", 6, position, false);
                    builder.factor(parseDecimal("factor", reader, -1));
                    break;
                case "net":
                    position = checkElementOrder("net", 7, position, false);
                    builder.net(parseMoney("net", reader, -1));
                    break;
                case "noteNumber":
                    position = checkElementOrder("noteNumber", 8, position, true);
                    builder.noteNumber((PositiveInt) parseInteger(PositiveInt.builder(), "noteNumber", reader, noteNumberElementIndex++));
                    break;
                case "adjudication":
                    position = checkElementOrder("adjudication", 9, position, true);
                    builder.adjudication(parseClaimResponseItemAdjudication("adjudication", reader, adjudicationElementIndex++));
                    break;
                case "subDetail":
                    position = checkElementOrder("subDetail", 10, position, true);
                    builder.subDetail(parseClaimResponseAddItemDetailSubDetail("subDetail", reader, subDetailElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ClaimResponse.AddItem.Detail.SubDetail parseClaimResponseAddItemDetailSubDetail(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ClaimResponse.AddItem.Detail.SubDetail.Builder builder = ClaimResponse.AddItem.Detail.SubDetail.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, modifierElementIndex = 0, noteNumberElementIndex = 0, adjudicationElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "productOrService":
                    position = checkElementOrder("productOrService", 2, position, false);
                    builder.productOrService(parseCodeableConcept("productOrService", reader, -1));
                    break;
                case "modifier":
                    position = checkElementOrder("modifier", 3, position, true);
                    builder.modifier(parseCodeableConcept("modifier", reader, modifierElementIndex++));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 4, position, false);
                    builder.quantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "quantity", reader, -1));
                    break;
                case "unitPrice":
                    position = checkElementOrder("unitPrice", 5, position, false);
                    builder.unitPrice(parseMoney("unitPrice", reader, -1));
                    break;
                case "factor":
                    position = checkElementOrder("factor", 6, position, false);
                    builder.factor(parseDecimal("factor", reader, -1));
                    break;
                case "net":
                    position = checkElementOrder("net", 7, position, false);
                    builder.net(parseMoney("net", reader, -1));
                    break;
                case "noteNumber":
                    position = checkElementOrder("noteNumber", 8, position, true);
                    builder.noteNumber((PositiveInt) parseInteger(PositiveInt.builder(), "noteNumber", reader, noteNumberElementIndex++));
                    break;
                case "adjudication":
                    position = checkElementOrder("adjudication", 9, position, true);
                    builder.adjudication(parseClaimResponseItemAdjudication("adjudication", reader, adjudicationElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ClaimResponse.Error parseClaimResponseError(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ClaimResponse.Error.Builder builder = ClaimResponse.Error.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "itemSequence":
                    position = checkElementOrder("itemSequence", 2, position, false);
                    builder.itemSequence((PositiveInt) parseInteger(PositiveInt.builder(), "itemSequence", reader, -1));
                    break;
                case "detailSequence":
                    position = checkElementOrder("detailSequence", 3, position, false);
                    builder.detailSequence((PositiveInt) parseInteger(PositiveInt.builder(), "detailSequence", reader, -1));
                    break;
                case "subDetailSequence":
                    position = checkElementOrder("subDetailSequence", 4, position, false);
                    builder.subDetailSequence((PositiveInt) parseInteger(PositiveInt.builder(), "subDetailSequence", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 5, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ClaimResponse.Insurance parseClaimResponseInsurance(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ClaimResponse.Insurance.Builder builder = ClaimResponse.Insurance.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "sequence":
                    position = checkElementOrder("sequence", 2, position, false);
                    builder.sequence((PositiveInt) parseInteger(PositiveInt.builder(), "sequence", reader, -1));
                    break;
                case "focal":
                    position = checkElementOrder("focal", 3, position, false);
                    builder.focal(parseBoolean("focal", reader, -1));
                    break;
                case "coverage":
                    position = checkElementOrder("coverage", 4, position, false);
                    builder.coverage(parseReference("coverage", reader, -1));
                    break;
                case "businessArrangement":
                    position = checkElementOrder("businessArrangement", 5, position, false);
                    builder.businessArrangement(parseString("businessArrangement", reader, -1));
                    break;
                case "claimResponse":
                    position = checkElementOrder("claimResponse", 6, position, false);
                    builder.claimResponse(parseReference("claimResponse", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ClaimResponse.Item parseClaimResponseItem(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ClaimResponse.Item.Builder builder = ClaimResponse.Item.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, noteNumberElementIndex = 0, adjudicationElementIndex = 0, detailElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "itemSequence":
                    position = checkElementOrder("itemSequence", 2, position, false);
                    builder.itemSequence((PositiveInt) parseInteger(PositiveInt.builder(), "itemSequence", reader, -1));
                    break;
                case "noteNumber":
                    position = checkElementOrder("noteNumber", 3, position, true);
                    builder.noteNumber((PositiveInt) parseInteger(PositiveInt.builder(), "noteNumber", reader, noteNumberElementIndex++));
                    break;
                case "adjudication":
                    position = checkElementOrder("adjudication", 4, position, true);
                    builder.adjudication(parseClaimResponseItemAdjudication("adjudication", reader, adjudicationElementIndex++));
                    break;
                case "detail":
                    position = checkElementOrder("detail", 5, position, true);
                    builder.detail(parseClaimResponseItemDetail("detail", reader, detailElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ClaimResponse.Item.Adjudication parseClaimResponseItemAdjudication(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ClaimResponse.Item.Adjudication.Builder builder = ClaimResponse.Item.Adjudication.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "category":
                    position = checkElementOrder("category", 2, position, false);
                    builder.category(parseCodeableConcept("category", reader, -1));
                    break;
                case "reason":
                    position = checkElementOrder("reason", 3, position, false);
                    builder.reason(parseCodeableConcept("reason", reader, -1));
                    break;
                case "amount":
                    position = checkElementOrder("amount", 4, position, false);
                    builder.amount(parseMoney("amount", reader, -1));
                    break;
                case "value":
                    position = checkElementOrder("value", 5, position, false);
                    builder.value(parseDecimal("value", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ClaimResponse.Item.Detail parseClaimResponseItemDetail(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ClaimResponse.Item.Detail.Builder builder = ClaimResponse.Item.Detail.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, noteNumberElementIndex = 0, adjudicationElementIndex = 0, subDetailElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "detailSequence":
                    position = checkElementOrder("detailSequence", 2, position, false);
                    builder.detailSequence((PositiveInt) parseInteger(PositiveInt.builder(), "detailSequence", reader, -1));
                    break;
                case "noteNumber":
                    position = checkElementOrder("noteNumber", 3, position, true);
                    builder.noteNumber((PositiveInt) parseInteger(PositiveInt.builder(), "noteNumber", reader, noteNumberElementIndex++));
                    break;
                case "adjudication":
                    position = checkElementOrder("adjudication", 4, position, true);
                    builder.adjudication(parseClaimResponseItemAdjudication("adjudication", reader, adjudicationElementIndex++));
                    break;
                case "subDetail":
                    position = checkElementOrder("subDetail", 5, position, true);
                    builder.subDetail(parseClaimResponseItemDetailSubDetail("subDetail", reader, subDetailElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ClaimResponse.Item.Detail.SubDetail parseClaimResponseItemDetailSubDetail(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ClaimResponse.Item.Detail.SubDetail.Builder builder = ClaimResponse.Item.Detail.SubDetail.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, noteNumberElementIndex = 0, adjudicationElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "subDetailSequence":
                    position = checkElementOrder("subDetailSequence", 2, position, false);
                    builder.subDetailSequence((PositiveInt) parseInteger(PositiveInt.builder(), "subDetailSequence", reader, -1));
                    break;
                case "noteNumber":
                    position = checkElementOrder("noteNumber", 3, position, true);
                    builder.noteNumber((PositiveInt) parseInteger(PositiveInt.builder(), "noteNumber", reader, noteNumberElementIndex++));
                    break;
                case "adjudication":
                    position = checkElementOrder("adjudication", 4, position, true);
                    builder.adjudication(parseClaimResponseItemAdjudication("adjudication", reader, adjudicationElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ClaimResponse.Payment parseClaimResponsePayment(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ClaimResponse.Payment.Builder builder = ClaimResponse.Payment.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "adjustment":
                    position = checkElementOrder("adjustment", 3, position, false);
                    builder.adjustment(parseMoney("adjustment", reader, -1));
                    break;
                case "adjustmentReason":
                    position = checkElementOrder("adjustmentReason", 4, position, false);
                    builder.adjustmentReason(parseCodeableConcept("adjustmentReason", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 5, position, false);
                    builder.date(parseDate("date", reader, -1));
                    break;
                case "amount":
                    position = checkElementOrder("amount", 6, position, false);
                    builder.amount(parseMoney("amount", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 7, position, false);
                    builder.identifier(parseIdentifier("identifier", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ClaimResponse.ProcessNote parseClaimResponseProcessNote(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ClaimResponse.ProcessNote.Builder builder = ClaimResponse.ProcessNote.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "number":
                    position = checkElementOrder("number", 2, position, false);
                    builder.number((PositiveInt) parseInteger(PositiveInt.builder(), "number", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type((NoteType) parseString(NoteType.builder(), "type", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseString("text", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 5, position, false);
                    builder.language(parseCodeableConcept("language", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ClaimResponse.Total parseClaimResponseTotal(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ClaimResponse.Total.Builder builder = ClaimResponse.Total.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "category":
                    position = checkElementOrder("category", 2, position, false);
                    builder.category(parseCodeableConcept("category", reader, -1));
                    break;
                case "amount":
                    position = checkElementOrder("amount", 3, position, false);
                    builder.amount(parseMoney("amount", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ClinicalImpression parseClinicalImpression(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ClinicalImpression.Builder builder = ClinicalImpression.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, problemElementIndex = 0, investigationElementIndex = 0, protocolElementIndex = 0, findingElementIndex = 0, prognosisCodeableConceptElementIndex = 0, prognosisReferenceElementIndex = 0, supportingInfoElementIndex = 0, noteElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((ClinicalImpressionStatus) parseString(ClinicalImpressionStatus.builder(), "status", reader, -1));
                    break;
                case "statusReason":
                    position = checkElementOrder("statusReason", 10, position, false);
                    builder.statusReason(parseCodeableConcept("statusReason", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 11, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 12, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 13, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 14, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "effectiveDateTime":
                    position = checkElementOrder("effective[x]", 15, position, false);
                    builder.effective(parseDateTime("effectiveDateTime", reader, -1));
                    break;
                case "effectivePeriod":
                    position = checkElementOrder("effective[x]", 15, position, false);
                    builder.effective(parsePeriod("effectivePeriod", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 16, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "assessor":
                    position = checkElementOrder("assessor", 17, position, false);
                    builder.assessor(parseReference("assessor", reader, -1));
                    break;
                case "previous":
                    position = checkElementOrder("previous", 18, position, false);
                    builder.previous(parseReference("previous", reader, -1));
                    break;
                case "problem":
                    position = checkElementOrder("problem", 19, position, true);
                    builder.problem(parseReference("problem", reader, problemElementIndex++));
                    break;
                case "investigation":
                    position = checkElementOrder("investigation", 20, position, true);
                    builder.investigation(parseClinicalImpressionInvestigation("investigation", reader, investigationElementIndex++));
                    break;
                case "protocol":
                    position = checkElementOrder("protocol", 21, position, true);
                    builder.protocol(parseUri("protocol", reader, protocolElementIndex++));
                    break;
                case "summary":
                    position = checkElementOrder("summary", 22, position, false);
                    builder.summary(parseString("summary", reader, -1));
                    break;
                case "finding":
                    position = checkElementOrder("finding", 23, position, true);
                    builder.finding(parseClinicalImpressionFinding("finding", reader, findingElementIndex++));
                    break;
                case "prognosisCodeableConcept":
                    position = checkElementOrder("prognosisCodeableConcept", 24, position, true);
                    builder.prognosisCodeableConcept(parseCodeableConcept("prognosisCodeableConcept", reader, prognosisCodeableConceptElementIndex++));
                    break;
                case "prognosisReference":
                    position = checkElementOrder("prognosisReference", 25, position, true);
                    builder.prognosisReference(parseReference("prognosisReference", reader, prognosisReferenceElementIndex++));
                    break;
                case "supportingInfo":
                    position = checkElementOrder("supportingInfo", 26, position, true);
                    builder.supportingInfo(parseReference("supportingInfo", reader, supportingInfoElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 27, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ClinicalImpression.Finding parseClinicalImpressionFinding(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ClinicalImpression.Finding.Builder builder = ClinicalImpression.Finding.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "itemCodeableConcept":
                    position = checkElementOrder("itemCodeableConcept", 2, position, false);
                    builder.itemCodeableConcept(parseCodeableConcept("itemCodeableConcept", reader, -1));
                    break;
                case "itemReference":
                    position = checkElementOrder("itemReference", 3, position, false);
                    builder.itemReference(parseReference("itemReference", reader, -1));
                    break;
                case "basis":
                    position = checkElementOrder("basis", 4, position, false);
                    builder.basis(parseString("basis", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ClinicalImpression.Investigation parseClinicalImpressionInvestigation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ClinicalImpression.Investigation.Builder builder = ClinicalImpression.Investigation.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, itemElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "item":
                    position = checkElementOrder("item", 3, position, true);
                    builder.item(parseReference("item", reader, itemElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ClinicalUseDefinition parseClinicalUseDefinition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ClinicalUseDefinition.Builder builder = ClinicalUseDefinition.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, categoryElementIndex = 0, subjectElementIndex = 0, populationElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 9, position, false);
                    builder.type((ClinicalUseDefinitionType) parseString(ClinicalUseDefinitionType.builder(), "type", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 10, position, true);
                    builder.category(parseCodeableConcept("category", reader, categoryElementIndex++));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 11, position, true);
                    builder.subject(parseReference("subject", reader, subjectElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 12, position, false);
                    builder.status(parseCodeableConcept("status", reader, -1));
                    break;
                case "contraindication":
                    position = checkElementOrder("contraindication", 13, position, false);
                    builder.contraindication(parseClinicalUseDefinitionContraindication("contraindication", reader, -1));
                    break;
                case "indication":
                    position = checkElementOrder("indication", 14, position, false);
                    builder.indication(parseClinicalUseDefinitionIndication("indication", reader, -1));
                    break;
                case "interaction":
                    position = checkElementOrder("interaction", 15, position, false);
                    builder.interaction(parseClinicalUseDefinitionInteraction("interaction", reader, -1));
                    break;
                case "population":
                    position = checkElementOrder("population", 16, position, true);
                    builder.population(parseReference("population", reader, populationElementIndex++));
                    break;
                case "undesirableEffect":
                    position = checkElementOrder("undesirableEffect", 17, position, false);
                    builder.undesirableEffect(parseClinicalUseDefinitionUndesirableEffect("undesirableEffect", reader, -1));
                    break;
                case "warning":
                    position = checkElementOrder("warning", 18, position, false);
                    builder.warning(parseClinicalUseDefinitionWarning("warning", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ClinicalUseDefinition.Contraindication parseClinicalUseDefinitionContraindication(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ClinicalUseDefinition.Contraindication.Builder builder = ClinicalUseDefinition.Contraindication.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, comorbidityElementIndex = 0, indicationElementIndex = 0, otherTherapyElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "diseaseSymptomProcedure":
                    position = checkElementOrder("diseaseSymptomProcedure", 2, position, false);
                    builder.diseaseSymptomProcedure(parseCodeableReference("diseaseSymptomProcedure", reader, -1));
                    break;
                case "diseaseStatus":
                    position = checkElementOrder("diseaseStatus", 3, position, false);
                    builder.diseaseStatus(parseCodeableReference("diseaseStatus", reader, -1));
                    break;
                case "comorbidity":
                    position = checkElementOrder("comorbidity", 4, position, true);
                    builder.comorbidity(parseCodeableReference("comorbidity", reader, comorbidityElementIndex++));
                    break;
                case "indication":
                    position = checkElementOrder("indication", 5, position, true);
                    builder.indication(parseReference("indication", reader, indicationElementIndex++));
                    break;
                case "otherTherapy":
                    position = checkElementOrder("otherTherapy", 6, position, true);
                    builder.otherTherapy(parseClinicalUseDefinitionContraindicationOtherTherapy("otherTherapy", reader, otherTherapyElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ClinicalUseDefinition.Contraindication.OtherTherapy parseClinicalUseDefinitionContraindicationOtherTherapy(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ClinicalUseDefinition.Contraindication.OtherTherapy.Builder builder = ClinicalUseDefinition.Contraindication.OtherTherapy.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "relationshipType":
                    position = checkElementOrder("relationshipType", 2, position, false);
                    builder.relationshipType(parseCodeableConcept("relationshipType", reader, -1));
                    break;
                case "therapy":
                    position = checkElementOrder("therapy", 3, position, false);
                    builder.therapy(parseCodeableReference("therapy", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ClinicalUseDefinition.Indication parseClinicalUseDefinitionIndication(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ClinicalUseDefinition.Indication.Builder builder = ClinicalUseDefinition.Indication.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, comorbidityElementIndex = 0, undesirableEffectElementIndex = 0, otherTherapyElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "diseaseSymptomProcedure":
                    position = checkElementOrder("diseaseSymptomProcedure", 2, position, false);
                    builder.diseaseSymptomProcedure(parseCodeableReference("diseaseSymptomProcedure", reader, -1));
                    break;
                case "diseaseStatus":
                    position = checkElementOrder("diseaseStatus", 3, position, false);
                    builder.diseaseStatus(parseCodeableReference("diseaseStatus", reader, -1));
                    break;
                case "comorbidity":
                    position = checkElementOrder("comorbidity", 4, position, true);
                    builder.comorbidity(parseCodeableReference("comorbidity", reader, comorbidityElementIndex++));
                    break;
                case "intendedEffect":
                    position = checkElementOrder("intendedEffect", 5, position, false);
                    builder.intendedEffect(parseCodeableReference("intendedEffect", reader, -1));
                    break;
                case "duration":
                    position = checkElementOrder("duration", 6, position, false);
                    builder.duration(parseQuantity("duration", reader, -1));
                    break;
                case "undesirableEffect":
                    position = checkElementOrder("undesirableEffect", 7, position, true);
                    builder.undesirableEffect(parseReference("undesirableEffect", reader, undesirableEffectElementIndex++));
                    break;
                case "otherTherapy":
                    position = checkElementOrder("otherTherapy", 8, position, true);
                    builder.otherTherapy(parseClinicalUseDefinitionContraindicationOtherTherapy("otherTherapy", reader, otherTherapyElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ClinicalUseDefinition.Interaction parseClinicalUseDefinitionInteraction(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ClinicalUseDefinition.Interaction.Builder builder = ClinicalUseDefinition.Interaction.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, interactantElementIndex = 0, managementElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "interactant":
                    position = checkElementOrder("interactant", 2, position, true);
                    builder.interactant(parseClinicalUseDefinitionInteractionInteractant("interactant", reader, interactantElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "effect":
                    position = checkElementOrder("effect", 4, position, false);
                    builder.effect(parseCodeableReference("effect", reader, -1));
                    break;
                case "incidence":
                    position = checkElementOrder("incidence", 5, position, false);
                    builder.incidence(parseCodeableConcept("incidence", reader, -1));
                    break;
                case "management":
                    position = checkElementOrder("management", 6, position, true);
                    builder.management(parseCodeableConcept("management", reader, managementElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ClinicalUseDefinition.Interaction.Interactant parseClinicalUseDefinitionInteractionInteractant(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ClinicalUseDefinition.Interaction.Interactant.Builder builder = ClinicalUseDefinition.Interaction.Interactant.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "itemReference":
                    position = checkElementOrder("item[x]", 2, position, false);
                    builder.item(parseReference("itemReference", reader, -1));
                    break;
                case "itemCodeableConcept":
                    position = checkElementOrder("item[x]", 2, position, false);
                    builder.item(parseCodeableConcept("itemCodeableConcept", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ClinicalUseDefinition.UndesirableEffect parseClinicalUseDefinitionUndesirableEffect(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ClinicalUseDefinition.UndesirableEffect.Builder builder = ClinicalUseDefinition.UndesirableEffect.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "symptomConditionEffect":
                    position = checkElementOrder("symptomConditionEffect", 2, position, false);
                    builder.symptomConditionEffect(parseCodeableReference("symptomConditionEffect", reader, -1));
                    break;
                case "classification":
                    position = checkElementOrder("classification", 3, position, false);
                    builder.classification(parseCodeableConcept("classification", reader, -1));
                    break;
                case "frequencyOfOccurrence":
                    position = checkElementOrder("frequencyOfOccurrence", 4, position, false);
                    builder.frequencyOfOccurrence(parseCodeableConcept("frequencyOfOccurrence", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ClinicalUseDefinition.Warning parseClinicalUseDefinitionWarning(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ClinicalUseDefinition.Warning.Builder builder = ClinicalUseDefinition.Warning.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 2, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 3, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CodeSystem parseCodeSystem(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CodeSystem.Builder builder = CodeSystem.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, contactElementIndex = 0, useContextElementIndex = 0, jurisdictionElementIndex = 0, filterElementIndex = 0, propertyElementIndex = 0, conceptElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 10, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 11, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 12, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 13, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 14, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 15, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 16, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 17, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 18, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 19, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 20, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 21, position, false);
                    builder.purpose((Markdown) parseString(Markdown.builder(), "purpose", reader, -1));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 22, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                case "caseSensitive":
                    position = checkElementOrder("caseSensitive", 23, position, false);
                    builder.caseSensitive(parseBoolean("caseSensitive", reader, -1));
                    break;
                case "valueSet":
                    position = checkElementOrder("valueSet", 24, position, false);
                    builder.valueSet((Canonical) parseUri(Canonical.builder(), "valueSet", reader, -1));
                    break;
                case "hierarchyMeaning":
                    position = checkElementOrder("hierarchyMeaning", 25, position, false);
                    builder.hierarchyMeaning((CodeSystemHierarchyMeaning) parseString(CodeSystemHierarchyMeaning.builder(), "hierarchyMeaning", reader, -1));
                    break;
                case "compositional":
                    position = checkElementOrder("compositional", 26, position, false);
                    builder.compositional(parseBoolean("compositional", reader, -1));
                    break;
                case "versionNeeded":
                    position = checkElementOrder("versionNeeded", 27, position, false);
                    builder.versionNeeded(parseBoolean("versionNeeded", reader, -1));
                    break;
                case "content":
                    position = checkElementOrder("content", 28, position, false);
                    builder.content((CodeSystemContentMode) parseString(CodeSystemContentMode.builder(), "content", reader, -1));
                    break;
                case "supplements":
                    position = checkElementOrder("supplements", 29, position, false);
                    builder.supplements((Canonical) parseUri(Canonical.builder(), "supplements", reader, -1));
                    break;
                case "count":
                    position = checkElementOrder("count", 30, position, false);
                    builder.count((UnsignedInt) parseInteger(UnsignedInt.builder(), "count", reader, -1));
                    break;
                case "filter":
                    position = checkElementOrder("filter", 31, position, true);
                    builder.filter(parseCodeSystemFilter("filter", reader, filterElementIndex++));
                    break;
                case "property":
                    position = checkElementOrder("property", 32, position, true);
                    builder.property(parseCodeSystemProperty("property", reader, propertyElementIndex++));
                    break;
                case "concept":
                    position = checkElementOrder("concept", 33, position, true);
                    builder.concept(parseCodeSystemConcept("concept", reader, conceptElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CodeSystem.Concept parseCodeSystemConcept(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CodeSystem.Concept.Builder builder = CodeSystem.Concept.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, designationElementIndex = 0, propertyElementIndex = 0, conceptElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code((Code) parseString(Code.builder(), "code", reader, -1));
                    break;
                case "display":
                    position = checkElementOrder("display", 3, position, false);
                    builder.display(parseString("display", reader, -1));
                    break;
                case "definition":
                    position = checkElementOrder("definition", 4, position, false);
                    builder.definition(parseString("definition", reader, -1));
                    break;
                case "designation":
                    position = checkElementOrder("designation", 5, position, true);
                    builder.designation(parseCodeSystemConceptDesignation("designation", reader, designationElementIndex++));
                    break;
                case "property":
                    position = checkElementOrder("property", 6, position, true);
                    builder.property(parseCodeSystemConceptProperty("property", reader, propertyElementIndex++));
                    break;
                case "concept":
                    position = checkElementOrder("concept", 7, position, true);
                    builder.concept(parseCodeSystemConcept("concept", reader, conceptElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CodeSystem.Concept.Designation parseCodeSystemConceptDesignation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CodeSystem.Concept.Designation.Builder builder = CodeSystem.Concept.Designation.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "language":
                    position = checkElementOrder("language", 2, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "use":
                    position = checkElementOrder("use", 3, position, false);
                    builder.use(parseCoding("use", reader, -1));
                    break;
                case "value":
                    position = checkElementOrder("value", 4, position, false);
                    builder.value(parseString("value", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CodeSystem.Concept.Property parseCodeSystemConceptProperty(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CodeSystem.Concept.Property.Builder builder = CodeSystem.Concept.Property.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code((Code) parseString(Code.builder(), "code", reader, -1));
                    break;
                case "valueCode":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Code) parseString(Code.builder(), "valueCode", reader, -1));
                    break;
                case "valueCoding":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCoding("valueCoding", reader, -1));
                    break;
                case "valueString":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseString("valueString", reader, -1));
                    break;
                case "valueInteger":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseInteger("valueInteger", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueDateTime":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDateTime("valueDateTime", reader, -1));
                    break;
                case "valueDecimal":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDecimal("valueDecimal", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CodeSystem.Filter parseCodeSystemFilter(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CodeSystem.Filter.Builder builder = CodeSystem.Filter.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, operatorElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code((Code) parseString(Code.builder(), "code", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 3, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "operator":
                    position = checkElementOrder("operator", 4, position, true);
                    builder.operator((FilterOperator) parseString(FilterOperator.builder(), "operator", reader, operatorElementIndex++));
                    break;
                case "value":
                    position = checkElementOrder("value", 5, position, false);
                    builder.value(parseString("value", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CodeSystem.Property parseCodeSystemProperty(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CodeSystem.Property.Builder builder = CodeSystem.Property.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code((Code) parseString(Code.builder(), "code", reader, -1));
                    break;
                case "uri":
                    position = checkElementOrder("uri", 3, position, false);
                    builder.uri(parseUri("uri", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 4, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 5, position, false);
                    builder.type((PropertyType) parseString(PropertyType.builder(), "type", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CodeableConcept parseCodeableConcept(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CodeableConcept.Builder builder = CodeableConcept.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, codingElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "coding":
                    position = checkElementOrder("coding", 1, position, true);
                    builder.coding(parseCoding("coding", reader, codingElementIndex++));
                    break;
                case "text":
                    position = checkElementOrder("text", 2, position, false);
                    builder.text(parseString("text", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CodeableReference parseCodeableReference(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CodeableReference.Builder builder = CodeableReference.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "concept":
                    position = checkElementOrder("concept", 1, position, false);
                    builder.concept(parseCodeableConcept("concept", reader, -1));
                    break;
                case "reference":
                    position = checkElementOrder("reference", 2, position, false);
                    builder.reference(parseReference("reference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Coding parseCoding(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Coding.Builder builder = Coding.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "system":
                    position = checkElementOrder("system", 1, position, false);
                    builder.system(parseUri("system", reader, -1));
                    break;
                case "version":
                    position = checkElementOrder("version", 2, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 3, position, false);
                    builder.code((Code) parseString(Code.builder(), "code", reader, -1));
                    break;
                case "display":
                    position = checkElementOrder("display", 4, position, false);
                    builder.display(parseString("display", reader, -1));
                    break;
                case "userSelected":
                    position = checkElementOrder("userSelected", 5, position, false);
                    builder.userSelected(parseBoolean("userSelected", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Communication parseCommunication(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Communication.Builder builder = Communication.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, instantiatesCanonicalElementIndex = 0, instantiatesUriElementIndex = 0, basedOnElementIndex = 0, partOfElementIndex = 0, inResponseToElementIndex = 0, categoryElementIndex = 0, mediumElementIndex = 0, aboutElementIndex = 0, recipientElementIndex = 0, reasonCodeElementIndex = 0, reasonReferenceElementIndex = 0, payloadElementIndex = 0, noteElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "instantiatesCanonical":
                    position = checkElementOrder("instantiatesCanonical", 9, position, true);
                    builder.instantiatesCanonical((Canonical) parseUri(Canonical.builder(), "instantiatesCanonical", reader, instantiatesCanonicalElementIndex++));
                    break;
                case "instantiatesUri":
                    position = checkElementOrder("instantiatesUri", 10, position, true);
                    builder.instantiatesUri(parseUri("instantiatesUri", reader, instantiatesUriElementIndex++));
                    break;
                case "basedOn":
                    position = checkElementOrder("basedOn", 11, position, true);
                    builder.basedOn(parseReference("basedOn", reader, basedOnElementIndex++));
                    break;
                case "partOf":
                    position = checkElementOrder("partOf", 12, position, true);
                    builder.partOf(parseReference("partOf", reader, partOfElementIndex++));
                    break;
                case "inResponseTo":
                    position = checkElementOrder("inResponseTo", 13, position, true);
                    builder.inResponseTo(parseReference("inResponseTo", reader, inResponseToElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 14, position, false);
                    builder.status((CommunicationStatus) parseString(CommunicationStatus.builder(), "status", reader, -1));
                    break;
                case "statusReason":
                    position = checkElementOrder("statusReason", 15, position, false);
                    builder.statusReason(parseCodeableConcept("statusReason", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 16, position, true);
                    builder.category(parseCodeableConcept("category", reader, categoryElementIndex++));
                    break;
                case "priority":
                    position = checkElementOrder("priority", 17, position, false);
                    builder.priority((CommunicationPriority) parseString(CommunicationPriority.builder(), "priority", reader, -1));
                    break;
                case "medium":
                    position = checkElementOrder("medium", 18, position, true);
                    builder.medium(parseCodeableConcept("medium", reader, mediumElementIndex++));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 19, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "topic":
                    position = checkElementOrder("topic", 20, position, false);
                    builder.topic(parseCodeableConcept("topic", reader, -1));
                    break;
                case "about":
                    position = checkElementOrder("about", 21, position, true);
                    builder.about(parseReference("about", reader, aboutElementIndex++));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 22, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "sent":
                    position = checkElementOrder("sent", 23, position, false);
                    builder.sent(parseDateTime("sent", reader, -1));
                    break;
                case "received":
                    position = checkElementOrder("received", 24, position, false);
                    builder.received(parseDateTime("received", reader, -1));
                    break;
                case "recipient":
                    position = checkElementOrder("recipient", 25, position, true);
                    builder.recipient(parseReference("recipient", reader, recipientElementIndex++));
                    break;
                case "sender":
                    position = checkElementOrder("sender", 26, position, false);
                    builder.sender(parseReference("sender", reader, -1));
                    break;
                case "reasonCode":
                    position = checkElementOrder("reasonCode", 27, position, true);
                    builder.reasonCode(parseCodeableConcept("reasonCode", reader, reasonCodeElementIndex++));
                    break;
                case "reasonReference":
                    position = checkElementOrder("reasonReference", 28, position, true);
                    builder.reasonReference(parseReference("reasonReference", reader, reasonReferenceElementIndex++));
                    break;
                case "payload":
                    position = checkElementOrder("payload", 29, position, true);
                    builder.payload(parseCommunicationPayload("payload", reader, payloadElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 30, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Communication.Payload parseCommunicationPayload(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Communication.Payload.Builder builder = Communication.Payload.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "contentString":
                    position = checkElementOrder("content[x]", 2, position, false);
                    builder.content(parseString("contentString", reader, -1));
                    break;
                case "contentAttachment":
                    position = checkElementOrder("content[x]", 2, position, false);
                    builder.content(parseAttachment("contentAttachment", reader, -1));
                    break;
                case "contentReference":
                    position = checkElementOrder("content[x]", 2, position, false);
                    builder.content(parseReference("contentReference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CommunicationRequest parseCommunicationRequest(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CommunicationRequest.Builder builder = CommunicationRequest.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, basedOnElementIndex = 0, replacesElementIndex = 0, categoryElementIndex = 0, mediumElementIndex = 0, aboutElementIndex = 0, payloadElementIndex = 0, recipientElementIndex = 0, reasonCodeElementIndex = 0, reasonReferenceElementIndex = 0, noteElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "basedOn":
                    position = checkElementOrder("basedOn", 9, position, true);
                    builder.basedOn(parseReference("basedOn", reader, basedOnElementIndex++));
                    break;
                case "replaces":
                    position = checkElementOrder("replaces", 10, position, true);
                    builder.replaces(parseReference("replaces", reader, replacesElementIndex++));
                    break;
                case "groupIdentifier":
                    position = checkElementOrder("groupIdentifier", 11, position, false);
                    builder.groupIdentifier(parseIdentifier("groupIdentifier", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 12, position, false);
                    builder.status((CommunicationRequestStatus) parseString(CommunicationRequestStatus.builder(), "status", reader, -1));
                    break;
                case "statusReason":
                    position = checkElementOrder("statusReason", 13, position, false);
                    builder.statusReason(parseCodeableConcept("statusReason", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 14, position, true);
                    builder.category(parseCodeableConcept("category", reader, categoryElementIndex++));
                    break;
                case "priority":
                    position = checkElementOrder("priority", 15, position, false);
                    builder.priority((CommunicationPriority) parseString(CommunicationPriority.builder(), "priority", reader, -1));
                    break;
                case "doNotPerform":
                    position = checkElementOrder("doNotPerform", 16, position, false);
                    builder.doNotPerform(parseBoolean("doNotPerform", reader, -1));
                    break;
                case "medium":
                    position = checkElementOrder("medium", 17, position, true);
                    builder.medium(parseCodeableConcept("medium", reader, mediumElementIndex++));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 18, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "about":
                    position = checkElementOrder("about", 19, position, true);
                    builder.about(parseReference("about", reader, aboutElementIndex++));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 20, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "payload":
                    position = checkElementOrder("payload", 21, position, true);
                    builder.payload(parseCommunicationRequestPayload("payload", reader, payloadElementIndex++));
                    break;
                case "occurrenceDateTime":
                    position = checkElementOrder("occurrence[x]", 22, position, false);
                    builder.occurrence(parseDateTime("occurrenceDateTime", reader, -1));
                    break;
                case "occurrencePeriod":
                    position = checkElementOrder("occurrence[x]", 22, position, false);
                    builder.occurrence(parsePeriod("occurrencePeriod", reader, -1));
                    break;
                case "authoredOn":
                    position = checkElementOrder("authoredOn", 23, position, false);
                    builder.authoredOn(parseDateTime("authoredOn", reader, -1));
                    break;
                case "requester":
                    position = checkElementOrder("requester", 24, position, false);
                    builder.requester(parseReference("requester", reader, -1));
                    break;
                case "recipient":
                    position = checkElementOrder("recipient", 25, position, true);
                    builder.recipient(parseReference("recipient", reader, recipientElementIndex++));
                    break;
                case "sender":
                    position = checkElementOrder("sender", 26, position, false);
                    builder.sender(parseReference("sender", reader, -1));
                    break;
                case "reasonCode":
                    position = checkElementOrder("reasonCode", 27, position, true);
                    builder.reasonCode(parseCodeableConcept("reasonCode", reader, reasonCodeElementIndex++));
                    break;
                case "reasonReference":
                    position = checkElementOrder("reasonReference", 28, position, true);
                    builder.reasonReference(parseReference("reasonReference", reader, reasonReferenceElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 29, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CommunicationRequest.Payload parseCommunicationRequestPayload(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CommunicationRequest.Payload.Builder builder = CommunicationRequest.Payload.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "contentString":
                    position = checkElementOrder("content[x]", 2, position, false);
                    builder.content(parseString("contentString", reader, -1));
                    break;
                case "contentAttachment":
                    position = checkElementOrder("content[x]", 2, position, false);
                    builder.content(parseAttachment("contentAttachment", reader, -1));
                    break;
                case "contentReference":
                    position = checkElementOrder("content[x]", 2, position, false);
                    builder.content(parseReference("contentReference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CompartmentDefinition parseCompartmentDefinition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CompartmentDefinition.Builder builder = CompartmentDefinition.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, contactElementIndex = 0, useContextElementIndex = 0, resourceElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "version":
                    position = checkElementOrder("version", 9, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 10, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 11, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 12, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 13, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 14, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 15, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 16, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 17, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 18, position, false);
                    builder.purpose((Markdown) parseString(Markdown.builder(), "purpose", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 19, position, false);
                    builder.code((CompartmentType) parseString(CompartmentType.builder(), "code", reader, -1));
                    break;
                case "search":
                    position = checkElementOrder("search", 20, position, false);
                    builder.search(parseBoolean("search", reader, -1));
                    break;
                case "resource":
                    position = checkElementOrder("resource", 21, position, true);
                    builder.resource(parseCompartmentDefinitionResource("resource", reader, resourceElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CompartmentDefinition.Resource parseCompartmentDefinitionResource(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CompartmentDefinition.Resource.Builder builder = CompartmentDefinition.Resource.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, paramElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code((ResourceTypeCode) parseString(ResourceTypeCode.builder(), "code", reader, -1));
                    break;
                case "param":
                    position = checkElementOrder("param", 3, position, true);
                    builder.param(parseString("param", reader, paramElementIndex++));
                    break;
                case "documentation":
                    position = checkElementOrder("documentation", 4, position, false);
                    builder.documentation(parseString("documentation", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Composition parseComposition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Composition.Builder builder = Composition.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, categoryElementIndex = 0, authorElementIndex = 0, attesterElementIndex = 0, relatesToElementIndex = 0, eventElementIndex = 0, sectionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, false);
                    builder.identifier(parseIdentifier("identifier", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((CompositionStatus) parseString(CompositionStatus.builder(), "status", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 10, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 11, position, true);
                    builder.category(parseCodeableConcept("category", reader, categoryElementIndex++));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 12, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 13, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 14, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "author":
                    position = checkElementOrder("author", 15, position, true);
                    builder.author(parseReference("author", reader, authorElementIndex++));
                    break;
                case "title":
                    position = checkElementOrder("title", 16, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "confidentiality":
                    position = checkElementOrder("confidentiality", 17, position, false);
                    builder.confidentiality((DocumentConfidentiality) parseString(DocumentConfidentiality.builder(), "confidentiality", reader, -1));
                    break;
                case "attester":
                    position = checkElementOrder("attester", 18, position, true);
                    builder.attester(parseCompositionAttester("attester", reader, attesterElementIndex++));
                    break;
                case "custodian":
                    position = checkElementOrder("custodian", 19, position, false);
                    builder.custodian(parseReference("custodian", reader, -1));
                    break;
                case "relatesTo":
                    position = checkElementOrder("relatesTo", 20, position, true);
                    builder.relatesTo(parseCompositionRelatesTo("relatesTo", reader, relatesToElementIndex++));
                    break;
                case "event":
                    position = checkElementOrder("event", 21, position, true);
                    builder.event(parseCompositionEvent("event", reader, eventElementIndex++));
                    break;
                case "section":
                    position = checkElementOrder("section", 22, position, true);
                    builder.section(parseCompositionSection("section", reader, sectionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Composition.Attester parseCompositionAttester(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Composition.Attester.Builder builder = Composition.Attester.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "mode":
                    position = checkElementOrder("mode", 2, position, false);
                    builder.mode((CompositionAttestationMode) parseString(CompositionAttestationMode.builder(), "mode", reader, -1));
                    break;
                case "time":
                    position = checkElementOrder("time", 3, position, false);
                    builder.time(parseDateTime("time", reader, -1));
                    break;
                case "party":
                    position = checkElementOrder("party", 4, position, false);
                    builder.party(parseReference("party", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Composition.Event parseCompositionEvent(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Composition.Event.Builder builder = Composition.Event.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, codeElementIndex = 0, detailElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, true);
                    builder.code(parseCodeableConcept("code", reader, codeElementIndex++));
                    break;
                case "period":
                    position = checkElementOrder("period", 3, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                case "detail":
                    position = checkElementOrder("detail", 4, position, true);
                    builder.detail(parseReference("detail", reader, detailElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Composition.RelatesTo parseCompositionRelatesTo(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Composition.RelatesTo.Builder builder = Composition.RelatesTo.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code((DocumentRelationshipType) parseString(DocumentRelationshipType.builder(), "code", reader, -1));
                    break;
                case "targetIdentifier":
                    position = checkElementOrder("target[x]", 3, position, false);
                    builder.target(parseIdentifier("targetIdentifier", reader, -1));
                    break;
                case "targetReference":
                    position = checkElementOrder("target[x]", 3, position, false);
                    builder.target(parseReference("targetReference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Composition.Section parseCompositionSection(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Composition.Section.Builder builder = Composition.Section.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, authorElementIndex = 0, entryElementIndex = 0, sectionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "title":
                    position = checkElementOrder("title", 2, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 3, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "author":
                    position = checkElementOrder("author", 4, position, true);
                    builder.author(parseReference("author", reader, authorElementIndex++));
                    break;
                case "focus":
                    position = checkElementOrder("focus", 5, position, false);
                    builder.focus(parseReference("focus", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 6, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "mode":
                    position = checkElementOrder("mode", 7, position, false);
                    builder.mode((SectionMode) parseString(SectionMode.builder(), "mode", reader, -1));
                    break;
                case "orderedBy":
                    position = checkElementOrder("orderedBy", 8, position, false);
                    builder.orderedBy(parseCodeableConcept("orderedBy", reader, -1));
                    break;
                case "entry":
                    position = checkElementOrder("entry", 9, position, true);
                    builder.entry(parseReference("entry", reader, entryElementIndex++));
                    break;
                case "emptyReason":
                    position = checkElementOrder("emptyReason", 10, position, false);
                    builder.emptyReason(parseCodeableConcept("emptyReason", reader, -1));
                    break;
                case "section":
                    position = checkElementOrder("section", 11, position, true);
                    builder.section(parseCompositionSection("section", reader, sectionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ConceptMap parseConceptMap(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ConceptMap.Builder builder = ConceptMap.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, contactElementIndex = 0, useContextElementIndex = 0, jurisdictionElementIndex = 0, groupElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, false);
                    builder.identifier(parseIdentifier("identifier", reader, -1));
                    break;
                case "version":
                    position = checkElementOrder("version", 10, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 11, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 12, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 13, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 14, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 15, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 16, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 17, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 18, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 19, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 20, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 21, position, false);
                    builder.purpose((Markdown) parseString(Markdown.builder(), "purpose", reader, -1));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 22, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                case "sourceUri":
                    position = checkElementOrder("source[x]", 23, position, false);
                    builder.source(parseUri("sourceUri", reader, -1));
                    break;
                case "sourceCanonical":
                    position = checkElementOrder("source[x]", 23, position, false);
                    builder.source((Canonical) parseUri(Canonical.builder(), "sourceCanonical", reader, -1));
                    break;
                case "targetUri":
                    position = checkElementOrder("target[x]", 24, position, false);
                    builder.target(parseUri("targetUri", reader, -1));
                    break;
                case "targetCanonical":
                    position = checkElementOrder("target[x]", 24, position, false);
                    builder.target((Canonical) parseUri(Canonical.builder(), "targetCanonical", reader, -1));
                    break;
                case "group":
                    position = checkElementOrder("group", 25, position, true);
                    builder.group(parseConceptMapGroup("group", reader, groupElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ConceptMap.Group parseConceptMapGroup(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ConceptMap.Group.Builder builder = ConceptMap.Group.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, elementElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "source":
                    position = checkElementOrder("source", 2, position, false);
                    builder.source(parseUri("source", reader, -1));
                    break;
                case "sourceVersion":
                    position = checkElementOrder("sourceVersion", 3, position, false);
                    builder.sourceVersion(parseString("sourceVersion", reader, -1));
                    break;
                case "target":
                    position = checkElementOrder("target", 4, position, false);
                    builder.target(parseUri("target", reader, -1));
                    break;
                case "targetVersion":
                    position = checkElementOrder("targetVersion", 5, position, false);
                    builder.targetVersion(parseString("targetVersion", reader, -1));
                    break;
                case "element":
                    position = checkElementOrder("element", 6, position, true);
                    builder.element(parseConceptMapGroupElement("element", reader, elementElementIndex++));
                    break;
                case "unmapped":
                    position = checkElementOrder("unmapped", 7, position, false);
                    builder.unmapped(parseConceptMapGroupUnmapped("unmapped", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ConceptMap.Group.Element parseConceptMapGroupElement(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ConceptMap.Group.Element.Builder builder = ConceptMap.Group.Element.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, targetElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code((Code) parseString(Code.builder(), "code", reader, -1));
                    break;
                case "display":
                    position = checkElementOrder("display", 3, position, false);
                    builder.display(parseString("display", reader, -1));
                    break;
                case "target":
                    position = checkElementOrder("target", 4, position, true);
                    builder.target(parseConceptMapGroupElementTarget("target", reader, targetElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ConceptMap.Group.Element.Target parseConceptMapGroupElementTarget(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ConceptMap.Group.Element.Target.Builder builder = ConceptMap.Group.Element.Target.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, dependsOnElementIndex = 0, productElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code((Code) parseString(Code.builder(), "code", reader, -1));
                    break;
                case "display":
                    position = checkElementOrder("display", 3, position, false);
                    builder.display(parseString("display", reader, -1));
                    break;
                case "equivalence":
                    position = checkElementOrder("equivalence", 4, position, false);
                    builder.equivalence((ConceptMapEquivalence) parseString(ConceptMapEquivalence.builder(), "equivalence", reader, -1));
                    break;
                case "comment":
                    position = checkElementOrder("comment", 5, position, false);
                    builder.comment(parseString("comment", reader, -1));
                    break;
                case "dependsOn":
                    position = checkElementOrder("dependsOn", 6, position, true);
                    builder.dependsOn(parseConceptMapGroupElementTargetDependsOn("dependsOn", reader, dependsOnElementIndex++));
                    break;
                case "product":
                    position = checkElementOrder("product", 7, position, true);
                    builder.product(parseConceptMapGroupElementTargetDependsOn("product", reader, productElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ConceptMap.Group.Element.Target.DependsOn parseConceptMapGroupElementTargetDependsOn(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ConceptMap.Group.Element.Target.DependsOn.Builder builder = ConceptMap.Group.Element.Target.DependsOn.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "property":
                    position = checkElementOrder("property", 2, position, false);
                    builder.property(parseUri("property", reader, -1));
                    break;
                case "system":
                    position = checkElementOrder("system", 3, position, false);
                    builder.system((Canonical) parseUri(Canonical.builder(), "system", reader, -1));
                    break;
                case "value":
                    position = checkElementOrder("value", 4, position, false);
                    builder.value(parseString("value", reader, -1));
                    break;
                case "display":
                    position = checkElementOrder("display", 5, position, false);
                    builder.display(parseString("display", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ConceptMap.Group.Unmapped parseConceptMapGroupUnmapped(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ConceptMap.Group.Unmapped.Builder builder = ConceptMap.Group.Unmapped.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "mode":
                    position = checkElementOrder("mode", 2, position, false);
                    builder.mode((ConceptMapGroupUnmappedMode) parseString(ConceptMapGroupUnmappedMode.builder(), "mode", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 3, position, false);
                    builder.code((Code) parseString(Code.builder(), "code", reader, -1));
                    break;
                case "display":
                    position = checkElementOrder("display", 4, position, false);
                    builder.display(parseString("display", reader, -1));
                    break;
                case "url":
                    position = checkElementOrder("url", 5, position, false);
                    builder.url((Canonical) parseUri(Canonical.builder(), "url", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Condition parseCondition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Condition.Builder builder = Condition.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, categoryElementIndex = 0, bodySiteElementIndex = 0, stageElementIndex = 0, evidenceElementIndex = 0, noteElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "clinicalStatus":
                    position = checkElementOrder("clinicalStatus", 9, position, false);
                    builder.clinicalStatus(parseCodeableConcept("clinicalStatus", reader, -1));
                    break;
                case "verificationStatus":
                    position = checkElementOrder("verificationStatus", 10, position, false);
                    builder.verificationStatus(parseCodeableConcept("verificationStatus", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 11, position, true);
                    builder.category(parseCodeableConcept("category", reader, categoryElementIndex++));
                    break;
                case "severity":
                    position = checkElementOrder("severity", 12, position, false);
                    builder.severity(parseCodeableConcept("severity", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 13, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "bodySite":
                    position = checkElementOrder("bodySite", 14, position, true);
                    builder.bodySite(parseCodeableConcept("bodySite", reader, bodySiteElementIndex++));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 15, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 16, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "onsetDateTime":
                    position = checkElementOrder("onset[x]", 17, position, false);
                    builder.onset(parseDateTime("onsetDateTime", reader, -1));
                    break;
                case "onsetAge":
                    position = checkElementOrder("onset[x]", 17, position, false);
                    builder.onset((Age) parseQuantity(Age.builder(), "onsetAge", reader, -1));
                    break;
                case "onsetPeriod":
                    position = checkElementOrder("onset[x]", 17, position, false);
                    builder.onset(parsePeriod("onsetPeriod", reader, -1));
                    break;
                case "onsetRange":
                    position = checkElementOrder("onset[x]", 17, position, false);
                    builder.onset(parseRange("onsetRange", reader, -1));
                    break;
                case "onsetString":
                    position = checkElementOrder("onset[x]", 17, position, false);
                    builder.onset(parseString("onsetString", reader, -1));
                    break;
                case "abatementDateTime":
                    position = checkElementOrder("abatement[x]", 18, position, false);
                    builder.abatement(parseDateTime("abatementDateTime", reader, -1));
                    break;
                case "abatementAge":
                    position = checkElementOrder("abatement[x]", 18, position, false);
                    builder.abatement((Age) parseQuantity(Age.builder(), "abatementAge", reader, -1));
                    break;
                case "abatementPeriod":
                    position = checkElementOrder("abatement[x]", 18, position, false);
                    builder.abatement(parsePeriod("abatementPeriod", reader, -1));
                    break;
                case "abatementRange":
                    position = checkElementOrder("abatement[x]", 18, position, false);
                    builder.abatement(parseRange("abatementRange", reader, -1));
                    break;
                case "abatementString":
                    position = checkElementOrder("abatement[x]", 18, position, false);
                    builder.abatement(parseString("abatementString", reader, -1));
                    break;
                case "recordedDate":
                    position = checkElementOrder("recordedDate", 19, position, false);
                    builder.recordedDate(parseDateTime("recordedDate", reader, -1));
                    break;
                case "recorder":
                    position = checkElementOrder("recorder", 20, position, false);
                    builder.recorder(parseReference("recorder", reader, -1));
                    break;
                case "asserter":
                    position = checkElementOrder("asserter", 21, position, false);
                    builder.asserter(parseReference("asserter", reader, -1));
                    break;
                case "stage":
                    position = checkElementOrder("stage", 22, position, true);
                    builder.stage(parseConditionStage("stage", reader, stageElementIndex++));
                    break;
                case "evidence":
                    position = checkElementOrder("evidence", 23, position, true);
                    builder.evidence(parseConditionEvidence("evidence", reader, evidenceElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 24, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Condition.Evidence parseConditionEvidence(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Condition.Evidence.Builder builder = Condition.Evidence.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, codeElementIndex = 0, detailElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, true);
                    builder.code(parseCodeableConcept("code", reader, codeElementIndex++));
                    break;
                case "detail":
                    position = checkElementOrder("detail", 3, position, true);
                    builder.detail(parseReference("detail", reader, detailElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Condition.Stage parseConditionStage(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Condition.Stage.Builder builder = Condition.Stage.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, assessmentElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "summary":
                    position = checkElementOrder("summary", 2, position, false);
                    builder.summary(parseCodeableConcept("summary", reader, -1));
                    break;
                case "assessment":
                    position = checkElementOrder("assessment", 3, position, true);
                    builder.assessment(parseReference("assessment", reader, assessmentElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 4, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Consent parseConsent(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Consent.Builder builder = Consent.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, categoryElementIndex = 0, performerElementIndex = 0, organizationElementIndex = 0, policyElementIndex = 0, verificationElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((ConsentState) parseString(ConsentState.builder(), "status", reader, -1));
                    break;
                case "scope":
                    position = checkElementOrder("scope", 10, position, false);
                    builder.scope(parseCodeableConcept("scope", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 11, position, true);
                    builder.category(parseCodeableConcept("category", reader, categoryElementIndex++));
                    break;
                case "patient":
                    position = checkElementOrder("patient", 12, position, false);
                    builder.patient(parseReference("patient", reader, -1));
                    break;
                case "dateTime":
                    position = checkElementOrder("dateTime", 13, position, false);
                    builder.dateTime(parseDateTime("dateTime", reader, -1));
                    break;
                case "performer":
                    position = checkElementOrder("performer", 14, position, true);
                    builder.performer(parseReference("performer", reader, performerElementIndex++));
                    break;
                case "organization":
                    position = checkElementOrder("organization", 15, position, true);
                    builder.organization(parseReference("organization", reader, organizationElementIndex++));
                    break;
                case "sourceAttachment":
                    position = checkElementOrder("source[x]", 16, position, false);
                    builder.source(parseAttachment("sourceAttachment", reader, -1));
                    break;
                case "sourceReference":
                    position = checkElementOrder("source[x]", 16, position, false);
                    builder.source(parseReference("sourceReference", reader, -1));
                    break;
                case "policy":
                    position = checkElementOrder("policy", 17, position, true);
                    builder.policy(parseConsentPolicy("policy", reader, policyElementIndex++));
                    break;
                case "policyRule":
                    position = checkElementOrder("policyRule", 18, position, false);
                    builder.policyRule(parseCodeableConcept("policyRule", reader, -1));
                    break;
                case "verification":
                    position = checkElementOrder("verification", 19, position, true);
                    builder.verification(parseConsentVerification("verification", reader, verificationElementIndex++));
                    break;
                case "provision":
                    position = checkElementOrder("provision", 20, position, false);
                    builder.provision(parseConsentProvision("provision", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Consent.Policy parseConsentPolicy(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Consent.Policy.Builder builder = Consent.Policy.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "authority":
                    position = checkElementOrder("authority", 2, position, false);
                    builder.authority(parseUri("authority", reader, -1));
                    break;
                case "uri":
                    position = checkElementOrder("uri", 3, position, false);
                    builder.uri(parseUri("uri", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Consent.Provision parseConsentProvision(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Consent.Provision.Builder builder = Consent.Provision.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, actorElementIndex = 0, actionElementIndex = 0, securityLabelElementIndex = 0, purposeElementIndex = 0, classElementIndex = 0, codeElementIndex = 0, dataElementIndex = 0, provisionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type((ConsentProvisionType) parseString(ConsentProvisionType.builder(), "type", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 3, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                case "actor":
                    position = checkElementOrder("actor", 4, position, true);
                    builder.actor(parseConsentProvisionActor("actor", reader, actorElementIndex++));
                    break;
                case "action":
                    position = checkElementOrder("action", 5, position, true);
                    builder.action(parseCodeableConcept("action", reader, actionElementIndex++));
                    break;
                case "securityLabel":
                    position = checkElementOrder("securityLabel", 6, position, true);
                    builder.securityLabel(parseCoding("securityLabel", reader, securityLabelElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 7, position, true);
                    builder.purpose(parseCoding("purpose", reader, purposeElementIndex++));
                    break;
                case "class":
                    position = checkElementOrder("class", 8, position, true);
                    builder.clazz(parseCoding("class", reader, classElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 9, position, true);
                    builder.code(parseCodeableConcept("code", reader, codeElementIndex++));
                    break;
                case "dataPeriod":
                    position = checkElementOrder("dataPeriod", 10, position, false);
                    builder.dataPeriod(parsePeriod("dataPeriod", reader, -1));
                    break;
                case "data":
                    position = checkElementOrder("data", 11, position, true);
                    builder.data(parseConsentProvisionData("data", reader, dataElementIndex++));
                    break;
                case "provision":
                    position = checkElementOrder("provision", 12, position, true);
                    builder.provision(parseConsentProvision("provision", reader, provisionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Consent.Provision.Actor parseConsentProvisionActor(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Consent.Provision.Actor.Builder builder = Consent.Provision.Actor.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "role":
                    position = checkElementOrder("role", 2, position, false);
                    builder.role(parseCodeableConcept("role", reader, -1));
                    break;
                case "reference":
                    position = checkElementOrder("reference", 3, position, false);
                    builder.reference(parseReference("reference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Consent.Provision.Data parseConsentProvisionData(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Consent.Provision.Data.Builder builder = Consent.Provision.Data.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "meaning":
                    position = checkElementOrder("meaning", 2, position, false);
                    builder.meaning((ConsentDataMeaning) parseString(ConsentDataMeaning.builder(), "meaning", reader, -1));
                    break;
                case "reference":
                    position = checkElementOrder("reference", 3, position, false);
                    builder.reference(parseReference("reference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Consent.Verification parseConsentVerification(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Consent.Verification.Builder builder = Consent.Verification.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "verified":
                    position = checkElementOrder("verified", 2, position, false);
                    builder.verified(parseBoolean("verified", reader, -1));
                    break;
                case "verifiedWith":
                    position = checkElementOrder("verifiedWith", 3, position, false);
                    builder.verifiedWith(parseReference("verifiedWith", reader, -1));
                    break;
                case "verificationDate":
                    position = checkElementOrder("verificationDate", 4, position, false);
                    builder.verificationDate(parseDateTime("verificationDate", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ContactDetail parseContactDetail(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ContactDetail.Builder builder = ContactDetail.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, telecomElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 1, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "telecom":
                    position = checkElementOrder("telecom", 2, position, true);
                    builder.telecom(parseContactPoint("telecom", reader, telecomElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ContactPoint parseContactPoint(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ContactPoint.Builder builder = ContactPoint.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "system":
                    position = checkElementOrder("system", 1, position, false);
                    builder.system((ContactPointSystem) parseString(ContactPointSystem.builder(), "system", reader, -1));
                    break;
                case "value":
                    position = checkElementOrder("value", 2, position, false);
                    builder.value(parseString("value", reader, -1));
                    break;
                case "use":
                    position = checkElementOrder("use", 3, position, false);
                    builder.use((ContactPointUse) parseString(ContactPointUse.builder(), "use", reader, -1));
                    break;
                case "rank":
                    position = checkElementOrder("rank", 4, position, false);
                    builder.rank((PositiveInt) parseInteger(PositiveInt.builder(), "rank", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 5, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Contract parseContract(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Contract.Builder builder = Contract.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, subjectElementIndex = 0, authorityElementIndex = 0, domainElementIndex = 0, siteElementIndex = 0, aliasElementIndex = 0, subTypeElementIndex = 0, termElementIndex = 0, supportingInfoElementIndex = 0, relevantHistoryElementIndex = 0, signerElementIndex = 0, friendlyElementIndex = 0, legalElementIndex = 0, ruleElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 9, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "version":
                    position = checkElementOrder("version", 10, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 11, position, false);
                    builder.status((ContractStatus) parseString(ContractStatus.builder(), "status", reader, -1));
                    break;
                case "legalState":
                    position = checkElementOrder("legalState", 12, position, false);
                    builder.legalState(parseCodeableConcept("legalState", reader, -1));
                    break;
                case "instantiatesCanonical":
                    position = checkElementOrder("instantiatesCanonical", 13, position, false);
                    builder.instantiatesCanonical(parseReference("instantiatesCanonical", reader, -1));
                    break;
                case "instantiatesUri":
                    position = checkElementOrder("instantiatesUri", 14, position, false);
                    builder.instantiatesUri(parseUri("instantiatesUri", reader, -1));
                    break;
                case "contentDerivative":
                    position = checkElementOrder("contentDerivative", 15, position, false);
                    builder.contentDerivative(parseCodeableConcept("contentDerivative", reader, -1));
                    break;
                case "issued":
                    position = checkElementOrder("issued", 16, position, false);
                    builder.issued(parseDateTime("issued", reader, -1));
                    break;
                case "applies":
                    position = checkElementOrder("applies", 17, position, false);
                    builder.applies(parsePeriod("applies", reader, -1));
                    break;
                case "expirationType":
                    position = checkElementOrder("expirationType", 18, position, false);
                    builder.expirationType(parseCodeableConcept("expirationType", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 19, position, true);
                    builder.subject(parseReference("subject", reader, subjectElementIndex++));
                    break;
                case "authority":
                    position = checkElementOrder("authority", 20, position, true);
                    builder.authority(parseReference("authority", reader, authorityElementIndex++));
                    break;
                case "domain":
                    position = checkElementOrder("domain", 21, position, true);
                    builder.domain(parseReference("domain", reader, domainElementIndex++));
                    break;
                case "site":
                    position = checkElementOrder("site", 22, position, true);
                    builder.site(parseReference("site", reader, siteElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 23, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 24, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "subtitle":
                    position = checkElementOrder("subtitle", 25, position, false);
                    builder.subtitle(parseString("subtitle", reader, -1));
                    break;
                case "alias":
                    position = checkElementOrder("alias", 26, position, true);
                    builder.alias(parseString("alias", reader, aliasElementIndex++));
                    break;
                case "author":
                    position = checkElementOrder("author", 27, position, false);
                    builder.author(parseReference("author", reader, -1));
                    break;
                case "scope":
                    position = checkElementOrder("scope", 28, position, false);
                    builder.scope(parseCodeableConcept("scope", reader, -1));
                    break;
                case "topicCodeableConcept":
                    position = checkElementOrder("topic[x]", 29, position, false);
                    builder.topic(parseCodeableConcept("topicCodeableConcept", reader, -1));
                    break;
                case "topicReference":
                    position = checkElementOrder("topic[x]", 29, position, false);
                    builder.topic(parseReference("topicReference", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 30, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "subType":
                    position = checkElementOrder("subType", 31, position, true);
                    builder.subType(parseCodeableConcept("subType", reader, subTypeElementIndex++));
                    break;
                case "contentDefinition":
                    position = checkElementOrder("contentDefinition", 32, position, false);
                    builder.contentDefinition(parseContractContentDefinition("contentDefinition", reader, -1));
                    break;
                case "term":
                    position = checkElementOrder("term", 33, position, true);
                    builder.term(parseContractTerm("term", reader, termElementIndex++));
                    break;
                case "supportingInfo":
                    position = checkElementOrder("supportingInfo", 34, position, true);
                    builder.supportingInfo(parseReference("supportingInfo", reader, supportingInfoElementIndex++));
                    break;
                case "relevantHistory":
                    position = checkElementOrder("relevantHistory", 35, position, true);
                    builder.relevantHistory(parseReference("relevantHistory", reader, relevantHistoryElementIndex++));
                    break;
                case "signer":
                    position = checkElementOrder("signer", 36, position, true);
                    builder.signer(parseContractSigner("signer", reader, signerElementIndex++));
                    break;
                case "friendly":
                    position = checkElementOrder("friendly", 37, position, true);
                    builder.friendly(parseContractFriendly("friendly", reader, friendlyElementIndex++));
                    break;
                case "legal":
                    position = checkElementOrder("legal", 38, position, true);
                    builder.legal(parseContractLegal("legal", reader, legalElementIndex++));
                    break;
                case "rule":
                    position = checkElementOrder("rule", 39, position, true);
                    builder.rule(parseContractRule("rule", reader, ruleElementIndex++));
                    break;
                case "legallyBindingAttachment":
                    position = checkElementOrder("legallyBinding[x]", 40, position, false);
                    builder.legallyBinding(parseAttachment("legallyBindingAttachment", reader, -1));
                    break;
                case "legallyBindingReference":
                    position = checkElementOrder("legallyBinding[x]", 40, position, false);
                    builder.legallyBinding(parseReference("legallyBindingReference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Contract.ContentDefinition parseContractContentDefinition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Contract.ContentDefinition.Builder builder = Contract.ContentDefinition.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "subType":
                    position = checkElementOrder("subType", 3, position, false);
                    builder.subType(parseCodeableConcept("subType", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 4, position, false);
                    builder.publisher(parseReference("publisher", reader, -1));
                    break;
                case "publicationDate":
                    position = checkElementOrder("publicationDate", 5, position, false);
                    builder.publicationDate(parseDateTime("publicationDate", reader, -1));
                    break;
                case "publicationStatus":
                    position = checkElementOrder("publicationStatus", 6, position, false);
                    builder.publicationStatus((ContractPublicationStatus) parseString(ContractPublicationStatus.builder(), "publicationStatus", reader, -1));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 7, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Contract.Friendly parseContractFriendly(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Contract.Friendly.Builder builder = Contract.Friendly.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "contentAttachment":
                    position = checkElementOrder("content[x]", 2, position, false);
                    builder.content(parseAttachment("contentAttachment", reader, -1));
                    break;
                case "contentReference":
                    position = checkElementOrder("content[x]", 2, position, false);
                    builder.content(parseReference("contentReference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Contract.Legal parseContractLegal(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Contract.Legal.Builder builder = Contract.Legal.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "contentAttachment":
                    position = checkElementOrder("content[x]", 2, position, false);
                    builder.content(parseAttachment("contentAttachment", reader, -1));
                    break;
                case "contentReference":
                    position = checkElementOrder("content[x]", 2, position, false);
                    builder.content(parseReference("contentReference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Contract.Rule parseContractRule(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Contract.Rule.Builder builder = Contract.Rule.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "contentAttachment":
                    position = checkElementOrder("content[x]", 2, position, false);
                    builder.content(parseAttachment("contentAttachment", reader, -1));
                    break;
                case "contentReference":
                    position = checkElementOrder("content[x]", 2, position, false);
                    builder.content(parseReference("contentReference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Contract.Signer parseContractSigner(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Contract.Signer.Builder builder = Contract.Signer.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, signatureElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCoding("type", reader, -1));
                    break;
                case "party":
                    position = checkElementOrder("party", 3, position, false);
                    builder.party(parseReference("party", reader, -1));
                    break;
                case "signature":
                    position = checkElementOrder("signature", 4, position, true);
                    builder.signature(parseSignature("signature", reader, signatureElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Contract.Term parseContractTerm(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Contract.Term.Builder builder = Contract.Term.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, securityLabelElementIndex = 0, assetElementIndex = 0, actionElementIndex = 0, groupElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 2, position, false);
                    builder.identifier(parseIdentifier("identifier", reader, -1));
                    break;
                case "issued":
                    position = checkElementOrder("issued", 3, position, false);
                    builder.issued(parseDateTime("issued", reader, -1));
                    break;
                case "applies":
                    position = checkElementOrder("applies", 4, position, false);
                    builder.applies(parsePeriod("applies", reader, -1));
                    break;
                case "topicCodeableConcept":
                    position = checkElementOrder("topic[x]", 5, position, false);
                    builder.topic(parseCodeableConcept("topicCodeableConcept", reader, -1));
                    break;
                case "topicReference":
                    position = checkElementOrder("topic[x]", 5, position, false);
                    builder.topic(parseReference("topicReference", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 6, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "subType":
                    position = checkElementOrder("subType", 7, position, false);
                    builder.subType(parseCodeableConcept("subType", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 8, position, false);
                    builder.text(parseString("text", reader, -1));
                    break;
                case "securityLabel":
                    position = checkElementOrder("securityLabel", 9, position, true);
                    builder.securityLabel(parseContractTermSecurityLabel("securityLabel", reader, securityLabelElementIndex++));
                    break;
                case "offer":
                    position = checkElementOrder("offer", 10, position, false);
                    builder.offer(parseContractTermOffer("offer", reader, -1));
                    break;
                case "asset":
                    position = checkElementOrder("asset", 11, position, true);
                    builder.asset(parseContractTermAsset("asset", reader, assetElementIndex++));
                    break;
                case "action":
                    position = checkElementOrder("action", 12, position, true);
                    builder.action(parseContractTermAction("action", reader, actionElementIndex++));
                    break;
                case "group":
                    position = checkElementOrder("group", 13, position, true);
                    builder.group(parseContractTerm("group", reader, groupElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Contract.Term.Action parseContractTermAction(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Contract.Term.Action.Builder builder = Contract.Term.Action.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, subjectElementIndex = 0, linkIdElementIndex = 0, contextLinkIdElementIndex = 0, requesterElementIndex = 0, requesterLinkIdElementIndex = 0, performerTypeElementIndex = 0, performerLinkIdElementIndex = 0, reasonCodeElementIndex = 0, reasonReferenceElementIndex = 0, reasonElementIndex = 0, reasonLinkIdElementIndex = 0, noteElementIndex = 0, securityLabelNumberElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "doNotPerform":
                    position = checkElementOrder("doNotPerform", 2, position, false);
                    builder.doNotPerform(parseBoolean("doNotPerform", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 4, position, true);
                    builder.subject(parseContractTermActionSubject("subject", reader, subjectElementIndex++));
                    break;
                case "intent":
                    position = checkElementOrder("intent", 5, position, false);
                    builder.intent(parseCodeableConcept("intent", reader, -1));
                    break;
                case "linkId":
                    position = checkElementOrder("linkId", 6, position, true);
                    builder.linkId(parseString("linkId", reader, linkIdElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 7, position, false);
                    builder.status(parseCodeableConcept("status", reader, -1));
                    break;
                case "context":
                    position = checkElementOrder("context", 8, position, false);
                    builder.context(parseReference("context", reader, -1));
                    break;
                case "contextLinkId":
                    position = checkElementOrder("contextLinkId", 9, position, true);
                    builder.contextLinkId(parseString("contextLinkId", reader, contextLinkIdElementIndex++));
                    break;
                case "occurrenceDateTime":
                    position = checkElementOrder("occurrence[x]", 10, position, false);
                    builder.occurrence(parseDateTime("occurrenceDateTime", reader, -1));
                    break;
                case "occurrencePeriod":
                    position = checkElementOrder("occurrence[x]", 10, position, false);
                    builder.occurrence(parsePeriod("occurrencePeriod", reader, -1));
                    break;
                case "occurrenceTiming":
                    position = checkElementOrder("occurrence[x]", 10, position, false);
                    builder.occurrence(parseTiming("occurrenceTiming", reader, -1));
                    break;
                case "requester":
                    position = checkElementOrder("requester", 11, position, true);
                    builder.requester(parseReference("requester", reader, requesterElementIndex++));
                    break;
                case "requesterLinkId":
                    position = checkElementOrder("requesterLinkId", 12, position, true);
                    builder.requesterLinkId(parseString("requesterLinkId", reader, requesterLinkIdElementIndex++));
                    break;
                case "performerType":
                    position = checkElementOrder("performerType", 13, position, true);
                    builder.performerType(parseCodeableConcept("performerType", reader, performerTypeElementIndex++));
                    break;
                case "performerRole":
                    position = checkElementOrder("performerRole", 14, position, false);
                    builder.performerRole(parseCodeableConcept("performerRole", reader, -1));
                    break;
                case "performer":
                    position = checkElementOrder("performer", 15, position, false);
                    builder.performer(parseReference("performer", reader, -1));
                    break;
                case "performerLinkId":
                    position = checkElementOrder("performerLinkId", 16, position, true);
                    builder.performerLinkId(parseString("performerLinkId", reader, performerLinkIdElementIndex++));
                    break;
                case "reasonCode":
                    position = checkElementOrder("reasonCode", 17, position, true);
                    builder.reasonCode(parseCodeableConcept("reasonCode", reader, reasonCodeElementIndex++));
                    break;
                case "reasonReference":
                    position = checkElementOrder("reasonReference", 18, position, true);
                    builder.reasonReference(parseReference("reasonReference", reader, reasonReferenceElementIndex++));
                    break;
                case "reason":
                    position = checkElementOrder("reason", 19, position, true);
                    builder.reason(parseString("reason", reader, reasonElementIndex++));
                    break;
                case "reasonLinkId":
                    position = checkElementOrder("reasonLinkId", 20, position, true);
                    builder.reasonLinkId(parseString("reasonLinkId", reader, reasonLinkIdElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 21, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "securityLabelNumber":
                    position = checkElementOrder("securityLabelNumber", 22, position, true);
                    builder.securityLabelNumber((UnsignedInt) parseInteger(UnsignedInt.builder(), "securityLabelNumber", reader, securityLabelNumberElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Contract.Term.Action.Subject parseContractTermActionSubject(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Contract.Term.Action.Subject.Builder builder = Contract.Term.Action.Subject.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, referenceElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "reference":
                    position = checkElementOrder("reference", 2, position, true);
                    builder.reference(parseReference("reference", reader, referenceElementIndex++));
                    break;
                case "role":
                    position = checkElementOrder("role", 3, position, false);
                    builder.role(parseCodeableConcept("role", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Contract.Term.Asset parseContractTermAsset(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Contract.Term.Asset.Builder builder = Contract.Term.Asset.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, typeElementIndex = 0, typeReferenceElementIndex = 0, subtypeElementIndex = 0, contextElementIndex = 0, periodTypeElementIndex = 0, periodElementIndex = 0, usePeriodElementIndex = 0, linkIdElementIndex = 0, answerElementIndex = 0, securityLabelNumberElementIndex = 0, valuedItemElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "scope":
                    position = checkElementOrder("scope", 2, position, false);
                    builder.scope(parseCodeableConcept("scope", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, true);
                    builder.type(parseCodeableConcept("type", reader, typeElementIndex++));
                    break;
                case "typeReference":
                    position = checkElementOrder("typeReference", 4, position, true);
                    builder.typeReference(parseReference("typeReference", reader, typeReferenceElementIndex++));
                    break;
                case "subtype":
                    position = checkElementOrder("subtype", 5, position, true);
                    builder.subtype(parseCodeableConcept("subtype", reader, subtypeElementIndex++));
                    break;
                case "relationship":
                    position = checkElementOrder("relationship", 6, position, false);
                    builder.relationship(parseCoding("relationship", reader, -1));
                    break;
                case "context":
                    position = checkElementOrder("context", 7, position, true);
                    builder.context(parseContractTermAssetContext("context", reader, contextElementIndex++));
                    break;
                case "condition":
                    position = checkElementOrder("condition", 8, position, false);
                    builder.condition(parseString("condition", reader, -1));
                    break;
                case "periodType":
                    position = checkElementOrder("periodType", 9, position, true);
                    builder.periodType(parseCodeableConcept("periodType", reader, periodTypeElementIndex++));
                    break;
                case "period":
                    position = checkElementOrder("period", 10, position, true);
                    builder.period(parsePeriod("period", reader, periodElementIndex++));
                    break;
                case "usePeriod":
                    position = checkElementOrder("usePeriod", 11, position, true);
                    builder.usePeriod(parsePeriod("usePeriod", reader, usePeriodElementIndex++));
                    break;
                case "text":
                    position = checkElementOrder("text", 12, position, false);
                    builder.text(parseString("text", reader, -1));
                    break;
                case "linkId":
                    position = checkElementOrder("linkId", 13, position, true);
                    builder.linkId(parseString("linkId", reader, linkIdElementIndex++));
                    break;
                case "answer":
                    position = checkElementOrder("answer", 14, position, true);
                    builder.answer(parseContractTermOfferAnswer("answer", reader, answerElementIndex++));
                    break;
                case "securityLabelNumber":
                    position = checkElementOrder("securityLabelNumber", 15, position, true);
                    builder.securityLabelNumber((UnsignedInt) parseInteger(UnsignedInt.builder(), "securityLabelNumber", reader, securityLabelNumberElementIndex++));
                    break;
                case "valuedItem":
                    position = checkElementOrder("valuedItem", 16, position, true);
                    builder.valuedItem(parseContractTermAssetValuedItem("valuedItem", reader, valuedItemElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Contract.Term.Asset.Context parseContractTermAssetContext(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Contract.Term.Asset.Context.Builder builder = Contract.Term.Asset.Context.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, codeElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "reference":
                    position = checkElementOrder("reference", 2, position, false);
                    builder.reference(parseReference("reference", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 3, position, true);
                    builder.code(parseCodeableConcept("code", reader, codeElementIndex++));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseString("text", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Contract.Term.Asset.ValuedItem parseContractTermAssetValuedItem(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Contract.Term.Asset.ValuedItem.Builder builder = Contract.Term.Asset.ValuedItem.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, linkIdElementIndex = 0, securityLabelNumberElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "entityCodeableConcept":
                    position = checkElementOrder("entity[x]", 2, position, false);
                    builder.entity(parseCodeableConcept("entityCodeableConcept", reader, -1));
                    break;
                case "entityReference":
                    position = checkElementOrder("entity[x]", 2, position, false);
                    builder.entity(parseReference("entityReference", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 3, position, false);
                    builder.identifier(parseIdentifier("identifier", reader, -1));
                    break;
                case "effectiveTime":
                    position = checkElementOrder("effectiveTime", 4, position, false);
                    builder.effectiveTime(parseDateTime("effectiveTime", reader, -1));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 5, position, false);
                    builder.quantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "quantity", reader, -1));
                    break;
                case "unitPrice":
                    position = checkElementOrder("unitPrice", 6, position, false);
                    builder.unitPrice(parseMoney("unitPrice", reader, -1));
                    break;
                case "factor":
                    position = checkElementOrder("factor", 7, position, false);
                    builder.factor(parseDecimal("factor", reader, -1));
                    break;
                case "points":
                    position = checkElementOrder("points", 8, position, false);
                    builder.points(parseDecimal("points", reader, -1));
                    break;
                case "net":
                    position = checkElementOrder("net", 9, position, false);
                    builder.net(parseMoney("net", reader, -1));
                    break;
                case "payment":
                    position = checkElementOrder("payment", 10, position, false);
                    builder.payment(parseString("payment", reader, -1));
                    break;
                case "paymentDate":
                    position = checkElementOrder("paymentDate", 11, position, false);
                    builder.paymentDate(parseDateTime("paymentDate", reader, -1));
                    break;
                case "responsible":
                    position = checkElementOrder("responsible", 12, position, false);
                    builder.responsible(parseReference("responsible", reader, -1));
                    break;
                case "recipient":
                    position = checkElementOrder("recipient", 13, position, false);
                    builder.recipient(parseReference("recipient", reader, -1));
                    break;
                case "linkId":
                    position = checkElementOrder("linkId", 14, position, true);
                    builder.linkId(parseString("linkId", reader, linkIdElementIndex++));
                    break;
                case "securityLabelNumber":
                    position = checkElementOrder("securityLabelNumber", 15, position, true);
                    builder.securityLabelNumber((UnsignedInt) parseInteger(UnsignedInt.builder(), "securityLabelNumber", reader, securityLabelNumberElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Contract.Term.Offer parseContractTermOffer(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Contract.Term.Offer.Builder builder = Contract.Term.Offer.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, partyElementIndex = 0, decisionModeElementIndex = 0, answerElementIndex = 0, linkIdElementIndex = 0, securityLabelNumberElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 2, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "party":
                    position = checkElementOrder("party", 3, position, true);
                    builder.party(parseContractTermOfferParty("party", reader, partyElementIndex++));
                    break;
                case "topic":
                    position = checkElementOrder("topic", 4, position, false);
                    builder.topic(parseReference("topic", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 5, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "decision":
                    position = checkElementOrder("decision", 6, position, false);
                    builder.decision(parseCodeableConcept("decision", reader, -1));
                    break;
                case "decisionMode":
                    position = checkElementOrder("decisionMode", 7, position, true);
                    builder.decisionMode(parseCodeableConcept("decisionMode", reader, decisionModeElementIndex++));
                    break;
                case "answer":
                    position = checkElementOrder("answer", 8, position, true);
                    builder.answer(parseContractTermOfferAnswer("answer", reader, answerElementIndex++));
                    break;
                case "text":
                    position = checkElementOrder("text", 9, position, false);
                    builder.text(parseString("text", reader, -1));
                    break;
                case "linkId":
                    position = checkElementOrder("linkId", 10, position, true);
                    builder.linkId(parseString("linkId", reader, linkIdElementIndex++));
                    break;
                case "securityLabelNumber":
                    position = checkElementOrder("securityLabelNumber", 11, position, true);
                    builder.securityLabelNumber((UnsignedInt) parseInteger(UnsignedInt.builder(), "securityLabelNumber", reader, securityLabelNumberElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Contract.Term.Offer.Answer parseContractTermOfferAnswer(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Contract.Term.Offer.Answer.Builder builder = Contract.Term.Offer.Answer.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueDecimal":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseDecimal("valueDecimal", reader, -1));
                    break;
                case "valueInteger":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseInteger("valueInteger", reader, -1));
                    break;
                case "valueDate":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseDate("valueDate", reader, -1));
                    break;
                case "valueDateTime":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseDateTime("valueDateTime", reader, -1));
                    break;
                case "valueTime":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseTime("valueTime", reader, -1));
                    break;
                case "valueString":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseString("valueString", reader, -1));
                    break;
                case "valueUri":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseUri("valueUri", reader, -1));
                    break;
                case "valueAttachment":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseAttachment("valueAttachment", reader, -1));
                    break;
                case "valueCoding":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseCoding("valueCoding", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueReference":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseReference("valueReference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Contract.Term.Offer.Party parseContractTermOfferParty(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Contract.Term.Offer.Party.Builder builder = Contract.Term.Offer.Party.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, referenceElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "reference":
                    position = checkElementOrder("reference", 2, position, true);
                    builder.reference(parseReference("reference", reader, referenceElementIndex++));
                    break;
                case "role":
                    position = checkElementOrder("role", 3, position, false);
                    builder.role(parseCodeableConcept("role", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Contract.Term.SecurityLabel parseContractTermSecurityLabel(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Contract.Term.SecurityLabel.Builder builder = Contract.Term.SecurityLabel.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, numberElementIndex = 0, categoryElementIndex = 0, controlElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "number":
                    position = checkElementOrder("number", 2, position, true);
                    builder.number((UnsignedInt) parseInteger(UnsignedInt.builder(), "number", reader, numberElementIndex++));
                    break;
                case "classification":
                    position = checkElementOrder("classification", 3, position, false);
                    builder.classification(parseCoding("classification", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 4, position, true);
                    builder.category(parseCoding("category", reader, categoryElementIndex++));
                    break;
                case "control":
                    position = checkElementOrder("control", 5, position, true);
                    builder.control(parseCoding("control", reader, controlElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Contributor parseContributor(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Contributor.Builder builder = Contributor.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, contactElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 1, position, false);
                    builder.type((ContributorType) parseString(ContributorType.builder(), "type", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 3, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Coverage parseCoverage(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Coverage.Builder builder = Coverage.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, payorElementIndex = 0, classElementIndex = 0, costToBeneficiaryElementIndex = 0, contractElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((CoverageStatus) parseString(CoverageStatus.builder(), "status", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 10, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "policyHolder":
                    position = checkElementOrder("policyHolder", 11, position, false);
                    builder.policyHolder(parseReference("policyHolder", reader, -1));
                    break;
                case "subscriber":
                    position = checkElementOrder("subscriber", 12, position, false);
                    builder.subscriber(parseReference("subscriber", reader, -1));
                    break;
                case "subscriberId":
                    position = checkElementOrder("subscriberId", 13, position, false);
                    builder.subscriberId(parseString("subscriberId", reader, -1));
                    break;
                case "beneficiary":
                    position = checkElementOrder("beneficiary", 14, position, false);
                    builder.beneficiary(parseReference("beneficiary", reader, -1));
                    break;
                case "dependent":
                    position = checkElementOrder("dependent", 15, position, false);
                    builder.dependent(parseString("dependent", reader, -1));
                    break;
                case "relationship":
                    position = checkElementOrder("relationship", 16, position, false);
                    builder.relationship(parseCodeableConcept("relationship", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 17, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                case "payor":
                    position = checkElementOrder("payor", 18, position, true);
                    builder.payor(parseReference("payor", reader, payorElementIndex++));
                    break;
                case "class":
                    position = checkElementOrder("class", 19, position, true);
                    builder.clazz(parseCoverageClass("class", reader, classElementIndex++));
                    break;
                case "order":
                    position = checkElementOrder("order", 20, position, false);
                    builder.order((PositiveInt) parseInteger(PositiveInt.builder(), "order", reader, -1));
                    break;
                case "network":
                    position = checkElementOrder("network", 21, position, false);
                    builder.network(parseString("network", reader, -1));
                    break;
                case "costToBeneficiary":
                    position = checkElementOrder("costToBeneficiary", 22, position, true);
                    builder.costToBeneficiary(parseCoverageCostToBeneficiary("costToBeneficiary", reader, costToBeneficiaryElementIndex++));
                    break;
                case "subrogation":
                    position = checkElementOrder("subrogation", 23, position, false);
                    builder.subrogation(parseBoolean("subrogation", reader, -1));
                    break;
                case "contract":
                    position = checkElementOrder("contract", 24, position, true);
                    builder.contract(parseReference("contract", reader, contractElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Coverage.Class parseCoverageClass(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Coverage.Class.Builder builder = Coverage.Class.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "value":
                    position = checkElementOrder("value", 3, position, false);
                    builder.value(parseString("value", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 4, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Coverage.CostToBeneficiary parseCoverageCostToBeneficiary(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Coverage.CostToBeneficiary.Builder builder = Coverage.CostToBeneficiary.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, exceptionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "valueQuantity", reader, -1));
                    break;
                case "valueMoney":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseMoney("valueMoney", reader, -1));
                    break;
                case "exception":
                    position = checkElementOrder("exception", 4, position, true);
                    builder.exception(parseCoverageCostToBeneficiaryException("exception", reader, exceptionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Coverage.CostToBeneficiary.Exception parseCoverageCostToBeneficiaryException(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Coverage.CostToBeneficiary.Exception.Builder builder = Coverage.CostToBeneficiary.Exception.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 3, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CoverageEligibilityRequest parseCoverageEligibilityRequest(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CoverageEligibilityRequest.Builder builder = CoverageEligibilityRequest.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, purposeElementIndex = 0, supportingInfoElementIndex = 0, insuranceElementIndex = 0, itemElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((EligibilityRequestStatus) parseString(EligibilityRequestStatus.builder(), "status", reader, -1));
                    break;
                case "priority":
                    position = checkElementOrder("priority", 10, position, false);
                    builder.priority(parseCodeableConcept("priority", reader, -1));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 11, position, true);
                    builder.purpose((EligibilityRequestPurpose) parseString(EligibilityRequestPurpose.builder(), "purpose", reader, purposeElementIndex++));
                    break;
                case "patient":
                    position = checkElementOrder("patient", 12, position, false);
                    builder.patient(parseReference("patient", reader, -1));
                    break;
                case "servicedDate":
                    position = checkElementOrder("serviced[x]", 13, position, false);
                    builder.serviced(parseDate("servicedDate", reader, -1));
                    break;
                case "servicedPeriod":
                    position = checkElementOrder("serviced[x]", 13, position, false);
                    builder.serviced(parsePeriod("servicedPeriod", reader, -1));
                    break;
                case "created":
                    position = checkElementOrder("created", 14, position, false);
                    builder.created(parseDateTime("created", reader, -1));
                    break;
                case "enterer":
                    position = checkElementOrder("enterer", 15, position, false);
                    builder.enterer(parseReference("enterer", reader, -1));
                    break;
                case "provider":
                    position = checkElementOrder("provider", 16, position, false);
                    builder.provider(parseReference("provider", reader, -1));
                    break;
                case "insurer":
                    position = checkElementOrder("insurer", 17, position, false);
                    builder.insurer(parseReference("insurer", reader, -1));
                    break;
                case "facility":
                    position = checkElementOrder("facility", 18, position, false);
                    builder.facility(parseReference("facility", reader, -1));
                    break;
                case "supportingInfo":
                    position = checkElementOrder("supportingInfo", 19, position, true);
                    builder.supportingInfo(parseCoverageEligibilityRequestSupportingInfo("supportingInfo", reader, supportingInfoElementIndex++));
                    break;
                case "insurance":
                    position = checkElementOrder("insurance", 20, position, true);
                    builder.insurance(parseCoverageEligibilityRequestInsurance("insurance", reader, insuranceElementIndex++));
                    break;
                case "item":
                    position = checkElementOrder("item", 21, position, true);
                    builder.item(parseCoverageEligibilityRequestItem("item", reader, itemElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CoverageEligibilityRequest.Insurance parseCoverageEligibilityRequestInsurance(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CoverageEligibilityRequest.Insurance.Builder builder = CoverageEligibilityRequest.Insurance.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "focal":
                    position = checkElementOrder("focal", 2, position, false);
                    builder.focal(parseBoolean("focal", reader, -1));
                    break;
                case "coverage":
                    position = checkElementOrder("coverage", 3, position, false);
                    builder.coverage(parseReference("coverage", reader, -1));
                    break;
                case "businessArrangement":
                    position = checkElementOrder("businessArrangement", 4, position, false);
                    builder.businessArrangement(parseString("businessArrangement", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CoverageEligibilityRequest.Item parseCoverageEligibilityRequestItem(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CoverageEligibilityRequest.Item.Builder builder = CoverageEligibilityRequest.Item.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, supportingInfoSequenceElementIndex = 0, modifierElementIndex = 0, diagnosisElementIndex = 0, detailElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "supportingInfoSequence":
                    position = checkElementOrder("supportingInfoSequence", 2, position, true);
                    builder.supportingInfoSequence((PositiveInt) parseInteger(PositiveInt.builder(), "supportingInfoSequence", reader, supportingInfoSequenceElementIndex++));
                    break;
                case "category":
                    position = checkElementOrder("category", 3, position, false);
                    builder.category(parseCodeableConcept("category", reader, -1));
                    break;
                case "productOrService":
                    position = checkElementOrder("productOrService", 4, position, false);
                    builder.productOrService(parseCodeableConcept("productOrService", reader, -1));
                    break;
                case "modifier":
                    position = checkElementOrder("modifier", 5, position, true);
                    builder.modifier(parseCodeableConcept("modifier", reader, modifierElementIndex++));
                    break;
                case "provider":
                    position = checkElementOrder("provider", 6, position, false);
                    builder.provider(parseReference("provider", reader, -1));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 7, position, false);
                    builder.quantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "quantity", reader, -1));
                    break;
                case "unitPrice":
                    position = checkElementOrder("unitPrice", 8, position, false);
                    builder.unitPrice(parseMoney("unitPrice", reader, -1));
                    break;
                case "facility":
                    position = checkElementOrder("facility", 9, position, false);
                    builder.facility(parseReference("facility", reader, -1));
                    break;
                case "diagnosis":
                    position = checkElementOrder("diagnosis", 10, position, true);
                    builder.diagnosis(parseCoverageEligibilityRequestItemDiagnosis("diagnosis", reader, diagnosisElementIndex++));
                    break;
                case "detail":
                    position = checkElementOrder("detail", 11, position, true);
                    builder.detail(parseReference("detail", reader, detailElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CoverageEligibilityRequest.Item.Diagnosis parseCoverageEligibilityRequestItemDiagnosis(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CoverageEligibilityRequest.Item.Diagnosis.Builder builder = CoverageEligibilityRequest.Item.Diagnosis.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "diagnosisCodeableConcept":
                    position = checkElementOrder("diagnosis[x]", 2, position, false);
                    builder.diagnosis(parseCodeableConcept("diagnosisCodeableConcept", reader, -1));
                    break;
                case "diagnosisReference":
                    position = checkElementOrder("diagnosis[x]", 2, position, false);
                    builder.diagnosis(parseReference("diagnosisReference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CoverageEligibilityRequest.SupportingInfo parseCoverageEligibilityRequestSupportingInfo(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CoverageEligibilityRequest.SupportingInfo.Builder builder = CoverageEligibilityRequest.SupportingInfo.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "sequence":
                    position = checkElementOrder("sequence", 2, position, false);
                    builder.sequence((PositiveInt) parseInteger(PositiveInt.builder(), "sequence", reader, -1));
                    break;
                case "information":
                    position = checkElementOrder("information", 3, position, false);
                    builder.information(parseReference("information", reader, -1));
                    break;
                case "appliesToAll":
                    position = checkElementOrder("appliesToAll", 4, position, false);
                    builder.appliesToAll(parseBoolean("appliesToAll", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CoverageEligibilityResponse parseCoverageEligibilityResponse(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CoverageEligibilityResponse.Builder builder = CoverageEligibilityResponse.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, purposeElementIndex = 0, insuranceElementIndex = 0, errorElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((EligibilityResponseStatus) parseString(EligibilityResponseStatus.builder(), "status", reader, -1));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 10, position, true);
                    builder.purpose((EligibilityResponsePurpose) parseString(EligibilityResponsePurpose.builder(), "purpose", reader, purposeElementIndex++));
                    break;
                case "patient":
                    position = checkElementOrder("patient", 11, position, false);
                    builder.patient(parseReference("patient", reader, -1));
                    break;
                case "servicedDate":
                    position = checkElementOrder("serviced[x]", 12, position, false);
                    builder.serviced(parseDate("servicedDate", reader, -1));
                    break;
                case "servicedPeriod":
                    position = checkElementOrder("serviced[x]", 12, position, false);
                    builder.serviced(parsePeriod("servicedPeriod", reader, -1));
                    break;
                case "created":
                    position = checkElementOrder("created", 13, position, false);
                    builder.created(parseDateTime("created", reader, -1));
                    break;
                case "requestor":
                    position = checkElementOrder("requestor", 14, position, false);
                    builder.requestor(parseReference("requestor", reader, -1));
                    break;
                case "request":
                    position = checkElementOrder("request", 15, position, false);
                    builder.request(parseReference("request", reader, -1));
                    break;
                case "outcome":
                    position = checkElementOrder("outcome", 16, position, false);
                    builder.outcome((RemittanceOutcome) parseString(RemittanceOutcome.builder(), "outcome", reader, -1));
                    break;
                case "disposition":
                    position = checkElementOrder("disposition", 17, position, false);
                    builder.disposition(parseString("disposition", reader, -1));
                    break;
                case "insurer":
                    position = checkElementOrder("insurer", 18, position, false);
                    builder.insurer(parseReference("insurer", reader, -1));
                    break;
                case "insurance":
                    position = checkElementOrder("insurance", 19, position, true);
                    builder.insurance(parseCoverageEligibilityResponseInsurance("insurance", reader, insuranceElementIndex++));
                    break;
                case "preAuthRef":
                    position = checkElementOrder("preAuthRef", 20, position, false);
                    builder.preAuthRef(parseString("preAuthRef", reader, -1));
                    break;
                case "form":
                    position = checkElementOrder("form", 21, position, false);
                    builder.form(parseCodeableConcept("form", reader, -1));
                    break;
                case "error":
                    position = checkElementOrder("error", 22, position, true);
                    builder.error(parseCoverageEligibilityResponseError("error", reader, errorElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CoverageEligibilityResponse.Error parseCoverageEligibilityResponseError(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CoverageEligibilityResponse.Error.Builder builder = CoverageEligibilityResponse.Error.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CoverageEligibilityResponse.Insurance parseCoverageEligibilityResponseInsurance(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CoverageEligibilityResponse.Insurance.Builder builder = CoverageEligibilityResponse.Insurance.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, itemElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "coverage":
                    position = checkElementOrder("coverage", 2, position, false);
                    builder.coverage(parseReference("coverage", reader, -1));
                    break;
                case "inforce":
                    position = checkElementOrder("inforce", 3, position, false);
                    builder.inforce(parseBoolean("inforce", reader, -1));
                    break;
                case "benefitPeriod":
                    position = checkElementOrder("benefitPeriod", 4, position, false);
                    builder.benefitPeriod(parsePeriod("benefitPeriod", reader, -1));
                    break;
                case "item":
                    position = checkElementOrder("item", 5, position, true);
                    builder.item(parseCoverageEligibilityResponseInsuranceItem("item", reader, itemElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CoverageEligibilityResponse.Insurance.Item parseCoverageEligibilityResponseInsuranceItem(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CoverageEligibilityResponse.Insurance.Item.Builder builder = CoverageEligibilityResponse.Insurance.Item.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, modifierElementIndex = 0, benefitElementIndex = 0, authorizationSupportingElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "category":
                    position = checkElementOrder("category", 2, position, false);
                    builder.category(parseCodeableConcept("category", reader, -1));
                    break;
                case "productOrService":
                    position = checkElementOrder("productOrService", 3, position, false);
                    builder.productOrService(parseCodeableConcept("productOrService", reader, -1));
                    break;
                case "modifier":
                    position = checkElementOrder("modifier", 4, position, true);
                    builder.modifier(parseCodeableConcept("modifier", reader, modifierElementIndex++));
                    break;
                case "provider":
                    position = checkElementOrder("provider", 5, position, false);
                    builder.provider(parseReference("provider", reader, -1));
                    break;
                case "excluded":
                    position = checkElementOrder("excluded", 6, position, false);
                    builder.excluded(parseBoolean("excluded", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 7, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 8, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "network":
                    position = checkElementOrder("network", 9, position, false);
                    builder.network(parseCodeableConcept("network", reader, -1));
                    break;
                case "unit":
                    position = checkElementOrder("unit", 10, position, false);
                    builder.unit(parseCodeableConcept("unit", reader, -1));
                    break;
                case "term":
                    position = checkElementOrder("term", 11, position, false);
                    builder.term(parseCodeableConcept("term", reader, -1));
                    break;
                case "benefit":
                    position = checkElementOrder("benefit", 12, position, true);
                    builder.benefit(parseCoverageEligibilityResponseInsuranceItemBenefit("benefit", reader, benefitElementIndex++));
                    break;
                case "authorizationRequired":
                    position = checkElementOrder("authorizationRequired", 13, position, false);
                    builder.authorizationRequired(parseBoolean("authorizationRequired", reader, -1));
                    break;
                case "authorizationSupporting":
                    position = checkElementOrder("authorizationSupporting", 14, position, true);
                    builder.authorizationSupporting(parseCodeableConcept("authorizationSupporting", reader, authorizationSupportingElementIndex++));
                    break;
                case "authorizationUrl":
                    position = checkElementOrder("authorizationUrl", 15, position, false);
                    builder.authorizationUrl(parseUri("authorizationUrl", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private CoverageEligibilityResponse.Insurance.Item.Benefit parseCoverageEligibilityResponseInsuranceItemBenefit(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        CoverageEligibilityResponse.Insurance.Item.Benefit.Builder builder = CoverageEligibilityResponse.Insurance.Item.Benefit.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "allowedUnsignedInt":
                    position = checkElementOrder("allowed[x]", 3, position, false);
                    builder.allowed((UnsignedInt) parseInteger(UnsignedInt.builder(), "allowedUnsignedInt", reader, -1));
                    break;
                case "allowedString":
                    position = checkElementOrder("allowed[x]", 3, position, false);
                    builder.allowed(parseString("allowedString", reader, -1));
                    break;
                case "allowedMoney":
                    position = checkElementOrder("allowed[x]", 3, position, false);
                    builder.allowed(parseMoney("allowedMoney", reader, -1));
                    break;
                case "usedUnsignedInt":
                    position = checkElementOrder("used[x]", 4, position, false);
                    builder.used((UnsignedInt) parseInteger(UnsignedInt.builder(), "usedUnsignedInt", reader, -1));
                    break;
                case "usedString":
                    position = checkElementOrder("used[x]", 4, position, false);
                    builder.used(parseString("usedString", reader, -1));
                    break;
                case "usedMoney":
                    position = checkElementOrder("used[x]", 4, position, false);
                    builder.used(parseMoney("usedMoney", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DataRequirement parseDataRequirement(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DataRequirement.Builder builder = DataRequirement.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, profileElementIndex = 0, mustSupportElementIndex = 0, codeFilterElementIndex = 0, dateFilterElementIndex = 0, sortElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 1, position, false);
                    builder.type((FHIRAllTypes) parseString(FHIRAllTypes.builder(), "type", reader, -1));
                    break;
                case "profile":
                    position = checkElementOrder("profile", 2, position, true);
                    builder.profile((Canonical) parseUri(Canonical.builder(), "profile", reader, profileElementIndex++));
                    break;
                case "subjectCodeableConcept":
                    position = checkElementOrder("subject[x]", 3, position, false);
                    builder.subject(parseCodeableConcept("subjectCodeableConcept", reader, -1));
                    break;
                case "subjectReference":
                    position = checkElementOrder("subject[x]", 3, position, false);
                    builder.subject(parseReference("subjectReference", reader, -1));
                    break;
                case "mustSupport":
                    position = checkElementOrder("mustSupport", 4, position, true);
                    builder.mustSupport(parseString("mustSupport", reader, mustSupportElementIndex++));
                    break;
                case "codeFilter":
                    position = checkElementOrder("codeFilter", 5, position, true);
                    builder.codeFilter(parseDataRequirementCodeFilter("codeFilter", reader, codeFilterElementIndex++));
                    break;
                case "dateFilter":
                    position = checkElementOrder("dateFilter", 6, position, true);
                    builder.dateFilter(parseDataRequirementDateFilter("dateFilter", reader, dateFilterElementIndex++));
                    break;
                case "limit":
                    position = checkElementOrder("limit", 7, position, false);
                    builder.limit((PositiveInt) parseInteger(PositiveInt.builder(), "limit", reader, -1));
                    break;
                case "sort":
                    position = checkElementOrder("sort", 8, position, true);
                    builder.sort(parseDataRequirementSort("sort", reader, sortElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DataRequirement.CodeFilter parseDataRequirementCodeFilter(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DataRequirement.CodeFilter.Builder builder = DataRequirement.CodeFilter.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, codeElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "path":
                    position = checkElementOrder("path", 2, position, false);
                    builder.path(parseString("path", reader, -1));
                    break;
                case "searchParam":
                    position = checkElementOrder("searchParam", 3, position, false);
                    builder.searchParam(parseString("searchParam", reader, -1));
                    break;
                case "valueSet":
                    position = checkElementOrder("valueSet", 4, position, false);
                    builder.valueSet((Canonical) parseUri(Canonical.builder(), "valueSet", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 5, position, true);
                    builder.code(parseCoding("code", reader, codeElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DataRequirement.DateFilter parseDataRequirementDateFilter(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DataRequirement.DateFilter.Builder builder = DataRequirement.DateFilter.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "path":
                    position = checkElementOrder("path", 2, position, false);
                    builder.path(parseString("path", reader, -1));
                    break;
                case "searchParam":
                    position = checkElementOrder("searchParam", 3, position, false);
                    builder.searchParam(parseString("searchParam", reader, -1));
                    break;
                case "valueDateTime":
                    position = checkElementOrder("value[x]", 4, position, false);
                    builder.value(parseDateTime("valueDateTime", reader, -1));
                    break;
                case "valuePeriod":
                    position = checkElementOrder("value[x]", 4, position, false);
                    builder.value(parsePeriod("valuePeriod", reader, -1));
                    break;
                case "valueDuration":
                    position = checkElementOrder("value[x]", 4, position, false);
                    builder.value((Duration) parseQuantity(Duration.builder(), "valueDuration", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DataRequirement.Sort parseDataRequirementSort(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DataRequirement.Sort.Builder builder = DataRequirement.Sort.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "path":
                    position = checkElementOrder("path", 2, position, false);
                    builder.path(parseString("path", reader, -1));
                    break;
                case "direction":
                    position = checkElementOrder("direction", 3, position, false);
                    builder.direction((SortDirection) parseString(SortDirection.builder(), "direction", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Date parseDate(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Date.Builder builder = Date.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        java.lang.String value = reader.getAttributeValue(null, "value");
        if (value != null) {
            builder.value(value);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DateTime parseDateTime(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DateTime.Builder builder = DateTime.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        java.lang.String value = reader.getAttributeValue(null, "value");
        if (value != null) {
            builder.value(value);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Decimal parseDecimal(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Decimal.Builder builder = Decimal.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        java.lang.String value = reader.getAttributeValue(null, "value");
        if (value != null) {
            builder.value(value);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DetectedIssue parseDetectedIssue(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DetectedIssue.Builder builder = DetectedIssue.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, implicatedElementIndex = 0, evidenceElementIndex = 0, mitigationElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((DetectedIssueStatus) parseString(DetectedIssueStatus.builder(), "status", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 10, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "severity":
                    position = checkElementOrder("severity", 11, position, false);
                    builder.severity((DetectedIssueSeverity) parseString(DetectedIssueSeverity.builder(), "severity", reader, -1));
                    break;
                case "patient":
                    position = checkElementOrder("patient", 12, position, false);
                    builder.patient(parseReference("patient", reader, -1));
                    break;
                case "identifiedDateTime":
                    position = checkElementOrder("identified[x]", 13, position, false);
                    builder.identified(parseDateTime("identifiedDateTime", reader, -1));
                    break;
                case "identifiedPeriod":
                    position = checkElementOrder("identified[x]", 13, position, false);
                    builder.identified(parsePeriod("identifiedPeriod", reader, -1));
                    break;
                case "author":
                    position = checkElementOrder("author", 14, position, false);
                    builder.author(parseReference("author", reader, -1));
                    break;
                case "implicated":
                    position = checkElementOrder("implicated", 15, position, true);
                    builder.implicated(parseReference("implicated", reader, implicatedElementIndex++));
                    break;
                case "evidence":
                    position = checkElementOrder("evidence", 16, position, true);
                    builder.evidence(parseDetectedIssueEvidence("evidence", reader, evidenceElementIndex++));
                    break;
                case "detail":
                    position = checkElementOrder("detail", 17, position, false);
                    builder.detail(parseString("detail", reader, -1));
                    break;
                case "reference":
                    position = checkElementOrder("reference", 18, position, false);
                    builder.reference(parseUri("reference", reader, -1));
                    break;
                case "mitigation":
                    position = checkElementOrder("mitigation", 19, position, true);
                    builder.mitigation(parseDetectedIssueMitigation("mitigation", reader, mitigationElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DetectedIssue.Evidence parseDetectedIssueEvidence(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DetectedIssue.Evidence.Builder builder = DetectedIssue.Evidence.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, codeElementIndex = 0, detailElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, true);
                    builder.code(parseCodeableConcept("code", reader, codeElementIndex++));
                    break;
                case "detail":
                    position = checkElementOrder("detail", 3, position, true);
                    builder.detail(parseReference("detail", reader, detailElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DetectedIssue.Mitigation parseDetectedIssueMitigation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DetectedIssue.Mitigation.Builder builder = DetectedIssue.Mitigation.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "action":
                    position = checkElementOrder("action", 2, position, false);
                    builder.action(parseCodeableConcept("action", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 3, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "author":
                    position = checkElementOrder("author", 4, position, false);
                    builder.author(parseReference("author", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Device parseDevice(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Device.Builder builder = Device.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, udiCarrierElementIndex = 0, statusReasonElementIndex = 0, deviceNameElementIndex = 0, specializationElementIndex = 0, versionElementIndex = 0, propertyElementIndex = 0, contactElementIndex = 0, noteElementIndex = 0, safetyElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "definition":
                    position = checkElementOrder("definition", 9, position, false);
                    builder.definition(parseReference("definition", reader, -1));
                    break;
                case "udiCarrier":
                    position = checkElementOrder("udiCarrier", 10, position, true);
                    builder.udiCarrier(parseDeviceUdiCarrier("udiCarrier", reader, udiCarrierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 11, position, false);
                    builder.status((FHIRDeviceStatus) parseString(FHIRDeviceStatus.builder(), "status", reader, -1));
                    break;
                case "statusReason":
                    position = checkElementOrder("statusReason", 12, position, true);
                    builder.statusReason(parseCodeableConcept("statusReason", reader, statusReasonElementIndex++));
                    break;
                case "distinctIdentifier":
                    position = checkElementOrder("distinctIdentifier", 13, position, false);
                    builder.distinctIdentifier(parseString("distinctIdentifier", reader, -1));
                    break;
                case "manufacturer":
                    position = checkElementOrder("manufacturer", 14, position, false);
                    builder.manufacturer(parseString("manufacturer", reader, -1));
                    break;
                case "manufactureDate":
                    position = checkElementOrder("manufactureDate", 15, position, false);
                    builder.manufactureDate(parseDateTime("manufactureDate", reader, -1));
                    break;
                case "expirationDate":
                    position = checkElementOrder("expirationDate", 16, position, false);
                    builder.expirationDate(parseDateTime("expirationDate", reader, -1));
                    break;
                case "lotNumber":
                    position = checkElementOrder("lotNumber", 17, position, false);
                    builder.lotNumber(parseString("lotNumber", reader, -1));
                    break;
                case "serialNumber":
                    position = checkElementOrder("serialNumber", 18, position, false);
                    builder.serialNumber(parseString("serialNumber", reader, -1));
                    break;
                case "deviceName":
                    position = checkElementOrder("deviceName", 19, position, true);
                    builder.deviceName(parseDeviceDeviceName("deviceName", reader, deviceNameElementIndex++));
                    break;
                case "modelNumber":
                    position = checkElementOrder("modelNumber", 20, position, false);
                    builder.modelNumber(parseString("modelNumber", reader, -1));
                    break;
                case "partNumber":
                    position = checkElementOrder("partNumber", 21, position, false);
                    builder.partNumber(parseString("partNumber", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 22, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "specialization":
                    position = checkElementOrder("specialization", 23, position, true);
                    builder.specialization(parseDeviceSpecialization("specialization", reader, specializationElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 24, position, true);
                    builder.version(parseDeviceVersion("version", reader, versionElementIndex++));
                    break;
                case "property":
                    position = checkElementOrder("property", 25, position, true);
                    builder.property(parseDeviceProperty("property", reader, propertyElementIndex++));
                    break;
                case "patient":
                    position = checkElementOrder("patient", 26, position, false);
                    builder.patient(parseReference("patient", reader, -1));
                    break;
                case "owner":
                    position = checkElementOrder("owner", 27, position, false);
                    builder.owner(parseReference("owner", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 28, position, true);
                    builder.contact(parseContactPoint("contact", reader, contactElementIndex++));
                    break;
                case "location":
                    position = checkElementOrder("location", 29, position, false);
                    builder.location(parseReference("location", reader, -1));
                    break;
                case "url":
                    position = checkElementOrder("url", 30, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "note":
                    position = checkElementOrder("note", 31, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "safety":
                    position = checkElementOrder("safety", 32, position, true);
                    builder.safety(parseCodeableConcept("safety", reader, safetyElementIndex++));
                    break;
                case "parent":
                    position = checkElementOrder("parent", 33, position, false);
                    builder.parent(parseReference("parent", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Device.DeviceName parseDeviceDeviceName(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Device.DeviceName.Builder builder = Device.DeviceName.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type((DeviceNameType) parseString(DeviceNameType.builder(), "type", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Device.Property parseDeviceProperty(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Device.Property.Builder builder = Device.Property.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, valueQuantityElementIndex = 0, valueCodeElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("valueQuantity", 3, position, true);
                    builder.valueQuantity(parseQuantity("valueQuantity", reader, valueQuantityElementIndex++));
                    break;
                case "valueCode":
                    position = checkElementOrder("valueCode", 4, position, true);
                    builder.valueCode(parseCodeableConcept("valueCode", reader, valueCodeElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Device.Specialization parseDeviceSpecialization(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Device.Specialization.Builder builder = Device.Specialization.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "systemType":
                    position = checkElementOrder("systemType", 2, position, false);
                    builder.systemType(parseCodeableConcept("systemType", reader, -1));
                    break;
                case "version":
                    position = checkElementOrder("version", 3, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Device.UdiCarrier parseDeviceUdiCarrier(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Device.UdiCarrier.Builder builder = Device.UdiCarrier.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "deviceIdentifier":
                    position = checkElementOrder("deviceIdentifier", 2, position, false);
                    builder.deviceIdentifier(parseString("deviceIdentifier", reader, -1));
                    break;
                case "issuer":
                    position = checkElementOrder("issuer", 3, position, false);
                    builder.issuer(parseUri("issuer", reader, -1));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 4, position, false);
                    builder.jurisdiction(parseUri("jurisdiction", reader, -1));
                    break;
                case "carrierAIDC":
                    position = checkElementOrder("carrierAIDC", 5, position, false);
                    builder.carrierAIDC(parseBase64Binary("carrierAIDC", reader, -1));
                    break;
                case "carrierHRF":
                    position = checkElementOrder("carrierHRF", 6, position, false);
                    builder.carrierHRF(parseString("carrierHRF", reader, -1));
                    break;
                case "entryType":
                    position = checkElementOrder("entryType", 7, position, false);
                    builder.entryType((UDIEntryType) parseString(UDIEntryType.builder(), "entryType", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Device.Version parseDeviceVersion(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Device.Version.Builder builder = Device.Version.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "component":
                    position = checkElementOrder("component", 3, position, false);
                    builder.component(parseIdentifier("component", reader, -1));
                    break;
                case "value":
                    position = checkElementOrder("value", 4, position, false);
                    builder.value(parseString("value", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DeviceDefinition parseDeviceDefinition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DeviceDefinition.Builder builder = DeviceDefinition.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, udiDeviceIdentifierElementIndex = 0, deviceNameElementIndex = 0, specializationElementIndex = 0, versionElementIndex = 0, safetyElementIndex = 0, shelfLifeStorageElementIndex = 0, languageCodeElementIndex = 0, capabilityElementIndex = 0, propertyElementIndex = 0, contactElementIndex = 0, noteElementIndex = 0, materialElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "udiDeviceIdentifier":
                    position = checkElementOrder("udiDeviceIdentifier", 9, position, true);
                    builder.udiDeviceIdentifier(parseDeviceDefinitionUdiDeviceIdentifier("udiDeviceIdentifier", reader, udiDeviceIdentifierElementIndex++));
                    break;
                case "manufacturerString":
                    position = checkElementOrder("manufacturer[x]", 10, position, false);
                    builder.manufacturer(parseString("manufacturerString", reader, -1));
                    break;
                case "manufacturerReference":
                    position = checkElementOrder("manufacturer[x]", 10, position, false);
                    builder.manufacturer(parseReference("manufacturerReference", reader, -1));
                    break;
                case "deviceName":
                    position = checkElementOrder("deviceName", 11, position, true);
                    builder.deviceName(parseDeviceDefinitionDeviceName("deviceName", reader, deviceNameElementIndex++));
                    break;
                case "modelNumber":
                    position = checkElementOrder("modelNumber", 12, position, false);
                    builder.modelNumber(parseString("modelNumber", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 13, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "specialization":
                    position = checkElementOrder("specialization", 14, position, true);
                    builder.specialization(parseDeviceDefinitionSpecialization("specialization", reader, specializationElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 15, position, true);
                    builder.version(parseString("version", reader, versionElementIndex++));
                    break;
                case "safety":
                    position = checkElementOrder("safety", 16, position, true);
                    builder.safety(parseCodeableConcept("safety", reader, safetyElementIndex++));
                    break;
                case "shelfLifeStorage":
                    position = checkElementOrder("shelfLifeStorage", 17, position, true);
                    builder.shelfLifeStorage(parseProductShelfLife("shelfLifeStorage", reader, shelfLifeStorageElementIndex++));
                    break;
                case "physicalCharacteristics":
                    position = checkElementOrder("physicalCharacteristics", 18, position, false);
                    builder.physicalCharacteristics(parseProdCharacteristic("physicalCharacteristics", reader, -1));
                    break;
                case "languageCode":
                    position = checkElementOrder("languageCode", 19, position, true);
                    builder.languageCode(parseCodeableConcept("languageCode", reader, languageCodeElementIndex++));
                    break;
                case "capability":
                    position = checkElementOrder("capability", 20, position, true);
                    builder.capability(parseDeviceDefinitionCapability("capability", reader, capabilityElementIndex++));
                    break;
                case "property":
                    position = checkElementOrder("property", 21, position, true);
                    builder.property(parseDeviceDefinitionProperty("property", reader, propertyElementIndex++));
                    break;
                case "owner":
                    position = checkElementOrder("owner", 22, position, false);
                    builder.owner(parseReference("owner", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 23, position, true);
                    builder.contact(parseContactPoint("contact", reader, contactElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 24, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "onlineInformation":
                    position = checkElementOrder("onlineInformation", 25, position, false);
                    builder.onlineInformation(parseUri("onlineInformation", reader, -1));
                    break;
                case "note":
                    position = checkElementOrder("note", 26, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 27, position, false);
                    builder.quantity(parseQuantity("quantity", reader, -1));
                    break;
                case "parentDevice":
                    position = checkElementOrder("parentDevice", 28, position, false);
                    builder.parentDevice(parseReference("parentDevice", reader, -1));
                    break;
                case "material":
                    position = checkElementOrder("material", 29, position, true);
                    builder.material(parseDeviceDefinitionMaterial("material", reader, materialElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DeviceDefinition.Capability parseDeviceDefinitionCapability(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DeviceDefinition.Capability.Builder builder = DeviceDefinition.Capability.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, descriptionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 3, position, true);
                    builder.description(parseCodeableConcept("description", reader, descriptionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DeviceDefinition.DeviceName parseDeviceDefinitionDeviceName(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DeviceDefinition.DeviceName.Builder builder = DeviceDefinition.DeviceName.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type((DeviceNameType) parseString(DeviceNameType.builder(), "type", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DeviceDefinition.Material parseDeviceDefinitionMaterial(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DeviceDefinition.Material.Builder builder = DeviceDefinition.Material.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "substance":
                    position = checkElementOrder("substance", 2, position, false);
                    builder.substance(parseCodeableConcept("substance", reader, -1));
                    break;
                case "alternate":
                    position = checkElementOrder("alternate", 3, position, false);
                    builder.alternate(parseBoolean("alternate", reader, -1));
                    break;
                case "allergenicIndicator":
                    position = checkElementOrder("allergenicIndicator", 4, position, false);
                    builder.allergenicIndicator(parseBoolean("allergenicIndicator", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DeviceDefinition.Property parseDeviceDefinitionProperty(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DeviceDefinition.Property.Builder builder = DeviceDefinition.Property.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, valueQuantityElementIndex = 0, valueCodeElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("valueQuantity", 3, position, true);
                    builder.valueQuantity(parseQuantity("valueQuantity", reader, valueQuantityElementIndex++));
                    break;
                case "valueCode":
                    position = checkElementOrder("valueCode", 4, position, true);
                    builder.valueCode(parseCodeableConcept("valueCode", reader, valueCodeElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DeviceDefinition.Specialization parseDeviceDefinitionSpecialization(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DeviceDefinition.Specialization.Builder builder = DeviceDefinition.Specialization.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "systemType":
                    position = checkElementOrder("systemType", 2, position, false);
                    builder.systemType(parseString("systemType", reader, -1));
                    break;
                case "version":
                    position = checkElementOrder("version", 3, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DeviceDefinition.UdiDeviceIdentifier parseDeviceDefinitionUdiDeviceIdentifier(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DeviceDefinition.UdiDeviceIdentifier.Builder builder = DeviceDefinition.UdiDeviceIdentifier.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "deviceIdentifier":
                    position = checkElementOrder("deviceIdentifier", 2, position, false);
                    builder.deviceIdentifier(parseString("deviceIdentifier", reader, -1));
                    break;
                case "issuer":
                    position = checkElementOrder("issuer", 3, position, false);
                    builder.issuer(parseUri("issuer", reader, -1));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 4, position, false);
                    builder.jurisdiction(parseUri("jurisdiction", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DeviceMetric parseDeviceMetric(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DeviceMetric.Builder builder = DeviceMetric.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, calibrationElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 9, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "unit":
                    position = checkElementOrder("unit", 10, position, false);
                    builder.unit(parseCodeableConcept("unit", reader, -1));
                    break;
                case "source":
                    position = checkElementOrder("source", 11, position, false);
                    builder.source(parseReference("source", reader, -1));
                    break;
                case "parent":
                    position = checkElementOrder("parent", 12, position, false);
                    builder.parent(parseReference("parent", reader, -1));
                    break;
                case "operationalStatus":
                    position = checkElementOrder("operationalStatus", 13, position, false);
                    builder.operationalStatus((DeviceMetricOperationalStatus) parseString(DeviceMetricOperationalStatus.builder(), "operationalStatus", reader, -1));
                    break;
                case "color":
                    position = checkElementOrder("color", 14, position, false);
                    builder.color((DeviceMetricColor) parseString(DeviceMetricColor.builder(), "color", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 15, position, false);
                    builder.category((DeviceMetricCategory) parseString(DeviceMetricCategory.builder(), "category", reader, -1));
                    break;
                case "measurementPeriod":
                    position = checkElementOrder("measurementPeriod", 16, position, false);
                    builder.measurementPeriod(parseTiming("measurementPeriod", reader, -1));
                    break;
                case "calibration":
                    position = checkElementOrder("calibration", 17, position, true);
                    builder.calibration(parseDeviceMetricCalibration("calibration", reader, calibrationElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DeviceMetric.Calibration parseDeviceMetricCalibration(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DeviceMetric.Calibration.Builder builder = DeviceMetric.Calibration.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type((DeviceMetricCalibrationType) parseString(DeviceMetricCalibrationType.builder(), "type", reader, -1));
                    break;
                case "state":
                    position = checkElementOrder("state", 3, position, false);
                    builder.state((DeviceMetricCalibrationState) parseString(DeviceMetricCalibrationState.builder(), "state", reader, -1));
                    break;
                case "time":
                    position = checkElementOrder("time", 4, position, false);
                    builder.time(parseInstant("time", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DeviceRequest parseDeviceRequest(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DeviceRequest.Builder builder = DeviceRequest.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, instantiatesCanonicalElementIndex = 0, instantiatesUriElementIndex = 0, basedOnElementIndex = 0, priorRequestElementIndex = 0, parameterElementIndex = 0, reasonCodeElementIndex = 0, reasonReferenceElementIndex = 0, insuranceElementIndex = 0, supportingInfoElementIndex = 0, noteElementIndex = 0, relevantHistoryElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "instantiatesCanonical":
                    position = checkElementOrder("instantiatesCanonical", 9, position, true);
                    builder.instantiatesCanonical((Canonical) parseUri(Canonical.builder(), "instantiatesCanonical", reader, instantiatesCanonicalElementIndex++));
                    break;
                case "instantiatesUri":
                    position = checkElementOrder("instantiatesUri", 10, position, true);
                    builder.instantiatesUri(parseUri("instantiatesUri", reader, instantiatesUriElementIndex++));
                    break;
                case "basedOn":
                    position = checkElementOrder("basedOn", 11, position, true);
                    builder.basedOn(parseReference("basedOn", reader, basedOnElementIndex++));
                    break;
                case "priorRequest":
                    position = checkElementOrder("priorRequest", 12, position, true);
                    builder.priorRequest(parseReference("priorRequest", reader, priorRequestElementIndex++));
                    break;
                case "groupIdentifier":
                    position = checkElementOrder("groupIdentifier", 13, position, false);
                    builder.groupIdentifier(parseIdentifier("groupIdentifier", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 14, position, false);
                    builder.status((DeviceRequestStatus) parseString(DeviceRequestStatus.builder(), "status", reader, -1));
                    break;
                case "intent":
                    position = checkElementOrder("intent", 15, position, false);
                    builder.intent((RequestIntent) parseString(RequestIntent.builder(), "intent", reader, -1));
                    break;
                case "priority":
                    position = checkElementOrder("priority", 16, position, false);
                    builder.priority((RequestPriority) parseString(RequestPriority.builder(), "priority", reader, -1));
                    break;
                case "codeReference":
                    position = checkElementOrder("code[x]", 17, position, false);
                    builder.code(parseReference("codeReference", reader, -1));
                    break;
                case "codeCodeableConcept":
                    position = checkElementOrder("code[x]", 17, position, false);
                    builder.code(parseCodeableConcept("codeCodeableConcept", reader, -1));
                    break;
                case "parameter":
                    position = checkElementOrder("parameter", 18, position, true);
                    builder.parameter(parseDeviceRequestParameter("parameter", reader, parameterElementIndex++));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 19, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 20, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "occurrenceDateTime":
                    position = checkElementOrder("occurrence[x]", 21, position, false);
                    builder.occurrence(parseDateTime("occurrenceDateTime", reader, -1));
                    break;
                case "occurrencePeriod":
                    position = checkElementOrder("occurrence[x]", 21, position, false);
                    builder.occurrence(parsePeriod("occurrencePeriod", reader, -1));
                    break;
                case "occurrenceTiming":
                    position = checkElementOrder("occurrence[x]", 21, position, false);
                    builder.occurrence(parseTiming("occurrenceTiming", reader, -1));
                    break;
                case "authoredOn":
                    position = checkElementOrder("authoredOn", 22, position, false);
                    builder.authoredOn(parseDateTime("authoredOn", reader, -1));
                    break;
                case "requester":
                    position = checkElementOrder("requester", 23, position, false);
                    builder.requester(parseReference("requester", reader, -1));
                    break;
                case "performerType":
                    position = checkElementOrder("performerType", 24, position, false);
                    builder.performerType(parseCodeableConcept("performerType", reader, -1));
                    break;
                case "performer":
                    position = checkElementOrder("performer", 25, position, false);
                    builder.performer(parseReference("performer", reader, -1));
                    break;
                case "reasonCode":
                    position = checkElementOrder("reasonCode", 26, position, true);
                    builder.reasonCode(parseCodeableConcept("reasonCode", reader, reasonCodeElementIndex++));
                    break;
                case "reasonReference":
                    position = checkElementOrder("reasonReference", 27, position, true);
                    builder.reasonReference(parseReference("reasonReference", reader, reasonReferenceElementIndex++));
                    break;
                case "insurance":
                    position = checkElementOrder("insurance", 28, position, true);
                    builder.insurance(parseReference("insurance", reader, insuranceElementIndex++));
                    break;
                case "supportingInfo":
                    position = checkElementOrder("supportingInfo", 29, position, true);
                    builder.supportingInfo(parseReference("supportingInfo", reader, supportingInfoElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 30, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "relevantHistory":
                    position = checkElementOrder("relevantHistory", 31, position, true);
                    builder.relevantHistory(parseReference("relevantHistory", reader, relevantHistoryElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DeviceRequest.Parameter parseDeviceRequestParameter(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DeviceRequest.Parameter.Builder builder = DeviceRequest.Parameter.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "valueCodeableConcept":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCodeableConcept("valueCodeableConcept", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueRange":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRange("valueRange", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DeviceUseStatement parseDeviceUseStatement(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DeviceUseStatement.Builder builder = DeviceUseStatement.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, basedOnElementIndex = 0, derivedFromElementIndex = 0, reasonCodeElementIndex = 0, reasonReferenceElementIndex = 0, noteElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "basedOn":
                    position = checkElementOrder("basedOn", 9, position, true);
                    builder.basedOn(parseReference("basedOn", reader, basedOnElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 10, position, false);
                    builder.status((DeviceUseStatementStatus) parseString(DeviceUseStatementStatus.builder(), "status", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 11, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "derivedFrom":
                    position = checkElementOrder("derivedFrom", 12, position, true);
                    builder.derivedFrom(parseReference("derivedFrom", reader, derivedFromElementIndex++));
                    break;
                case "timingTiming":
                    position = checkElementOrder("timing[x]", 13, position, false);
                    builder.timing(parseTiming("timingTiming", reader, -1));
                    break;
                case "timingPeriod":
                    position = checkElementOrder("timing[x]", 13, position, false);
                    builder.timing(parsePeriod("timingPeriod", reader, -1));
                    break;
                case "timingDateTime":
                    position = checkElementOrder("timing[x]", 13, position, false);
                    builder.timing(parseDateTime("timingDateTime", reader, -1));
                    break;
                case "recordedOn":
                    position = checkElementOrder("recordedOn", 14, position, false);
                    builder.recordedOn(parseDateTime("recordedOn", reader, -1));
                    break;
                case "source":
                    position = checkElementOrder("source", 15, position, false);
                    builder.source(parseReference("source", reader, -1));
                    break;
                case "device":
                    position = checkElementOrder("device", 16, position, false);
                    builder.device(parseReference("device", reader, -1));
                    break;
                case "reasonCode":
                    position = checkElementOrder("reasonCode", 17, position, true);
                    builder.reasonCode(parseCodeableConcept("reasonCode", reader, reasonCodeElementIndex++));
                    break;
                case "reasonReference":
                    position = checkElementOrder("reasonReference", 18, position, true);
                    builder.reasonReference(parseReference("reasonReference", reader, reasonReferenceElementIndex++));
                    break;
                case "bodySite":
                    position = checkElementOrder("bodySite", 19, position, false);
                    builder.bodySite(parseCodeableConcept("bodySite", reader, -1));
                    break;
                case "note":
                    position = checkElementOrder("note", 20, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DiagnosticReport parseDiagnosticReport(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DiagnosticReport.Builder builder = DiagnosticReport.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, basedOnElementIndex = 0, categoryElementIndex = 0, performerElementIndex = 0, resultsInterpreterElementIndex = 0, specimenElementIndex = 0, resultElementIndex = 0, imagingStudyElementIndex = 0, mediaElementIndex = 0, conclusionCodeElementIndex = 0, presentedFormElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "basedOn":
                    position = checkElementOrder("basedOn", 9, position, true);
                    builder.basedOn(parseReference("basedOn", reader, basedOnElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 10, position, false);
                    builder.status((DiagnosticReportStatus) parseString(DiagnosticReportStatus.builder(), "status", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 11, position, true);
                    builder.category(parseCodeableConcept("category", reader, categoryElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 12, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 13, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 14, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "effectiveDateTime":
                    position = checkElementOrder("effective[x]", 15, position, false);
                    builder.effective(parseDateTime("effectiveDateTime", reader, -1));
                    break;
                case "effectivePeriod":
                    position = checkElementOrder("effective[x]", 15, position, false);
                    builder.effective(parsePeriod("effectivePeriod", reader, -1));
                    break;
                case "issued":
                    position = checkElementOrder("issued", 16, position, false);
                    builder.issued(parseInstant("issued", reader, -1));
                    break;
                case "performer":
                    position = checkElementOrder("performer", 17, position, true);
                    builder.performer(parseReference("performer", reader, performerElementIndex++));
                    break;
                case "resultsInterpreter":
                    position = checkElementOrder("resultsInterpreter", 18, position, true);
                    builder.resultsInterpreter(parseReference("resultsInterpreter", reader, resultsInterpreterElementIndex++));
                    break;
                case "specimen":
                    position = checkElementOrder("specimen", 19, position, true);
                    builder.specimen(parseReference("specimen", reader, specimenElementIndex++));
                    break;
                case "result":
                    position = checkElementOrder("result", 20, position, true);
                    builder.result(parseReference("result", reader, resultElementIndex++));
                    break;
                case "imagingStudy":
                    position = checkElementOrder("imagingStudy", 21, position, true);
                    builder.imagingStudy(parseReference("imagingStudy", reader, imagingStudyElementIndex++));
                    break;
                case "media":
                    position = checkElementOrder("media", 22, position, true);
                    builder.media(parseDiagnosticReportMedia("media", reader, mediaElementIndex++));
                    break;
                case "conclusion":
                    position = checkElementOrder("conclusion", 23, position, false);
                    builder.conclusion(parseString("conclusion", reader, -1));
                    break;
                case "conclusionCode":
                    position = checkElementOrder("conclusionCode", 24, position, true);
                    builder.conclusionCode(parseCodeableConcept("conclusionCode", reader, conclusionCodeElementIndex++));
                    break;
                case "presentedForm":
                    position = checkElementOrder("presentedForm", 25, position, true);
                    builder.presentedForm(parseAttachment("presentedForm", reader, presentedFormElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DiagnosticReport.Media parseDiagnosticReportMedia(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DiagnosticReport.Media.Builder builder = DiagnosticReport.Media.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "comment":
                    position = checkElementOrder("comment", 2, position, false);
                    builder.comment(parseString("comment", reader, -1));
                    break;
                case "link":
                    position = checkElementOrder("link", 3, position, false);
                    builder.link(parseReference("link", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DocumentManifest parseDocumentManifest(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DocumentManifest.Builder builder = DocumentManifest.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, authorElementIndex = 0, recipientElementIndex = 0, contentElementIndex = 0, relatedElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "masterIdentifier":
                    position = checkElementOrder("masterIdentifier", 8, position, false);
                    builder.masterIdentifier(parseIdentifier("masterIdentifier", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 10, position, false);
                    builder.status((DocumentReferenceStatus) parseString(DocumentReferenceStatus.builder(), "status", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 11, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 12, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "created":
                    position = checkElementOrder("created", 13, position, false);
                    builder.created(parseDateTime("created", reader, -1));
                    break;
                case "author":
                    position = checkElementOrder("author", 14, position, true);
                    builder.author(parseReference("author", reader, authorElementIndex++));
                    break;
                case "recipient":
                    position = checkElementOrder("recipient", 15, position, true);
                    builder.recipient(parseReference("recipient", reader, recipientElementIndex++));
                    break;
                case "source":
                    position = checkElementOrder("source", 16, position, false);
                    builder.source(parseUri("source", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 17, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "content":
                    position = checkElementOrder("content", 18, position, true);
                    builder.content(parseReference("content", reader, contentElementIndex++));
                    break;
                case "related":
                    position = checkElementOrder("related", 19, position, true);
                    builder.related(parseDocumentManifestRelated("related", reader, relatedElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DocumentManifest.Related parseDocumentManifestRelated(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DocumentManifest.Related.Builder builder = DocumentManifest.Related.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 2, position, false);
                    builder.identifier(parseIdentifier("identifier", reader, -1));
                    break;
                case "ref":
                    position = checkElementOrder("ref", 3, position, false);
                    builder.ref(parseReference("ref", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DocumentReference parseDocumentReference(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DocumentReference.Builder builder = DocumentReference.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, categoryElementIndex = 0, authorElementIndex = 0, relatesToElementIndex = 0, securityLabelElementIndex = 0, contentElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "masterIdentifier":
                    position = checkElementOrder("masterIdentifier", 8, position, false);
                    builder.masterIdentifier(parseIdentifier("masterIdentifier", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 10, position, false);
                    builder.status((DocumentReferenceStatus) parseString(DocumentReferenceStatus.builder(), "status", reader, -1));
                    break;
                case "docStatus":
                    position = checkElementOrder("docStatus", 11, position, false);
                    builder.docStatus((ReferredDocumentStatus) parseString(ReferredDocumentStatus.builder(), "docStatus", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 12, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 13, position, true);
                    builder.category(parseCodeableConcept("category", reader, categoryElementIndex++));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 14, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 15, position, false);
                    builder.date(parseInstant("date", reader, -1));
                    break;
                case "author":
                    position = checkElementOrder("author", 16, position, true);
                    builder.author(parseReference("author", reader, authorElementIndex++));
                    break;
                case "authenticator":
                    position = checkElementOrder("authenticator", 17, position, false);
                    builder.authenticator(parseReference("authenticator", reader, -1));
                    break;
                case "custodian":
                    position = checkElementOrder("custodian", 18, position, false);
                    builder.custodian(parseReference("custodian", reader, -1));
                    break;
                case "relatesTo":
                    position = checkElementOrder("relatesTo", 19, position, true);
                    builder.relatesTo(parseDocumentReferenceRelatesTo("relatesTo", reader, relatesToElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 20, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "securityLabel":
                    position = checkElementOrder("securityLabel", 21, position, true);
                    builder.securityLabel(parseCodeableConcept("securityLabel", reader, securityLabelElementIndex++));
                    break;
                case "content":
                    position = checkElementOrder("content", 22, position, true);
                    builder.content(parseDocumentReferenceContent("content", reader, contentElementIndex++));
                    break;
                case "context":
                    position = checkElementOrder("context", 23, position, false);
                    builder.context(parseDocumentReferenceContext("context", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DocumentReference.Content parseDocumentReferenceContent(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DocumentReference.Content.Builder builder = DocumentReference.Content.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "attachment":
                    position = checkElementOrder("attachment", 2, position, false);
                    builder.attachment(parseAttachment("attachment", reader, -1));
                    break;
                case "format":
                    position = checkElementOrder("format", 3, position, false);
                    builder.format(parseCoding("format", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DocumentReference.Context parseDocumentReferenceContext(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DocumentReference.Context.Builder builder = DocumentReference.Context.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, encounterElementIndex = 0, eventElementIndex = 0, relatedElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 2, position, true);
                    builder.encounter(parseReference("encounter", reader, encounterElementIndex++));
                    break;
                case "event":
                    position = checkElementOrder("event", 3, position, true);
                    builder.event(parseCodeableConcept("event", reader, eventElementIndex++));
                    break;
                case "period":
                    position = checkElementOrder("period", 4, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                case "facilityType":
                    position = checkElementOrder("facilityType", 5, position, false);
                    builder.facilityType(parseCodeableConcept("facilityType", reader, -1));
                    break;
                case "practiceSetting":
                    position = checkElementOrder("practiceSetting", 6, position, false);
                    builder.practiceSetting(parseCodeableConcept("practiceSetting", reader, -1));
                    break;
                case "sourcePatientInfo":
                    position = checkElementOrder("sourcePatientInfo", 7, position, false);
                    builder.sourcePatientInfo(parseReference("sourcePatientInfo", reader, -1));
                    break;
                case "related":
                    position = checkElementOrder("related", 8, position, true);
                    builder.related(parseReference("related", reader, relatedElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private DocumentReference.RelatesTo parseDocumentReferenceRelatesTo(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        DocumentReference.RelatesTo.Builder builder = DocumentReference.RelatesTo.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code((DocumentRelationshipType) parseString(DocumentRelationshipType.builder(), "code", reader, -1));
                    break;
                case "target":
                    position = checkElementOrder("target", 3, position, false);
                    builder.target(parseReference("target", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Dosage parseDosage(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Dosage.Builder builder = Dosage.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, additionalInstructionElementIndex = 0, doseAndRateElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "sequence":
                    position = checkElementOrder("sequence", 2, position, false);
                    builder.sequence(parseInteger("sequence", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 3, position, false);
                    builder.text(parseString("text", reader, -1));
                    break;
                case "additionalInstruction":
                    position = checkElementOrder("additionalInstruction", 4, position, true);
                    builder.additionalInstruction(parseCodeableConcept("additionalInstruction", reader, additionalInstructionElementIndex++));
                    break;
                case "patientInstruction":
                    position = checkElementOrder("patientInstruction", 5, position, false);
                    builder.patientInstruction(parseString("patientInstruction", reader, -1));
                    break;
                case "timing":
                    position = checkElementOrder("timing", 6, position, false);
                    builder.timing(parseTiming("timing", reader, -1));
                    break;
                case "asNeededBoolean":
                    position = checkElementOrder("asNeeded[x]", 7, position, false);
                    builder.asNeeded(parseBoolean("asNeededBoolean", reader, -1));
                    break;
                case "asNeededCodeableConcept":
                    position = checkElementOrder("asNeeded[x]", 7, position, false);
                    builder.asNeeded(parseCodeableConcept("asNeededCodeableConcept", reader, -1));
                    break;
                case "site":
                    position = checkElementOrder("site", 8, position, false);
                    builder.site(parseCodeableConcept("site", reader, -1));
                    break;
                case "route":
                    position = checkElementOrder("route", 9, position, false);
                    builder.route(parseCodeableConcept("route", reader, -1));
                    break;
                case "method":
                    position = checkElementOrder("method", 10, position, false);
                    builder.method(parseCodeableConcept("method", reader, -1));
                    break;
                case "doseAndRate":
                    position = checkElementOrder("doseAndRate", 11, position, true);
                    builder.doseAndRate(parseDosageDoseAndRate("doseAndRate", reader, doseAndRateElementIndex++));
                    break;
                case "maxDosePerPeriod":
                    position = checkElementOrder("maxDosePerPeriod", 12, position, false);
                    builder.maxDosePerPeriod(parseRatio("maxDosePerPeriod", reader, -1));
                    break;
                case "maxDosePerAdministration":
                    position = checkElementOrder("maxDosePerAdministration", 13, position, false);
                    builder.maxDosePerAdministration((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "maxDosePerAdministration", reader, -1));
                    break;
                case "maxDosePerLifetime":
                    position = checkElementOrder("maxDosePerLifetime", 14, position, false);
                    builder.maxDosePerLifetime((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "maxDosePerLifetime", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Dosage.DoseAndRate parseDosageDoseAndRate(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Dosage.DoseAndRate.Builder builder = Dosage.DoseAndRate.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "doseRange":
                    position = checkElementOrder("dose[x]", 3, position, false);
                    builder.dose(parseRange("doseRange", reader, -1));
                    break;
                case "doseQuantity":
                    position = checkElementOrder("dose[x]", 3, position, false);
                    builder.dose((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "doseQuantity", reader, -1));
                    break;
                case "rateRatio":
                    position = checkElementOrder("rate[x]", 4, position, false);
                    builder.rate(parseRatio("rateRatio", reader, -1));
                    break;
                case "rateRange":
                    position = checkElementOrder("rate[x]", 4, position, false);
                    builder.rate(parseRange("rateRange", reader, -1));
                    break;
                case "rateQuantity":
                    position = checkElementOrder("rate[x]", 4, position, false);
                    builder.rate((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "rateQuantity", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ElementDefinition parseElementDefinition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ElementDefinition.Builder builder = ElementDefinition.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, representationElementIndex = 0, codeElementIndex = 0, aliasElementIndex = 0, typeElementIndex = 0, exampleElementIndex = 0, conditionElementIndex = 0, constraintElementIndex = 0, mappingElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "path":
                    position = checkElementOrder("path", 2, position, false);
                    builder.path(parseString("path", reader, -1));
                    break;
                case "representation":
                    position = checkElementOrder("representation", 3, position, true);
                    builder.representation((PropertyRepresentation) parseString(PropertyRepresentation.builder(), "representation", reader, representationElementIndex++));
                    break;
                case "sliceName":
                    position = checkElementOrder("sliceName", 4, position, false);
                    builder.sliceName(parseString("sliceName", reader, -1));
                    break;
                case "sliceIsConstraining":
                    position = checkElementOrder("sliceIsConstraining", 5, position, false);
                    builder.sliceIsConstraining(parseBoolean("sliceIsConstraining", reader, -1));
                    break;
                case "label":
                    position = checkElementOrder("label", 6, position, false);
                    builder.label(parseString("label", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 7, position, true);
                    builder.code(parseCoding("code", reader, codeElementIndex++));
                    break;
                case "slicing":
                    position = checkElementOrder("slicing", 8, position, false);
                    builder.slicing(parseElementDefinitionSlicing("slicing", reader, -1));
                    break;
                case "short":
                    position = checkElementOrder("short", 9, position, false);
                    builder._short(parseString("short", reader, -1));
                    break;
                case "definition":
                    position = checkElementOrder("definition", 10, position, false);
                    builder.definition((Markdown) parseString(Markdown.builder(), "definition", reader, -1));
                    break;
                case "comment":
                    position = checkElementOrder("comment", 11, position, false);
                    builder.comment((Markdown) parseString(Markdown.builder(), "comment", reader, -1));
                    break;
                case "requirements":
                    position = checkElementOrder("requirements", 12, position, false);
                    builder.requirements((Markdown) parseString(Markdown.builder(), "requirements", reader, -1));
                    break;
                case "alias":
                    position = checkElementOrder("alias", 13, position, true);
                    builder.alias(parseString("alias", reader, aliasElementIndex++));
                    break;
                case "min":
                    position = checkElementOrder("min", 14, position, false);
                    builder.min((UnsignedInt) parseInteger(UnsignedInt.builder(), "min", reader, -1));
                    break;
                case "max":
                    position = checkElementOrder("max", 15, position, false);
                    builder.max(parseString("max", reader, -1));
                    break;
                case "base":
                    position = checkElementOrder("base", 16, position, false);
                    builder.base(parseElementDefinitionBase("base", reader, -1));
                    break;
                case "contentReference":
                    position = checkElementOrder("contentReference", 17, position, false);
                    builder.contentReference(parseUri("contentReference", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 18, position, true);
                    builder.type(parseElementDefinitionType("type", reader, typeElementIndex++));
                    break;
                case "defaultValueBase64Binary":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseBase64Binary("defaultValueBase64Binary", reader, -1));
                    break;
                case "defaultValueBoolean":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseBoolean("defaultValueBoolean", reader, -1));
                    break;
                case "defaultValueCanonical":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue((Canonical) parseUri(Canonical.builder(), "defaultValueCanonical", reader, -1));
                    break;
                case "defaultValueCode":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue((Code) parseString(Code.builder(), "defaultValueCode", reader, -1));
                    break;
                case "defaultValueDate":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseDate("defaultValueDate", reader, -1));
                    break;
                case "defaultValueDateTime":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseDateTime("defaultValueDateTime", reader, -1));
                    break;
                case "defaultValueDecimal":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseDecimal("defaultValueDecimal", reader, -1));
                    break;
                case "defaultValueId":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue((Id) parseString(Id.builder(), "defaultValueId", reader, -1));
                    break;
                case "defaultValueInstant":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseInstant("defaultValueInstant", reader, -1));
                    break;
                case "defaultValueInteger":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseInteger("defaultValueInteger", reader, -1));
                    break;
                case "defaultValueMarkdown":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue((Markdown) parseString(Markdown.builder(), "defaultValueMarkdown", reader, -1));
                    break;
                case "defaultValueOid":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue((Oid) parseUri(Oid.builder(), "defaultValueOid", reader, -1));
                    break;
                case "defaultValuePositiveInt":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue((PositiveInt) parseInteger(PositiveInt.builder(), "defaultValuePositiveInt", reader, -1));
                    break;
                case "defaultValueString":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseString("defaultValueString", reader, -1));
                    break;
                case "defaultValueTime":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseTime("defaultValueTime", reader, -1));
                    break;
                case "defaultValueUnsignedInt":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue((UnsignedInt) parseInteger(UnsignedInt.builder(), "defaultValueUnsignedInt", reader, -1));
                    break;
                case "defaultValueUri":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseUri("defaultValueUri", reader, -1));
                    break;
                case "defaultValueUrl":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue((Url) parseUri(Url.builder(), "defaultValueUrl", reader, -1));
                    break;
                case "defaultValueUuid":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue((Uuid) parseUri(Uuid.builder(), "defaultValueUuid", reader, -1));
                    break;
                case "defaultValueAddress":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseAddress("defaultValueAddress", reader, -1));
                    break;
                case "defaultValueAge":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue((Age) parseQuantity(Age.builder(), "defaultValueAge", reader, -1));
                    break;
                case "defaultValueAnnotation":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseAnnotation("defaultValueAnnotation", reader, -1));
                    break;
                case "defaultValueAttachment":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseAttachment("defaultValueAttachment", reader, -1));
                    break;
                case "defaultValueCodeableConcept":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseCodeableConcept("defaultValueCodeableConcept", reader, -1));
                    break;
                case "defaultValueCodeableReference":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseCodeableReference("defaultValueCodeableReference", reader, -1));
                    break;
                case "defaultValueCoding":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseCoding("defaultValueCoding", reader, -1));
                    break;
                case "defaultValueContactPoint":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseContactPoint("defaultValueContactPoint", reader, -1));
                    break;
                case "defaultValueCount":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue((Count) parseQuantity(Count.builder(), "defaultValueCount", reader, -1));
                    break;
                case "defaultValueDistance":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue((Distance) parseQuantity(Distance.builder(), "defaultValueDistance", reader, -1));
                    break;
                case "defaultValueDuration":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue((Duration) parseQuantity(Duration.builder(), "defaultValueDuration", reader, -1));
                    break;
                case "defaultValueHumanName":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseHumanName("defaultValueHumanName", reader, -1));
                    break;
                case "defaultValueIdentifier":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseIdentifier("defaultValueIdentifier", reader, -1));
                    break;
                case "defaultValueMoney":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseMoney("defaultValueMoney", reader, -1));
                    break;
                case "defaultValuePeriod":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parsePeriod("defaultValuePeriod", reader, -1));
                    break;
                case "defaultValueQuantity":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseQuantity("defaultValueQuantity", reader, -1));
                    break;
                case "defaultValueRange":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseRange("defaultValueRange", reader, -1));
                    break;
                case "defaultValueRatio":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseRatio("defaultValueRatio", reader, -1));
                    break;
                case "defaultValueRatioRange":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseRatioRange("defaultValueRatioRange", reader, -1));
                    break;
                case "defaultValueReference":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseReference("defaultValueReference", reader, -1));
                    break;
                case "defaultValueSampledData":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseSampledData("defaultValueSampledData", reader, -1));
                    break;
                case "defaultValueSignature":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseSignature("defaultValueSignature", reader, -1));
                    break;
                case "defaultValueTiming":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseTiming("defaultValueTiming", reader, -1));
                    break;
                case "defaultValueContactDetail":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseContactDetail("defaultValueContactDetail", reader, -1));
                    break;
                case "defaultValueContributor":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseContributor("defaultValueContributor", reader, -1));
                    break;
                case "defaultValueDataRequirement":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseDataRequirement("defaultValueDataRequirement", reader, -1));
                    break;
                case "defaultValueExpression":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseExpression("defaultValueExpression", reader, -1));
                    break;
                case "defaultValueParameterDefinition":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseParameterDefinition("defaultValueParameterDefinition", reader, -1));
                    break;
                case "defaultValueRelatedArtifact":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseRelatedArtifact("defaultValueRelatedArtifact", reader, -1));
                    break;
                case "defaultValueTriggerDefinition":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseTriggerDefinition("defaultValueTriggerDefinition", reader, -1));
                    break;
                case "defaultValueUsageContext":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseUsageContext("defaultValueUsageContext", reader, -1));
                    break;
                case "defaultValueDosage":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseDosage("defaultValueDosage", reader, -1));
                    break;
                case "defaultValueMeta":
                    position = checkElementOrder("defaultValue[x]", 19, position, false);
                    builder.defaultValue(parseMeta("defaultValueMeta", reader, -1));
                    break;
                case "meaningWhenMissing":
                    position = checkElementOrder("meaningWhenMissing", 20, position, false);
                    builder.meaningWhenMissing((Markdown) parseString(Markdown.builder(), "meaningWhenMissing", reader, -1));
                    break;
                case "orderMeaning":
                    position = checkElementOrder("orderMeaning", 21, position, false);
                    builder.orderMeaning(parseString("orderMeaning", reader, -1));
                    break;
                case "fixedBase64Binary":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseBase64Binary("fixedBase64Binary", reader, -1));
                    break;
                case "fixedBoolean":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseBoolean("fixedBoolean", reader, -1));
                    break;
                case "fixedCanonical":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed((Canonical) parseUri(Canonical.builder(), "fixedCanonical", reader, -1));
                    break;
                case "fixedCode":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed((Code) parseString(Code.builder(), "fixedCode", reader, -1));
                    break;
                case "fixedDate":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseDate("fixedDate", reader, -1));
                    break;
                case "fixedDateTime":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseDateTime("fixedDateTime", reader, -1));
                    break;
                case "fixedDecimal":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseDecimal("fixedDecimal", reader, -1));
                    break;
                case "fixedId":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed((Id) parseString(Id.builder(), "fixedId", reader, -1));
                    break;
                case "fixedInstant":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseInstant("fixedInstant", reader, -1));
                    break;
                case "fixedInteger":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseInteger("fixedInteger", reader, -1));
                    break;
                case "fixedMarkdown":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed((Markdown) parseString(Markdown.builder(), "fixedMarkdown", reader, -1));
                    break;
                case "fixedOid":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed((Oid) parseUri(Oid.builder(), "fixedOid", reader, -1));
                    break;
                case "fixedPositiveInt":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed((PositiveInt) parseInteger(PositiveInt.builder(), "fixedPositiveInt", reader, -1));
                    break;
                case "fixedString":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseString("fixedString", reader, -1));
                    break;
                case "fixedTime":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseTime("fixedTime", reader, -1));
                    break;
                case "fixedUnsignedInt":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed((UnsignedInt) parseInteger(UnsignedInt.builder(), "fixedUnsignedInt", reader, -1));
                    break;
                case "fixedUri":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseUri("fixedUri", reader, -1));
                    break;
                case "fixedUrl":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed((Url) parseUri(Url.builder(), "fixedUrl", reader, -1));
                    break;
                case "fixedUuid":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed((Uuid) parseUri(Uuid.builder(), "fixedUuid", reader, -1));
                    break;
                case "fixedAddress":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseAddress("fixedAddress", reader, -1));
                    break;
                case "fixedAge":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed((Age) parseQuantity(Age.builder(), "fixedAge", reader, -1));
                    break;
                case "fixedAnnotation":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseAnnotation("fixedAnnotation", reader, -1));
                    break;
                case "fixedAttachment":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseAttachment("fixedAttachment", reader, -1));
                    break;
                case "fixedCodeableConcept":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseCodeableConcept("fixedCodeableConcept", reader, -1));
                    break;
                case "fixedCodeableReference":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseCodeableReference("fixedCodeableReference", reader, -1));
                    break;
                case "fixedCoding":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseCoding("fixedCoding", reader, -1));
                    break;
                case "fixedContactPoint":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseContactPoint("fixedContactPoint", reader, -1));
                    break;
                case "fixedCount":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed((Count) parseQuantity(Count.builder(), "fixedCount", reader, -1));
                    break;
                case "fixedDistance":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed((Distance) parseQuantity(Distance.builder(), "fixedDistance", reader, -1));
                    break;
                case "fixedDuration":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed((Duration) parseQuantity(Duration.builder(), "fixedDuration", reader, -1));
                    break;
                case "fixedHumanName":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseHumanName("fixedHumanName", reader, -1));
                    break;
                case "fixedIdentifier":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseIdentifier("fixedIdentifier", reader, -1));
                    break;
                case "fixedMoney":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseMoney("fixedMoney", reader, -1));
                    break;
                case "fixedPeriod":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parsePeriod("fixedPeriod", reader, -1));
                    break;
                case "fixedQuantity":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseQuantity("fixedQuantity", reader, -1));
                    break;
                case "fixedRange":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseRange("fixedRange", reader, -1));
                    break;
                case "fixedRatio":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseRatio("fixedRatio", reader, -1));
                    break;
                case "fixedRatioRange":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseRatioRange("fixedRatioRange", reader, -1));
                    break;
                case "fixedReference":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseReference("fixedReference", reader, -1));
                    break;
                case "fixedSampledData":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseSampledData("fixedSampledData", reader, -1));
                    break;
                case "fixedSignature":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseSignature("fixedSignature", reader, -1));
                    break;
                case "fixedTiming":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseTiming("fixedTiming", reader, -1));
                    break;
                case "fixedContactDetail":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseContactDetail("fixedContactDetail", reader, -1));
                    break;
                case "fixedContributor":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseContributor("fixedContributor", reader, -1));
                    break;
                case "fixedDataRequirement":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseDataRequirement("fixedDataRequirement", reader, -1));
                    break;
                case "fixedExpression":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseExpression("fixedExpression", reader, -1));
                    break;
                case "fixedParameterDefinition":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseParameterDefinition("fixedParameterDefinition", reader, -1));
                    break;
                case "fixedRelatedArtifact":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseRelatedArtifact("fixedRelatedArtifact", reader, -1));
                    break;
                case "fixedTriggerDefinition":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseTriggerDefinition("fixedTriggerDefinition", reader, -1));
                    break;
                case "fixedUsageContext":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseUsageContext("fixedUsageContext", reader, -1));
                    break;
                case "fixedDosage":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseDosage("fixedDosage", reader, -1));
                    break;
                case "fixedMeta":
                    position = checkElementOrder("fixed[x]", 22, position, false);
                    builder.fixed(parseMeta("fixedMeta", reader, -1));
                    break;
                case "patternBase64Binary":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseBase64Binary("patternBase64Binary", reader, -1));
                    break;
                case "patternBoolean":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseBoolean("patternBoolean", reader, -1));
                    break;
                case "patternCanonical":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern((Canonical) parseUri(Canonical.builder(), "patternCanonical", reader, -1));
                    break;
                case "patternCode":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern((Code) parseString(Code.builder(), "patternCode", reader, -1));
                    break;
                case "patternDate":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseDate("patternDate", reader, -1));
                    break;
                case "patternDateTime":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseDateTime("patternDateTime", reader, -1));
                    break;
                case "patternDecimal":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseDecimal("patternDecimal", reader, -1));
                    break;
                case "patternId":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern((Id) parseString(Id.builder(), "patternId", reader, -1));
                    break;
                case "patternInstant":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseInstant("patternInstant", reader, -1));
                    break;
                case "patternInteger":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseInteger("patternInteger", reader, -1));
                    break;
                case "patternMarkdown":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern((Markdown) parseString(Markdown.builder(), "patternMarkdown", reader, -1));
                    break;
                case "patternOid":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern((Oid) parseUri(Oid.builder(), "patternOid", reader, -1));
                    break;
                case "patternPositiveInt":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern((PositiveInt) parseInteger(PositiveInt.builder(), "patternPositiveInt", reader, -1));
                    break;
                case "patternString":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseString("patternString", reader, -1));
                    break;
                case "patternTime":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseTime("patternTime", reader, -1));
                    break;
                case "patternUnsignedInt":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern((UnsignedInt) parseInteger(UnsignedInt.builder(), "patternUnsignedInt", reader, -1));
                    break;
                case "patternUri":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseUri("patternUri", reader, -1));
                    break;
                case "patternUrl":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern((Url) parseUri(Url.builder(), "patternUrl", reader, -1));
                    break;
                case "patternUuid":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern((Uuid) parseUri(Uuid.builder(), "patternUuid", reader, -1));
                    break;
                case "patternAddress":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseAddress("patternAddress", reader, -1));
                    break;
                case "patternAge":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern((Age) parseQuantity(Age.builder(), "patternAge", reader, -1));
                    break;
                case "patternAnnotation":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseAnnotation("patternAnnotation", reader, -1));
                    break;
                case "patternAttachment":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseAttachment("patternAttachment", reader, -1));
                    break;
                case "patternCodeableConcept":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseCodeableConcept("patternCodeableConcept", reader, -1));
                    break;
                case "patternCodeableReference":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseCodeableReference("patternCodeableReference", reader, -1));
                    break;
                case "patternCoding":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseCoding("patternCoding", reader, -1));
                    break;
                case "patternContactPoint":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseContactPoint("patternContactPoint", reader, -1));
                    break;
                case "patternCount":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern((Count) parseQuantity(Count.builder(), "patternCount", reader, -1));
                    break;
                case "patternDistance":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern((Distance) parseQuantity(Distance.builder(), "patternDistance", reader, -1));
                    break;
                case "patternDuration":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern((Duration) parseQuantity(Duration.builder(), "patternDuration", reader, -1));
                    break;
                case "patternHumanName":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseHumanName("patternHumanName", reader, -1));
                    break;
                case "patternIdentifier":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseIdentifier("patternIdentifier", reader, -1));
                    break;
                case "patternMoney":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseMoney("patternMoney", reader, -1));
                    break;
                case "patternPeriod":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parsePeriod("patternPeriod", reader, -1));
                    break;
                case "patternQuantity":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseQuantity("patternQuantity", reader, -1));
                    break;
                case "patternRange":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseRange("patternRange", reader, -1));
                    break;
                case "patternRatio":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseRatio("patternRatio", reader, -1));
                    break;
                case "patternRatioRange":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseRatioRange("patternRatioRange", reader, -1));
                    break;
                case "patternReference":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseReference("patternReference", reader, -1));
                    break;
                case "patternSampledData":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseSampledData("patternSampledData", reader, -1));
                    break;
                case "patternSignature":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseSignature("patternSignature", reader, -1));
                    break;
                case "patternTiming":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseTiming("patternTiming", reader, -1));
                    break;
                case "patternContactDetail":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseContactDetail("patternContactDetail", reader, -1));
                    break;
                case "patternContributor":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseContributor("patternContributor", reader, -1));
                    break;
                case "patternDataRequirement":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseDataRequirement("patternDataRequirement", reader, -1));
                    break;
                case "patternExpression":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseExpression("patternExpression", reader, -1));
                    break;
                case "patternParameterDefinition":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseParameterDefinition("patternParameterDefinition", reader, -1));
                    break;
                case "patternRelatedArtifact":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseRelatedArtifact("patternRelatedArtifact", reader, -1));
                    break;
                case "patternTriggerDefinition":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseTriggerDefinition("patternTriggerDefinition", reader, -1));
                    break;
                case "patternUsageContext":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseUsageContext("patternUsageContext", reader, -1));
                    break;
                case "patternDosage":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseDosage("patternDosage", reader, -1));
                    break;
                case "patternMeta":
                    position = checkElementOrder("pattern[x]", 23, position, false);
                    builder.pattern(parseMeta("patternMeta", reader, -1));
                    break;
                case "example":
                    position = checkElementOrder("example", 24, position, true);
                    builder.example(parseElementDefinitionExample("example", reader, exampleElementIndex++));
                    break;
                case "minValueDate":
                    position = checkElementOrder("minValue[x]", 25, position, false);
                    builder.minValue(parseDate("minValueDate", reader, -1));
                    break;
                case "minValueDateTime":
                    position = checkElementOrder("minValue[x]", 25, position, false);
                    builder.minValue(parseDateTime("minValueDateTime", reader, -1));
                    break;
                case "minValueInstant":
                    position = checkElementOrder("minValue[x]", 25, position, false);
                    builder.minValue(parseInstant("minValueInstant", reader, -1));
                    break;
                case "minValueTime":
                    position = checkElementOrder("minValue[x]", 25, position, false);
                    builder.minValue(parseTime("minValueTime", reader, -1));
                    break;
                case "minValueDecimal":
                    position = checkElementOrder("minValue[x]", 25, position, false);
                    builder.minValue(parseDecimal("minValueDecimal", reader, -1));
                    break;
                case "minValueInteger":
                    position = checkElementOrder("minValue[x]", 25, position, false);
                    builder.minValue(parseInteger("minValueInteger", reader, -1));
                    break;
                case "minValuePositiveInt":
                    position = checkElementOrder("minValue[x]", 25, position, false);
                    builder.minValue((PositiveInt) parseInteger(PositiveInt.builder(), "minValuePositiveInt", reader, -1));
                    break;
                case "minValueUnsignedInt":
                    position = checkElementOrder("minValue[x]", 25, position, false);
                    builder.minValue((UnsignedInt) parseInteger(UnsignedInt.builder(), "minValueUnsignedInt", reader, -1));
                    break;
                case "minValueQuantity":
                    position = checkElementOrder("minValue[x]", 25, position, false);
                    builder.minValue(parseQuantity("minValueQuantity", reader, -1));
                    break;
                case "maxValueDate":
                    position = checkElementOrder("maxValue[x]", 26, position, false);
                    builder.maxValue(parseDate("maxValueDate", reader, -1));
                    break;
                case "maxValueDateTime":
                    position = checkElementOrder("maxValue[x]", 26, position, false);
                    builder.maxValue(parseDateTime("maxValueDateTime", reader, -1));
                    break;
                case "maxValueInstant":
                    position = checkElementOrder("maxValue[x]", 26, position, false);
                    builder.maxValue(parseInstant("maxValueInstant", reader, -1));
                    break;
                case "maxValueTime":
                    position = checkElementOrder("maxValue[x]", 26, position, false);
                    builder.maxValue(parseTime("maxValueTime", reader, -1));
                    break;
                case "maxValueDecimal":
                    position = checkElementOrder("maxValue[x]", 26, position, false);
                    builder.maxValue(parseDecimal("maxValueDecimal", reader, -1));
                    break;
                case "maxValueInteger":
                    position = checkElementOrder("maxValue[x]", 26, position, false);
                    builder.maxValue(parseInteger("maxValueInteger", reader, -1));
                    break;
                case "maxValuePositiveInt":
                    position = checkElementOrder("maxValue[x]", 26, position, false);
                    builder.maxValue((PositiveInt) parseInteger(PositiveInt.builder(), "maxValuePositiveInt", reader, -1));
                    break;
                case "maxValueUnsignedInt":
                    position = checkElementOrder("maxValue[x]", 26, position, false);
                    builder.maxValue((UnsignedInt) parseInteger(UnsignedInt.builder(), "maxValueUnsignedInt", reader, -1));
                    break;
                case "maxValueQuantity":
                    position = checkElementOrder("maxValue[x]", 26, position, false);
                    builder.maxValue(parseQuantity("maxValueQuantity", reader, -1));
                    break;
                case "maxLength":
                    position = checkElementOrder("maxLength", 27, position, false);
                    builder.maxLength(parseInteger("maxLength", reader, -1));
                    break;
                case "condition":
                    position = checkElementOrder("condition", 28, position, true);
                    builder.condition((Id) parseString(Id.builder(), "condition", reader, conditionElementIndex++));
                    break;
                case "constraint":
                    position = checkElementOrder("constraint", 29, position, true);
                    builder.constraint(parseElementDefinitionConstraint("constraint", reader, constraintElementIndex++));
                    break;
                case "mustSupport":
                    position = checkElementOrder("mustSupport", 30, position, false);
                    builder.mustSupport(parseBoolean("mustSupport", reader, -1));
                    break;
                case "isModifier":
                    position = checkElementOrder("isModifier", 31, position, false);
                    builder.isModifier(parseBoolean("isModifier", reader, -1));
                    break;
                case "isModifierReason":
                    position = checkElementOrder("isModifierReason", 32, position, false);
                    builder.isModifierReason(parseString("isModifierReason", reader, -1));
                    break;
                case "isSummary":
                    position = checkElementOrder("isSummary", 33, position, false);
                    builder.isSummary(parseBoolean("isSummary", reader, -1));
                    break;
                case "binding":
                    position = checkElementOrder("binding", 34, position, false);
                    builder.binding(parseElementDefinitionBinding("binding", reader, -1));
                    break;
                case "mapping":
                    position = checkElementOrder("mapping", 35, position, true);
                    builder.mapping(parseElementDefinitionMapping("mapping", reader, mappingElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ElementDefinition.Base parseElementDefinitionBase(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ElementDefinition.Base.Builder builder = ElementDefinition.Base.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "path":
                    position = checkElementOrder("path", 2, position, false);
                    builder.path(parseString("path", reader, -1));
                    break;
                case "min":
                    position = checkElementOrder("min", 3, position, false);
                    builder.min((UnsignedInt) parseInteger(UnsignedInt.builder(), "min", reader, -1));
                    break;
                case "max":
                    position = checkElementOrder("max", 4, position, false);
                    builder.max(parseString("max", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ElementDefinition.Binding parseElementDefinitionBinding(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ElementDefinition.Binding.Builder builder = ElementDefinition.Binding.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "strength":
                    position = checkElementOrder("strength", 2, position, false);
                    builder.strength((BindingStrength) parseString(BindingStrength.builder(), "strength", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 3, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "valueSet":
                    position = checkElementOrder("valueSet", 4, position, false);
                    builder.valueSet((Canonical) parseUri(Canonical.builder(), "valueSet", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ElementDefinition.Constraint parseElementDefinitionConstraint(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ElementDefinition.Constraint.Builder builder = ElementDefinition.Constraint.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "key":
                    position = checkElementOrder("key", 2, position, false);
                    builder.key((Id) parseString(Id.builder(), "key", reader, -1));
                    break;
                case "requirements":
                    position = checkElementOrder("requirements", 3, position, false);
                    builder.requirements(parseString("requirements", reader, -1));
                    break;
                case "severity":
                    position = checkElementOrder("severity", 4, position, false);
                    builder.severity((ConstraintSeverity) parseString(ConstraintSeverity.builder(), "severity", reader, -1));
                    break;
                case "human":
                    position = checkElementOrder("human", 5, position, false);
                    builder.human(parseString("human", reader, -1));
                    break;
                case "expression":
                    position = checkElementOrder("expression", 6, position, false);
                    builder.expression(parseString("expression", reader, -1));
                    break;
                case "xpath":
                    position = checkElementOrder("xpath", 7, position, false);
                    builder.xpath(parseString("xpath", reader, -1));
                    break;
                case "source":
                    position = checkElementOrder("source", 8, position, false);
                    builder.source((Canonical) parseUri(Canonical.builder(), "source", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ElementDefinition.Example parseElementDefinitionExample(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ElementDefinition.Example.Builder builder = ElementDefinition.Example.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "label":
                    position = checkElementOrder("label", 2, position, false);
                    builder.label(parseString("label", reader, -1));
                    break;
                case "valueBase64Binary":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBase64Binary("valueBase64Binary", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueCanonical":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Canonical) parseUri(Canonical.builder(), "valueCanonical", reader, -1));
                    break;
                case "valueCode":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Code) parseString(Code.builder(), "valueCode", reader, -1));
                    break;
                case "valueDate":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDate("valueDate", reader, -1));
                    break;
                case "valueDateTime":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDateTime("valueDateTime", reader, -1));
                    break;
                case "valueDecimal":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDecimal("valueDecimal", reader, -1));
                    break;
                case "valueId":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Id) parseString(Id.builder(), "valueId", reader, -1));
                    break;
                case "valueInstant":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseInstant("valueInstant", reader, -1));
                    break;
                case "valueInteger":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseInteger("valueInteger", reader, -1));
                    break;
                case "valueMarkdown":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Markdown) parseString(Markdown.builder(), "valueMarkdown", reader, -1));
                    break;
                case "valueOid":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Oid) parseUri(Oid.builder(), "valueOid", reader, -1));
                    break;
                case "valuePositiveInt":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((PositiveInt) parseInteger(PositiveInt.builder(), "valuePositiveInt", reader, -1));
                    break;
                case "valueString":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseString("valueString", reader, -1));
                    break;
                case "valueTime":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseTime("valueTime", reader, -1));
                    break;
                case "valueUnsignedInt":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((UnsignedInt) parseInteger(UnsignedInt.builder(), "valueUnsignedInt", reader, -1));
                    break;
                case "valueUri":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseUri("valueUri", reader, -1));
                    break;
                case "valueUrl":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Url) parseUri(Url.builder(), "valueUrl", reader, -1));
                    break;
                case "valueUuid":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Uuid) parseUri(Uuid.builder(), "valueUuid", reader, -1));
                    break;
                case "valueAddress":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseAddress("valueAddress", reader, -1));
                    break;
                case "valueAge":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Age) parseQuantity(Age.builder(), "valueAge", reader, -1));
                    break;
                case "valueAnnotation":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseAnnotation("valueAnnotation", reader, -1));
                    break;
                case "valueAttachment":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseAttachment("valueAttachment", reader, -1));
                    break;
                case "valueCodeableConcept":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCodeableConcept("valueCodeableConcept", reader, -1));
                    break;
                case "valueCodeableReference":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCodeableReference("valueCodeableReference", reader, -1));
                    break;
                case "valueCoding":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCoding("valueCoding", reader, -1));
                    break;
                case "valueContactPoint":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseContactPoint("valueContactPoint", reader, -1));
                    break;
                case "valueCount":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Count) parseQuantity(Count.builder(), "valueCount", reader, -1));
                    break;
                case "valueDistance":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Distance) parseQuantity(Distance.builder(), "valueDistance", reader, -1));
                    break;
                case "valueDuration":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Duration) parseQuantity(Duration.builder(), "valueDuration", reader, -1));
                    break;
                case "valueHumanName":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseHumanName("valueHumanName", reader, -1));
                    break;
                case "valueIdentifier":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseIdentifier("valueIdentifier", reader, -1));
                    break;
                case "valueMoney":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseMoney("valueMoney", reader, -1));
                    break;
                case "valuePeriod":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parsePeriod("valuePeriod", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueRange":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRange("valueRange", reader, -1));
                    break;
                case "valueRatio":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRatio("valueRatio", reader, -1));
                    break;
                case "valueRatioRange":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRatioRange("valueRatioRange", reader, -1));
                    break;
                case "valueReference":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseReference("valueReference", reader, -1));
                    break;
                case "valueSampledData":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseSampledData("valueSampledData", reader, -1));
                    break;
                case "valueSignature":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseSignature("valueSignature", reader, -1));
                    break;
                case "valueTiming":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseTiming("valueTiming", reader, -1));
                    break;
                case "valueContactDetail":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseContactDetail("valueContactDetail", reader, -1));
                    break;
                case "valueContributor":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseContributor("valueContributor", reader, -1));
                    break;
                case "valueDataRequirement":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDataRequirement("valueDataRequirement", reader, -1));
                    break;
                case "valueExpression":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseExpression("valueExpression", reader, -1));
                    break;
                case "valueParameterDefinition":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseParameterDefinition("valueParameterDefinition", reader, -1));
                    break;
                case "valueRelatedArtifact":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRelatedArtifact("valueRelatedArtifact", reader, -1));
                    break;
                case "valueTriggerDefinition":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseTriggerDefinition("valueTriggerDefinition", reader, -1));
                    break;
                case "valueUsageContext":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseUsageContext("valueUsageContext", reader, -1));
                    break;
                case "valueDosage":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDosage("valueDosage", reader, -1));
                    break;
                case "valueMeta":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseMeta("valueMeta", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ElementDefinition.Mapping parseElementDefinitionMapping(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ElementDefinition.Mapping.Builder builder = ElementDefinition.Mapping.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identity":
                    position = checkElementOrder("identity", 2, position, false);
                    builder.identity((Id) parseString(Id.builder(), "identity", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "map":
                    position = checkElementOrder("map", 4, position, false);
                    builder.map(parseString("map", reader, -1));
                    break;
                case "comment":
                    position = checkElementOrder("comment", 5, position, false);
                    builder.comment(parseString("comment", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ElementDefinition.Slicing parseElementDefinitionSlicing(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ElementDefinition.Slicing.Builder builder = ElementDefinition.Slicing.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, discriminatorElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "discriminator":
                    position = checkElementOrder("discriminator", 2, position, true);
                    builder.discriminator(parseElementDefinitionSlicingDiscriminator("discriminator", reader, discriminatorElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 3, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "ordered":
                    position = checkElementOrder("ordered", 4, position, false);
                    builder.ordered(parseBoolean("ordered", reader, -1));
                    break;
                case "rules":
                    position = checkElementOrder("rules", 5, position, false);
                    builder.rules((SlicingRules) parseString(SlicingRules.builder(), "rules", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ElementDefinition.Slicing.Discriminator parseElementDefinitionSlicingDiscriminator(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ElementDefinition.Slicing.Discriminator.Builder builder = ElementDefinition.Slicing.Discriminator.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type((DiscriminatorType) parseString(DiscriminatorType.builder(), "type", reader, -1));
                    break;
                case "path":
                    position = checkElementOrder("path", 3, position, false);
                    builder.path(parseString("path", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ElementDefinition.Type parseElementDefinitionType(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ElementDefinition.Type.Builder builder = ElementDefinition.Type.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, profileElementIndex = 0, targetProfileElementIndex = 0, aggregationElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code(parseUri("code", reader, -1));
                    break;
                case "profile":
                    position = checkElementOrder("profile", 3, position, true);
                    builder.profile((Canonical) parseUri(Canonical.builder(), "profile", reader, profileElementIndex++));
                    break;
                case "targetProfile":
                    position = checkElementOrder("targetProfile", 4, position, true);
                    builder.targetProfile((Canonical) parseUri(Canonical.builder(), "targetProfile", reader, targetProfileElementIndex++));
                    break;
                case "aggregation":
                    position = checkElementOrder("aggregation", 5, position, true);
                    builder.aggregation((AggregationMode) parseString(AggregationMode.builder(), "aggregation", reader, aggregationElementIndex++));
                    break;
                case "versioning":
                    position = checkElementOrder("versioning", 6, position, false);
                    builder.versioning((ReferenceVersionRules) parseString(ReferenceVersionRules.builder(), "versioning", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Encounter parseEncounter(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Encounter.Builder builder = Encounter.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, statusHistoryElementIndex = 0, classHistoryElementIndex = 0, typeElementIndex = 0, episodeOfCareElementIndex = 0, basedOnElementIndex = 0, participantElementIndex = 0, appointmentElementIndex = 0, reasonCodeElementIndex = 0, reasonReferenceElementIndex = 0, diagnosisElementIndex = 0, accountElementIndex = 0, locationElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((EncounterStatus) parseString(EncounterStatus.builder(), "status", reader, -1));
                    break;
                case "statusHistory":
                    position = checkElementOrder("statusHistory", 10, position, true);
                    builder.statusHistory(parseEncounterStatusHistory("statusHistory", reader, statusHistoryElementIndex++));
                    break;
                case "class":
                    position = checkElementOrder("class", 11, position, false);
                    builder.clazz(parseCoding("class", reader, -1));
                    break;
                case "classHistory":
                    position = checkElementOrder("classHistory", 12, position, true);
                    builder.classHistory(parseEncounterClassHistory("classHistory", reader, classHistoryElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 13, position, true);
                    builder.type(parseCodeableConcept("type", reader, typeElementIndex++));
                    break;
                case "serviceType":
                    position = checkElementOrder("serviceType", 14, position, false);
                    builder.serviceType(parseCodeableConcept("serviceType", reader, -1));
                    break;
                case "priority":
                    position = checkElementOrder("priority", 15, position, false);
                    builder.priority(parseCodeableConcept("priority", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 16, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "episodeOfCare":
                    position = checkElementOrder("episodeOfCare", 17, position, true);
                    builder.episodeOfCare(parseReference("episodeOfCare", reader, episodeOfCareElementIndex++));
                    break;
                case "basedOn":
                    position = checkElementOrder("basedOn", 18, position, true);
                    builder.basedOn(parseReference("basedOn", reader, basedOnElementIndex++));
                    break;
                case "participant":
                    position = checkElementOrder("participant", 19, position, true);
                    builder.participant(parseEncounterParticipant("participant", reader, participantElementIndex++));
                    break;
                case "appointment":
                    position = checkElementOrder("appointment", 20, position, true);
                    builder.appointment(parseReference("appointment", reader, appointmentElementIndex++));
                    break;
                case "period":
                    position = checkElementOrder("period", 21, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                case "length":
                    position = checkElementOrder("length", 22, position, false);
                    builder.length((Duration) parseQuantity(Duration.builder(), "length", reader, -1));
                    break;
                case "reasonCode":
                    position = checkElementOrder("reasonCode", 23, position, true);
                    builder.reasonCode(parseCodeableConcept("reasonCode", reader, reasonCodeElementIndex++));
                    break;
                case "reasonReference":
                    position = checkElementOrder("reasonReference", 24, position, true);
                    builder.reasonReference(parseReference("reasonReference", reader, reasonReferenceElementIndex++));
                    break;
                case "diagnosis":
                    position = checkElementOrder("diagnosis", 25, position, true);
                    builder.diagnosis(parseEncounterDiagnosis("diagnosis", reader, diagnosisElementIndex++));
                    break;
                case "account":
                    position = checkElementOrder("account", 26, position, true);
                    builder.account(parseReference("account", reader, accountElementIndex++));
                    break;
                case "hospitalization":
                    position = checkElementOrder("hospitalization", 27, position, false);
                    builder.hospitalization(parseEncounterHospitalization("hospitalization", reader, -1));
                    break;
                case "location":
                    position = checkElementOrder("location", 28, position, true);
                    builder.location(parseEncounterLocation("location", reader, locationElementIndex++));
                    break;
                case "serviceProvider":
                    position = checkElementOrder("serviceProvider", 29, position, false);
                    builder.serviceProvider(parseReference("serviceProvider", reader, -1));
                    break;
                case "partOf":
                    position = checkElementOrder("partOf", 30, position, false);
                    builder.partOf(parseReference("partOf", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Encounter.ClassHistory parseEncounterClassHistory(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Encounter.ClassHistory.Builder builder = Encounter.ClassHistory.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "class":
                    position = checkElementOrder("class", 2, position, false);
                    builder.clazz(parseCoding("class", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 3, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Encounter.Diagnosis parseEncounterDiagnosis(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Encounter.Diagnosis.Builder builder = Encounter.Diagnosis.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "condition":
                    position = checkElementOrder("condition", 2, position, false);
                    builder.condition(parseReference("condition", reader, -1));
                    break;
                case "use":
                    position = checkElementOrder("use", 3, position, false);
                    builder.use(parseCodeableConcept("use", reader, -1));
                    break;
                case "rank":
                    position = checkElementOrder("rank", 4, position, false);
                    builder.rank((PositiveInt) parseInteger(PositiveInt.builder(), "rank", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Encounter.Hospitalization parseEncounterHospitalization(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Encounter.Hospitalization.Builder builder = Encounter.Hospitalization.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, dietPreferenceElementIndex = 0, specialCourtesyElementIndex = 0, specialArrangementElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "preAdmissionIdentifier":
                    position = checkElementOrder("preAdmissionIdentifier", 2, position, false);
                    builder.preAdmissionIdentifier(parseIdentifier("preAdmissionIdentifier", reader, -1));
                    break;
                case "origin":
                    position = checkElementOrder("origin", 3, position, false);
                    builder.origin(parseReference("origin", reader, -1));
                    break;
                case "admitSource":
                    position = checkElementOrder("admitSource", 4, position, false);
                    builder.admitSource(parseCodeableConcept("admitSource", reader, -1));
                    break;
                case "reAdmission":
                    position = checkElementOrder("reAdmission", 5, position, false);
                    builder.reAdmission(parseCodeableConcept("reAdmission", reader, -1));
                    break;
                case "dietPreference":
                    position = checkElementOrder("dietPreference", 6, position, true);
                    builder.dietPreference(parseCodeableConcept("dietPreference", reader, dietPreferenceElementIndex++));
                    break;
                case "specialCourtesy":
                    position = checkElementOrder("specialCourtesy", 7, position, true);
                    builder.specialCourtesy(parseCodeableConcept("specialCourtesy", reader, specialCourtesyElementIndex++));
                    break;
                case "specialArrangement":
                    position = checkElementOrder("specialArrangement", 8, position, true);
                    builder.specialArrangement(parseCodeableConcept("specialArrangement", reader, specialArrangementElementIndex++));
                    break;
                case "destination":
                    position = checkElementOrder("destination", 9, position, false);
                    builder.destination(parseReference("destination", reader, -1));
                    break;
                case "dischargeDisposition":
                    position = checkElementOrder("dischargeDisposition", 10, position, false);
                    builder.dischargeDisposition(parseCodeableConcept("dischargeDisposition", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Encounter.Location parseEncounterLocation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Encounter.Location.Builder builder = Encounter.Location.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "location":
                    position = checkElementOrder("location", 2, position, false);
                    builder.location(parseReference("location", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 3, position, false);
                    builder.status((EncounterLocationStatus) parseString(EncounterLocationStatus.builder(), "status", reader, -1));
                    break;
                case "physicalType":
                    position = checkElementOrder("physicalType", 4, position, false);
                    builder.physicalType(parseCodeableConcept("physicalType", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 5, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Encounter.Participant parseEncounterParticipant(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Encounter.Participant.Builder builder = Encounter.Participant.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, typeElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, true);
                    builder.type(parseCodeableConcept("type", reader, typeElementIndex++));
                    break;
                case "period":
                    position = checkElementOrder("period", 3, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                case "individual":
                    position = checkElementOrder("individual", 4, position, false);
                    builder.individual(parseReference("individual", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Encounter.StatusHistory parseEncounterStatusHistory(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Encounter.StatusHistory.Builder builder = Encounter.StatusHistory.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 2, position, false);
                    builder.status((EncounterStatus) parseString(EncounterStatus.builder(), "status", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 3, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Endpoint parseEndpoint(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Endpoint.Builder builder = Endpoint.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, contactElementIndex = 0, payloadTypeElementIndex = 0, payloadMimeTypeElementIndex = 0, headerElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((EndpointStatus) parseString(EndpointStatus.builder(), "status", reader, -1));
                    break;
                case "connectionType":
                    position = checkElementOrder("connectionType", 10, position, false);
                    builder.connectionType(parseCoding("connectionType", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 11, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "managingOrganization":
                    position = checkElementOrder("managingOrganization", 12, position, false);
                    builder.managingOrganization(parseReference("managingOrganization", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 13, position, true);
                    builder.contact(parseContactPoint("contact", reader, contactElementIndex++));
                    break;
                case "period":
                    position = checkElementOrder("period", 14, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                case "payloadType":
                    position = checkElementOrder("payloadType", 15, position, true);
                    builder.payloadType(parseCodeableConcept("payloadType", reader, payloadTypeElementIndex++));
                    break;
                case "payloadMimeType":
                    position = checkElementOrder("payloadMimeType", 16, position, true);
                    builder.payloadMimeType((Code) parseString(Code.builder(), "payloadMimeType", reader, payloadMimeTypeElementIndex++));
                    break;
                case "address":
                    position = checkElementOrder("address", 17, position, false);
                    builder.address((Url) parseUri(Url.builder(), "address", reader, -1));
                    break;
                case "header":
                    position = checkElementOrder("header", 18, position, true);
                    builder.header(parseString("header", reader, headerElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private EnrollmentRequest parseEnrollmentRequest(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        EnrollmentRequest.Builder builder = EnrollmentRequest.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((EnrollmentRequestStatus) parseString(EnrollmentRequestStatus.builder(), "status", reader, -1));
                    break;
                case "created":
                    position = checkElementOrder("created", 10, position, false);
                    builder.created(parseDateTime("created", reader, -1));
                    break;
                case "insurer":
                    position = checkElementOrder("insurer", 11, position, false);
                    builder.insurer(parseReference("insurer", reader, -1));
                    break;
                case "provider":
                    position = checkElementOrder("provider", 12, position, false);
                    builder.provider(parseReference("provider", reader, -1));
                    break;
                case "candidate":
                    position = checkElementOrder("candidate", 13, position, false);
                    builder.candidate(parseReference("candidate", reader, -1));
                    break;
                case "coverage":
                    position = checkElementOrder("coverage", 14, position, false);
                    builder.coverage(parseReference("coverage", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private EnrollmentResponse parseEnrollmentResponse(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        EnrollmentResponse.Builder builder = EnrollmentResponse.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((EnrollmentResponseStatus) parseString(EnrollmentResponseStatus.builder(), "status", reader, -1));
                    break;
                case "request":
                    position = checkElementOrder("request", 10, position, false);
                    builder.request(parseReference("request", reader, -1));
                    break;
                case "outcome":
                    position = checkElementOrder("outcome", 11, position, false);
                    builder.outcome((RemittanceOutcome) parseString(RemittanceOutcome.builder(), "outcome", reader, -1));
                    break;
                case "disposition":
                    position = checkElementOrder("disposition", 12, position, false);
                    builder.disposition(parseString("disposition", reader, -1));
                    break;
                case "created":
                    position = checkElementOrder("created", 13, position, false);
                    builder.created(parseDateTime("created", reader, -1));
                    break;
                case "organization":
                    position = checkElementOrder("organization", 14, position, false);
                    builder.organization(parseReference("organization", reader, -1));
                    break;
                case "requestProvider":
                    position = checkElementOrder("requestProvider", 15, position, false);
                    builder.requestProvider(parseReference("requestProvider", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private EpisodeOfCare parseEpisodeOfCare(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        EpisodeOfCare.Builder builder = EpisodeOfCare.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, statusHistoryElementIndex = 0, typeElementIndex = 0, diagnosisElementIndex = 0, referralRequestElementIndex = 0, teamElementIndex = 0, accountElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((EpisodeOfCareStatus) parseString(EpisodeOfCareStatus.builder(), "status", reader, -1));
                    break;
                case "statusHistory":
                    position = checkElementOrder("statusHistory", 10, position, true);
                    builder.statusHistory(parseEpisodeOfCareStatusHistory("statusHistory", reader, statusHistoryElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 11, position, true);
                    builder.type(parseCodeableConcept("type", reader, typeElementIndex++));
                    break;
                case "diagnosis":
                    position = checkElementOrder("diagnosis", 12, position, true);
                    builder.diagnosis(parseEpisodeOfCareDiagnosis("diagnosis", reader, diagnosisElementIndex++));
                    break;
                case "patient":
                    position = checkElementOrder("patient", 13, position, false);
                    builder.patient(parseReference("patient", reader, -1));
                    break;
                case "managingOrganization":
                    position = checkElementOrder("managingOrganization", 14, position, false);
                    builder.managingOrganization(parseReference("managingOrganization", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 15, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                case "referralRequest":
                    position = checkElementOrder("referralRequest", 16, position, true);
                    builder.referralRequest(parseReference("referralRequest", reader, referralRequestElementIndex++));
                    break;
                case "careManager":
                    position = checkElementOrder("careManager", 17, position, false);
                    builder.careManager(parseReference("careManager", reader, -1));
                    break;
                case "team":
                    position = checkElementOrder("team", 18, position, true);
                    builder.team(parseReference("team", reader, teamElementIndex++));
                    break;
                case "account":
                    position = checkElementOrder("account", 19, position, true);
                    builder.account(parseReference("account", reader, accountElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private EpisodeOfCare.Diagnosis parseEpisodeOfCareDiagnosis(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        EpisodeOfCare.Diagnosis.Builder builder = EpisodeOfCare.Diagnosis.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "condition":
                    position = checkElementOrder("condition", 2, position, false);
                    builder.condition(parseReference("condition", reader, -1));
                    break;
                case "role":
                    position = checkElementOrder("role", 3, position, false);
                    builder.role(parseCodeableConcept("role", reader, -1));
                    break;
                case "rank":
                    position = checkElementOrder("rank", 4, position, false);
                    builder.rank((PositiveInt) parseInteger(PositiveInt.builder(), "rank", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private EpisodeOfCare.StatusHistory parseEpisodeOfCareStatusHistory(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        EpisodeOfCare.StatusHistory.Builder builder = EpisodeOfCare.StatusHistory.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 2, position, false);
                    builder.status((EpisodeOfCareStatus) parseString(EpisodeOfCareStatus.builder(), "status", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 3, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private EventDefinition parseEventDefinition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        EventDefinition.Builder builder = EventDefinition.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, contactElementIndex = 0, useContextElementIndex = 0, jurisdictionElementIndex = 0, topicElementIndex = 0, authorElementIndex = 0, editorElementIndex = 0, reviewerElementIndex = 0, endorserElementIndex = 0, relatedArtifactElementIndex = 0, triggerElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 10, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 11, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 12, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "subtitle":
                    position = checkElementOrder("subtitle", 13, position, false);
                    builder.subtitle(parseString("subtitle", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 14, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 15, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "subjectCodeableConcept":
                    position = checkElementOrder("subject[x]", 16, position, false);
                    builder.subject(parseCodeableConcept("subjectCodeableConcept", reader, -1));
                    break;
                case "subjectReference":
                    position = checkElementOrder("subject[x]", 16, position, false);
                    builder.subject(parseReference("subjectReference", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 17, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 18, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 19, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 20, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 21, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 22, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 23, position, false);
                    builder.purpose((Markdown) parseString(Markdown.builder(), "purpose", reader, -1));
                    break;
                case "usage":
                    position = checkElementOrder("usage", 24, position, false);
                    builder.usage(parseString("usage", reader, -1));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 25, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                case "approvalDate":
                    position = checkElementOrder("approvalDate", 26, position, false);
                    builder.approvalDate(parseDate("approvalDate", reader, -1));
                    break;
                case "lastReviewDate":
                    position = checkElementOrder("lastReviewDate", 27, position, false);
                    builder.lastReviewDate(parseDate("lastReviewDate", reader, -1));
                    break;
                case "effectivePeriod":
                    position = checkElementOrder("effectivePeriod", 28, position, false);
                    builder.effectivePeriod(parsePeriod("effectivePeriod", reader, -1));
                    break;
                case "topic":
                    position = checkElementOrder("topic", 29, position, true);
                    builder.topic(parseCodeableConcept("topic", reader, topicElementIndex++));
                    break;
                case "author":
                    position = checkElementOrder("author", 30, position, true);
                    builder.author(parseContactDetail("author", reader, authorElementIndex++));
                    break;
                case "editor":
                    position = checkElementOrder("editor", 31, position, true);
                    builder.editor(parseContactDetail("editor", reader, editorElementIndex++));
                    break;
                case "reviewer":
                    position = checkElementOrder("reviewer", 32, position, true);
                    builder.reviewer(parseContactDetail("reviewer", reader, reviewerElementIndex++));
                    break;
                case "endorser":
                    position = checkElementOrder("endorser", 33, position, true);
                    builder.endorser(parseContactDetail("endorser", reader, endorserElementIndex++));
                    break;
                case "relatedArtifact":
                    position = checkElementOrder("relatedArtifact", 34, position, true);
                    builder.relatedArtifact(parseRelatedArtifact("relatedArtifact", reader, relatedArtifactElementIndex++));
                    break;
                case "trigger":
                    position = checkElementOrder("trigger", 35, position, true);
                    builder.trigger(parseTriggerDefinition("trigger", reader, triggerElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Evidence parseEvidence(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Evidence.Builder builder = Evidence.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, useContextElementIndex = 0, contactElementIndex = 0, authorElementIndex = 0, editorElementIndex = 0, reviewerElementIndex = 0, endorserElementIndex = 0, relatedArtifactElementIndex = 0, noteElementIndex = 0, variableDefinitionElementIndex = 0, statisticElementIndex = 0, certaintyElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 10, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 11, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "citeAsReference":
                    position = checkElementOrder("citeAs[x]", 12, position, false);
                    builder.citeAs(parseReference("citeAsReference", reader, -1));
                    break;
                case "citeAsMarkdown":
                    position = checkElementOrder("citeAs[x]", 12, position, false);
                    builder.citeAs((Markdown) parseString(Markdown.builder(), "citeAsMarkdown", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 13, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 14, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 15, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "approvalDate":
                    position = checkElementOrder("approvalDate", 16, position, false);
                    builder.approvalDate(parseDate("approvalDate", reader, -1));
                    break;
                case "lastReviewDate":
                    position = checkElementOrder("lastReviewDate", 17, position, false);
                    builder.lastReviewDate(parseDate("lastReviewDate", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 18, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 19, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "author":
                    position = checkElementOrder("author", 20, position, true);
                    builder.author(parseContactDetail("author", reader, authorElementIndex++));
                    break;
                case "editor":
                    position = checkElementOrder("editor", 21, position, true);
                    builder.editor(parseContactDetail("editor", reader, editorElementIndex++));
                    break;
                case "reviewer":
                    position = checkElementOrder("reviewer", 22, position, true);
                    builder.reviewer(parseContactDetail("reviewer", reader, reviewerElementIndex++));
                    break;
                case "endorser":
                    position = checkElementOrder("endorser", 23, position, true);
                    builder.endorser(parseContactDetail("endorser", reader, endorserElementIndex++));
                    break;
                case "relatedArtifact":
                    position = checkElementOrder("relatedArtifact", 24, position, true);
                    builder.relatedArtifact(parseRelatedArtifact("relatedArtifact", reader, relatedArtifactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 25, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "assertion":
                    position = checkElementOrder("assertion", 26, position, false);
                    builder.assertion((Markdown) parseString(Markdown.builder(), "assertion", reader, -1));
                    break;
                case "note":
                    position = checkElementOrder("note", 27, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "variableDefinition":
                    position = checkElementOrder("variableDefinition", 28, position, true);
                    builder.variableDefinition(parseEvidenceVariableDefinition("variableDefinition", reader, variableDefinitionElementIndex++));
                    break;
                case "synthesisType":
                    position = checkElementOrder("synthesisType", 29, position, false);
                    builder.synthesisType(parseCodeableConcept("synthesisType", reader, -1));
                    break;
                case "studyType":
                    position = checkElementOrder("studyType", 30, position, false);
                    builder.studyType(parseCodeableConcept("studyType", reader, -1));
                    break;
                case "statistic":
                    position = checkElementOrder("statistic", 31, position, true);
                    builder.statistic(parseEvidenceStatistic("statistic", reader, statisticElementIndex++));
                    break;
                case "certainty":
                    position = checkElementOrder("certainty", 32, position, true);
                    builder.certainty(parseEvidenceCertainty("certainty", reader, certaintyElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Evidence.Certainty parseEvidenceCertainty(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Evidence.Certainty.Builder builder = Evidence.Certainty.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, noteElementIndex = 0, subcomponentElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 2, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "note":
                    position = checkElementOrder("note", 3, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 4, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "rating":
                    position = checkElementOrder("rating", 5, position, false);
                    builder.rating(parseCodeableConcept("rating", reader, -1));
                    break;
                case "rater":
                    position = checkElementOrder("rater", 6, position, false);
                    builder.rater(parseString("rater", reader, -1));
                    break;
                case "subcomponent":
                    position = checkElementOrder("subcomponent", 7, position, true);
                    builder.subcomponent(parseEvidenceCertainty("subcomponent", reader, subcomponentElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Evidence.Statistic parseEvidenceStatistic(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Evidence.Statistic.Builder builder = Evidence.Statistic.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, noteElementIndex = 0, attributeEstimateElementIndex = 0, modelCharacteristicElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 2, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "note":
                    position = checkElementOrder("note", 3, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "statisticType":
                    position = checkElementOrder("statisticType", 4, position, false);
                    builder.statisticType(parseCodeableConcept("statisticType", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 5, position, false);
                    builder.category(parseCodeableConcept("category", reader, -1));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 6, position, false);
                    builder.quantity(parseQuantity("quantity", reader, -1));
                    break;
                case "numberOfEvents":
                    position = checkElementOrder("numberOfEvents", 7, position, false);
                    builder.numberOfEvents((UnsignedInt) parseInteger(UnsignedInt.builder(), "numberOfEvents", reader, -1));
                    break;
                case "numberAffected":
                    position = checkElementOrder("numberAffected", 8, position, false);
                    builder.numberAffected((UnsignedInt) parseInteger(UnsignedInt.builder(), "numberAffected", reader, -1));
                    break;
                case "sampleSize":
                    position = checkElementOrder("sampleSize", 9, position, false);
                    builder.sampleSize(parseEvidenceStatisticSampleSize("sampleSize", reader, -1));
                    break;
                case "attributeEstimate":
                    position = checkElementOrder("attributeEstimate", 10, position, true);
                    builder.attributeEstimate(parseEvidenceStatisticAttributeEstimate("attributeEstimate", reader, attributeEstimateElementIndex++));
                    break;
                case "modelCharacteristic":
                    position = checkElementOrder("modelCharacteristic", 11, position, true);
                    builder.modelCharacteristic(parseEvidenceStatisticModelCharacteristic("modelCharacteristic", reader, modelCharacteristicElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Evidence.Statistic.AttributeEstimate parseEvidenceStatisticAttributeEstimate(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Evidence.Statistic.AttributeEstimate.Builder builder = Evidence.Statistic.AttributeEstimate.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, noteElementIndex = 0, attributeEstimateElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 2, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "note":
                    position = checkElementOrder("note", 3, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 4, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 5, position, false);
                    builder.quantity(parseQuantity("quantity", reader, -1));
                    break;
                case "level":
                    position = checkElementOrder("level", 6, position, false);
                    builder.level(parseDecimal("level", reader, -1));
                    break;
                case "range":
                    position = checkElementOrder("range", 7, position, false);
                    builder.range(parseRange("range", reader, -1));
                    break;
                case "attributeEstimate":
                    position = checkElementOrder("attributeEstimate", 8, position, true);
                    builder.attributeEstimate(parseEvidenceStatisticAttributeEstimate("attributeEstimate", reader, attributeEstimateElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Evidence.Statistic.ModelCharacteristic parseEvidenceStatisticModelCharacteristic(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Evidence.Statistic.ModelCharacteristic.Builder builder = Evidence.Statistic.ModelCharacteristic.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, variableElementIndex = 0, attributeEstimateElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "value":
                    position = checkElementOrder("value", 3, position, false);
                    builder.value((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "value", reader, -1));
                    break;
                case "variable":
                    position = checkElementOrder("variable", 4, position, true);
                    builder.variable(parseEvidenceStatisticModelCharacteristicVariable("variable", reader, variableElementIndex++));
                    break;
                case "attributeEstimate":
                    position = checkElementOrder("attributeEstimate", 5, position, true);
                    builder.attributeEstimate(parseEvidenceStatisticAttributeEstimate("attributeEstimate", reader, attributeEstimateElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Evidence.Statistic.ModelCharacteristic.Variable parseEvidenceStatisticModelCharacteristicVariable(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Evidence.Statistic.ModelCharacteristic.Variable.Builder builder = Evidence.Statistic.ModelCharacteristic.Variable.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, valueCategoryElementIndex = 0, valueQuantityElementIndex = 0, valueRangeElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "variableDefinition":
                    position = checkElementOrder("variableDefinition", 2, position, false);
                    builder.variableDefinition(parseReference("variableDefinition", reader, -1));
                    break;
                case "handling":
                    position = checkElementOrder("handling", 3, position, false);
                    builder.handling((EvidenceVariableHandling) parseString(EvidenceVariableHandling.builder(), "handling", reader, -1));
                    break;
                case "valueCategory":
                    position = checkElementOrder("valueCategory", 4, position, true);
                    builder.valueCategory(parseCodeableConcept("valueCategory", reader, valueCategoryElementIndex++));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("valueQuantity", 5, position, true);
                    builder.valueQuantity(parseQuantity("valueQuantity", reader, valueQuantityElementIndex++));
                    break;
                case "valueRange":
                    position = checkElementOrder("valueRange", 6, position, true);
                    builder.valueRange(parseRange("valueRange", reader, valueRangeElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Evidence.Statistic.SampleSize parseEvidenceStatisticSampleSize(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Evidence.Statistic.SampleSize.Builder builder = Evidence.Statistic.SampleSize.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, noteElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 2, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "note":
                    position = checkElementOrder("note", 3, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "numberOfStudies":
                    position = checkElementOrder("numberOfStudies", 4, position, false);
                    builder.numberOfStudies((UnsignedInt) parseInteger(UnsignedInt.builder(), "numberOfStudies", reader, -1));
                    break;
                case "numberOfParticipants":
                    position = checkElementOrder("numberOfParticipants", 5, position, false);
                    builder.numberOfParticipants((UnsignedInt) parseInteger(UnsignedInt.builder(), "numberOfParticipants", reader, -1));
                    break;
                case "knownDataCount":
                    position = checkElementOrder("knownDataCount", 6, position, false);
                    builder.knownDataCount((UnsignedInt) parseInteger(UnsignedInt.builder(), "knownDataCount", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Evidence.VariableDefinition parseEvidenceVariableDefinition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Evidence.VariableDefinition.Builder builder = Evidence.VariableDefinition.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, noteElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 2, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "note":
                    position = checkElementOrder("note", 3, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "variableRole":
                    position = checkElementOrder("variableRole", 4, position, false);
                    builder.variableRole(parseCodeableConcept("variableRole", reader, -1));
                    break;
                case "observed":
                    position = checkElementOrder("observed", 5, position, false);
                    builder.observed(parseReference("observed", reader, -1));
                    break;
                case "intended":
                    position = checkElementOrder("intended", 6, position, false);
                    builder.intended(parseReference("intended", reader, -1));
                    break;
                case "directnessMatch":
                    position = checkElementOrder("directnessMatch", 7, position, false);
                    builder.directnessMatch(parseCodeableConcept("directnessMatch", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private EvidenceReport parseEvidenceReport(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        EvidenceReport.Builder builder = EvidenceReport.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, useContextElementIndex = 0, identifierElementIndex = 0, relatedIdentifierElementIndex = 0, noteElementIndex = 0, relatedArtifactElementIndex = 0, contactElementIndex = 0, authorElementIndex = 0, editorElementIndex = 0, reviewerElementIndex = 0, endorserElementIndex = 0, relatesToElementIndex = 0, sectionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 10, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 11, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "relatedIdentifier":
                    position = checkElementOrder("relatedIdentifier", 12, position, true);
                    builder.relatedIdentifier(parseIdentifier("relatedIdentifier", reader, relatedIdentifierElementIndex++));
                    break;
                case "citeAsReference":
                    position = checkElementOrder("citeAs[x]", 13, position, false);
                    builder.citeAs(parseReference("citeAsReference", reader, -1));
                    break;
                case "citeAsMarkdown":
                    position = checkElementOrder("citeAs[x]", 13, position, false);
                    builder.citeAs((Markdown) parseString(Markdown.builder(), "citeAsMarkdown", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 14, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "note":
                    position = checkElementOrder("note", 15, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "relatedArtifact":
                    position = checkElementOrder("relatedArtifact", 16, position, true);
                    builder.relatedArtifact(parseRelatedArtifact("relatedArtifact", reader, relatedArtifactElementIndex++));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 17, position, false);
                    builder.subject(parseEvidenceReportSubject("subject", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 18, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 19, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "author":
                    position = checkElementOrder("author", 20, position, true);
                    builder.author(parseContactDetail("author", reader, authorElementIndex++));
                    break;
                case "editor":
                    position = checkElementOrder("editor", 21, position, true);
                    builder.editor(parseContactDetail("editor", reader, editorElementIndex++));
                    break;
                case "reviewer":
                    position = checkElementOrder("reviewer", 22, position, true);
                    builder.reviewer(parseContactDetail("reviewer", reader, reviewerElementIndex++));
                    break;
                case "endorser":
                    position = checkElementOrder("endorser", 23, position, true);
                    builder.endorser(parseContactDetail("endorser", reader, endorserElementIndex++));
                    break;
                case "relatesTo":
                    position = checkElementOrder("relatesTo", 24, position, true);
                    builder.relatesTo(parseEvidenceReportRelatesTo("relatesTo", reader, relatesToElementIndex++));
                    break;
                case "section":
                    position = checkElementOrder("section", 25, position, true);
                    builder.section(parseEvidenceReportSection("section", reader, sectionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private EvidenceReport.RelatesTo parseEvidenceReportRelatesTo(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        EvidenceReport.RelatesTo.Builder builder = EvidenceReport.RelatesTo.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code((ReportRelationshipType) parseString(ReportRelationshipType.builder(), "code", reader, -1));
                    break;
                case "targetIdentifier":
                    position = checkElementOrder("target[x]", 3, position, false);
                    builder.target(parseIdentifier("targetIdentifier", reader, -1));
                    break;
                case "targetReference":
                    position = checkElementOrder("target[x]", 3, position, false);
                    builder.target(parseReference("targetReference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private EvidenceReport.Section parseEvidenceReportSection(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        EvidenceReport.Section.Builder builder = EvidenceReport.Section.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, authorElementIndex = 0, entryClassifierElementIndex = 0, entryReferenceElementIndex = 0, entryQuantityElementIndex = 0, sectionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "title":
                    position = checkElementOrder("title", 2, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "focus":
                    position = checkElementOrder("focus", 3, position, false);
                    builder.focus(parseCodeableConcept("focus", reader, -1));
                    break;
                case "focusReference":
                    position = checkElementOrder("focusReference", 4, position, false);
                    builder.focusReference(parseReference("focusReference", reader, -1));
                    break;
                case "author":
                    position = checkElementOrder("author", 5, position, true);
                    builder.author(parseReference("author", reader, authorElementIndex++));
                    break;
                case "text":
                    position = checkElementOrder("text", 6, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "mode":
                    position = checkElementOrder("mode", 7, position, false);
                    builder.mode((SectionMode) parseString(SectionMode.builder(), "mode", reader, -1));
                    break;
                case "orderedBy":
                    position = checkElementOrder("orderedBy", 8, position, false);
                    builder.orderedBy(parseCodeableConcept("orderedBy", reader, -1));
                    break;
                case "entryClassifier":
                    position = checkElementOrder("entryClassifier", 9, position, true);
                    builder.entryClassifier(parseCodeableConcept("entryClassifier", reader, entryClassifierElementIndex++));
                    break;
                case "entryReference":
                    position = checkElementOrder("entryReference", 10, position, true);
                    builder.entryReference(parseReference("entryReference", reader, entryReferenceElementIndex++));
                    break;
                case "entryQuantity":
                    position = checkElementOrder("entryQuantity", 11, position, true);
                    builder.entryQuantity(parseQuantity("entryQuantity", reader, entryQuantityElementIndex++));
                    break;
                case "emptyReason":
                    position = checkElementOrder("emptyReason", 12, position, false);
                    builder.emptyReason(parseCodeableConcept("emptyReason", reader, -1));
                    break;
                case "section":
                    position = checkElementOrder("section", 13, position, true);
                    builder.section(parseEvidenceReportSection("section", reader, sectionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private EvidenceReport.Subject parseEvidenceReportSubject(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        EvidenceReport.Subject.Builder builder = EvidenceReport.Subject.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, characteristicElementIndex = 0, noteElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "characteristic":
                    position = checkElementOrder("characteristic", 2, position, true);
                    builder.characteristic(parseEvidenceReportSubjectCharacteristic("characteristic", reader, characteristicElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 3, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private EvidenceReport.Subject.Characteristic parseEvidenceReportSubjectCharacteristic(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        EvidenceReport.Subject.Characteristic.Builder builder = EvidenceReport.Subject.Characteristic.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "valueReference":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseReference("valueReference", reader, -1));
                    break;
                case "valueCodeableConcept":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCodeableConcept("valueCodeableConcept", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueRange":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRange("valueRange", reader, -1));
                    break;
                case "exclude":
                    position = checkElementOrder("exclude", 4, position, false);
                    builder.exclude(parseBoolean("exclude", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 5, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private EvidenceVariable parseEvidenceVariable(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        EvidenceVariable.Builder builder = EvidenceVariable.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, noteElementIndex = 0, useContextElementIndex = 0, contactElementIndex = 0, authorElementIndex = 0, editorElementIndex = 0, reviewerElementIndex = 0, endorserElementIndex = 0, relatedArtifactElementIndex = 0, characteristicElementIndex = 0, categoryElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 10, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 11, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 12, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "shortTitle":
                    position = checkElementOrder("shortTitle", 13, position, false);
                    builder.shortTitle(parseString("shortTitle", reader, -1));
                    break;
                case "subtitle":
                    position = checkElementOrder("subtitle", 14, position, false);
                    builder.subtitle(parseString("subtitle", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 15, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 16, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 17, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "note":
                    position = checkElementOrder("note", 18, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 19, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 20, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 21, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "author":
                    position = checkElementOrder("author", 22, position, true);
                    builder.author(parseContactDetail("author", reader, authorElementIndex++));
                    break;
                case "editor":
                    position = checkElementOrder("editor", 23, position, true);
                    builder.editor(parseContactDetail("editor", reader, editorElementIndex++));
                    break;
                case "reviewer":
                    position = checkElementOrder("reviewer", 24, position, true);
                    builder.reviewer(parseContactDetail("reviewer", reader, reviewerElementIndex++));
                    break;
                case "endorser":
                    position = checkElementOrder("endorser", 25, position, true);
                    builder.endorser(parseContactDetail("endorser", reader, endorserElementIndex++));
                    break;
                case "relatedArtifact":
                    position = checkElementOrder("relatedArtifact", 26, position, true);
                    builder.relatedArtifact(parseRelatedArtifact("relatedArtifact", reader, relatedArtifactElementIndex++));
                    break;
                case "actual":
                    position = checkElementOrder("actual", 27, position, false);
                    builder.actual(parseBoolean("actual", reader, -1));
                    break;
                case "characteristicCombination":
                    position = checkElementOrder("characteristicCombination", 28, position, false);
                    builder.characteristicCombination((CharacteristicCombination) parseString(CharacteristicCombination.builder(), "characteristicCombination", reader, -1));
                    break;
                case "characteristic":
                    position = checkElementOrder("characteristic", 29, position, true);
                    builder.characteristic(parseEvidenceVariableCharacteristic("characteristic", reader, characteristicElementIndex++));
                    break;
                case "handling":
                    position = checkElementOrder("handling", 30, position, false);
                    builder.handling((EvidenceVariableHandling) parseString(EvidenceVariableHandling.builder(), "handling", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 31, position, true);
                    builder.category(parseEvidenceVariableCategory("category", reader, categoryElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private EvidenceVariable.Category parseEvidenceVariableCategory(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        EvidenceVariable.Category.Builder builder = EvidenceVariable.Category.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "valueCodeableConcept":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCodeableConcept("valueCodeableConcept", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueRange":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRange("valueRange", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private EvidenceVariable.Characteristic parseEvidenceVariableCharacteristic(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        EvidenceVariable.Characteristic.Builder builder = EvidenceVariable.Characteristic.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 2, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "definitionReference":
                    position = checkElementOrder("definition[x]", 3, position, false);
                    builder.definition(parseReference("definitionReference", reader, -1));
                    break;
                case "definitionCanonical":
                    position = checkElementOrder("definition[x]", 3, position, false);
                    builder.definition((Canonical) parseUri(Canonical.builder(), "definitionCanonical", reader, -1));
                    break;
                case "definitionCodeableConcept":
                    position = checkElementOrder("definition[x]", 3, position, false);
                    builder.definition(parseCodeableConcept("definitionCodeableConcept", reader, -1));
                    break;
                case "definitionExpression":
                    position = checkElementOrder("definition[x]", 3, position, false);
                    builder.definition(parseExpression("definitionExpression", reader, -1));
                    break;
                case "method":
                    position = checkElementOrder("method", 4, position, false);
                    builder.method(parseCodeableConcept("method", reader, -1));
                    break;
                case "device":
                    position = checkElementOrder("device", 5, position, false);
                    builder.device(parseReference("device", reader, -1));
                    break;
                case "exclude":
                    position = checkElementOrder("exclude", 6, position, false);
                    builder.exclude(parseBoolean("exclude", reader, -1));
                    break;
                case "timeFromStart":
                    position = checkElementOrder("timeFromStart", 7, position, false);
                    builder.timeFromStart(parseEvidenceVariableCharacteristicTimeFromStart("timeFromStart", reader, -1));
                    break;
                case "groupMeasure":
                    position = checkElementOrder("groupMeasure", 8, position, false);
                    builder.groupMeasure((GroupMeasure) parseString(GroupMeasure.builder(), "groupMeasure", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private EvidenceVariable.Characteristic.TimeFromStart parseEvidenceVariableCharacteristicTimeFromStart(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        EvidenceVariable.Characteristic.TimeFromStart.Builder builder = EvidenceVariable.Characteristic.TimeFromStart.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, noteElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 2, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 3, position, false);
                    builder.quantity(parseQuantity("quantity", reader, -1));
                    break;
                case "range":
                    position = checkElementOrder("range", 4, position, false);
                    builder.range(parseRange("range", reader, -1));
                    break;
                case "note":
                    position = checkElementOrder("note", 5, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExampleScenario parseExampleScenario(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExampleScenario.Builder builder = ExampleScenario.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, contactElementIndex = 0, useContextElementIndex = 0, jurisdictionElementIndex = 0, actorElementIndex = 0, instanceElementIndex = 0, processElementIndex = 0, workflowElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 10, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 11, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 12, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 13, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 14, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 15, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 16, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 17, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 18, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 19, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 20, position, false);
                    builder.purpose((Markdown) parseString(Markdown.builder(), "purpose", reader, -1));
                    break;
                case "actor":
                    position = checkElementOrder("actor", 21, position, true);
                    builder.actor(parseExampleScenarioActor("actor", reader, actorElementIndex++));
                    break;
                case "instance":
                    position = checkElementOrder("instance", 22, position, true);
                    builder.instance(parseExampleScenarioInstance("instance", reader, instanceElementIndex++));
                    break;
                case "process":
                    position = checkElementOrder("process", 23, position, true);
                    builder.process(parseExampleScenarioProcess("process", reader, processElementIndex++));
                    break;
                case "workflow":
                    position = checkElementOrder("workflow", 24, position, true);
                    builder.workflow((Canonical) parseUri(Canonical.builder(), "workflow", reader, workflowElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExampleScenario.Actor parseExampleScenarioActor(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExampleScenario.Actor.Builder builder = ExampleScenario.Actor.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "actorId":
                    position = checkElementOrder("actorId", 2, position, false);
                    builder.actorId(parseString("actorId", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type((ExampleScenarioActorType) parseString(ExampleScenarioActorType.builder(), "type", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 4, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 5, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExampleScenario.Instance parseExampleScenarioInstance(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExampleScenario.Instance.Builder builder = ExampleScenario.Instance.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, versionElementIndex = 0, containedInstanceElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "resourceId":
                    position = checkElementOrder("resourceId", 2, position, false);
                    builder.resourceId(parseString("resourceId", reader, -1));
                    break;
                case "resourceType":
                    position = checkElementOrder("resourceType", 3, position, false);
                    builder.resourceType((ResourceTypeCode) parseString(ResourceTypeCode.builder(), "resourceType", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 4, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 5, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "version":
                    position = checkElementOrder("version", 6, position, true);
                    builder.version(parseExampleScenarioInstanceVersion("version", reader, versionElementIndex++));
                    break;
                case "containedInstance":
                    position = checkElementOrder("containedInstance", 7, position, true);
                    builder.containedInstance(parseExampleScenarioInstanceContainedInstance("containedInstance", reader, containedInstanceElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExampleScenario.Instance.ContainedInstance parseExampleScenarioInstanceContainedInstance(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExampleScenario.Instance.ContainedInstance.Builder builder = ExampleScenario.Instance.ContainedInstance.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "resourceId":
                    position = checkElementOrder("resourceId", 2, position, false);
                    builder.resourceId(parseString("resourceId", reader, -1));
                    break;
                case "versionId":
                    position = checkElementOrder("versionId", 3, position, false);
                    builder.versionId(parseString("versionId", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExampleScenario.Instance.Version parseExampleScenarioInstanceVersion(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExampleScenario.Instance.Version.Builder builder = ExampleScenario.Instance.Version.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "versionId":
                    position = checkElementOrder("versionId", 2, position, false);
                    builder.versionId(parseString("versionId", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 3, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExampleScenario.Process parseExampleScenarioProcess(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExampleScenario.Process.Builder builder = ExampleScenario.Process.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, stepElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "title":
                    position = checkElementOrder("title", 2, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 3, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "preConditions":
                    position = checkElementOrder("preConditions", 4, position, false);
                    builder.preConditions((Markdown) parseString(Markdown.builder(), "preConditions", reader, -1));
                    break;
                case "postConditions":
                    position = checkElementOrder("postConditions", 5, position, false);
                    builder.postConditions((Markdown) parseString(Markdown.builder(), "postConditions", reader, -1));
                    break;
                case "step":
                    position = checkElementOrder("step", 6, position, true);
                    builder.step(parseExampleScenarioProcessStep("step", reader, stepElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExampleScenario.Process.Step parseExampleScenarioProcessStep(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExampleScenario.Process.Step.Builder builder = ExampleScenario.Process.Step.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, processElementIndex = 0, alternativeElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "process":
                    position = checkElementOrder("process", 2, position, true);
                    builder.process(parseExampleScenarioProcess("process", reader, processElementIndex++));
                    break;
                case "pause":
                    position = checkElementOrder("pause", 3, position, false);
                    builder.pause(parseBoolean("pause", reader, -1));
                    break;
                case "operation":
                    position = checkElementOrder("operation", 4, position, false);
                    builder.operation(parseExampleScenarioProcessStepOperation("operation", reader, -1));
                    break;
                case "alternative":
                    position = checkElementOrder("alternative", 5, position, true);
                    builder.alternative(parseExampleScenarioProcessStepAlternative("alternative", reader, alternativeElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExampleScenario.Process.Step.Alternative parseExampleScenarioProcessStepAlternative(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExampleScenario.Process.Step.Alternative.Builder builder = ExampleScenario.Process.Step.Alternative.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, stepElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "title":
                    position = checkElementOrder("title", 2, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 3, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "step":
                    position = checkElementOrder("step", 4, position, true);
                    builder.step(parseExampleScenarioProcessStep("step", reader, stepElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExampleScenario.Process.Step.Operation parseExampleScenarioProcessStepOperation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExampleScenario.Process.Step.Operation.Builder builder = ExampleScenario.Process.Step.Operation.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "number":
                    position = checkElementOrder("number", 2, position, false);
                    builder.number(parseString("number", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type(parseString("type", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 4, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "initiator":
                    position = checkElementOrder("initiator", 5, position, false);
                    builder.initiator(parseString("initiator", reader, -1));
                    break;
                case "receiver":
                    position = checkElementOrder("receiver", 6, position, false);
                    builder.receiver(parseString("receiver", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 7, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "initiatorActive":
                    position = checkElementOrder("initiatorActive", 8, position, false);
                    builder.initiatorActive(parseBoolean("initiatorActive", reader, -1));
                    break;
                case "receiverActive":
                    position = checkElementOrder("receiverActive", 9, position, false);
                    builder.receiverActive(parseBoolean("receiverActive", reader, -1));
                    break;
                case "request":
                    position = checkElementOrder("request", 10, position, false);
                    builder.request(parseExampleScenarioInstanceContainedInstance("request", reader, -1));
                    break;
                case "response":
                    position = checkElementOrder("response", 11, position, false);
                    builder.response(parseExampleScenarioInstanceContainedInstance("response", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExplanationOfBenefit parseExplanationOfBenefit(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExplanationOfBenefit.Builder builder = ExplanationOfBenefit.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, relatedElementIndex = 0, preAuthRefElementIndex = 0, preAuthRefPeriodElementIndex = 0, careTeamElementIndex = 0, supportingInfoElementIndex = 0, diagnosisElementIndex = 0, procedureElementIndex = 0, insuranceElementIndex = 0, itemElementIndex = 0, addItemElementIndex = 0, adjudicationElementIndex = 0, totalElementIndex = 0, processNoteElementIndex = 0, benefitBalanceElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((ExplanationOfBenefitStatus) parseString(ExplanationOfBenefitStatus.builder(), "status", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 10, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "subType":
                    position = checkElementOrder("subType", 11, position, false);
                    builder.subType(parseCodeableConcept("subType", reader, -1));
                    break;
                case "use":
                    position = checkElementOrder("use", 12, position, false);
                    builder.use((Use) parseString(Use.builder(), "use", reader, -1));
                    break;
                case "patient":
                    position = checkElementOrder("patient", 13, position, false);
                    builder.patient(parseReference("patient", reader, -1));
                    break;
                case "billablePeriod":
                    position = checkElementOrder("billablePeriod", 14, position, false);
                    builder.billablePeriod(parsePeriod("billablePeriod", reader, -1));
                    break;
                case "created":
                    position = checkElementOrder("created", 15, position, false);
                    builder.created(parseDateTime("created", reader, -1));
                    break;
                case "enterer":
                    position = checkElementOrder("enterer", 16, position, false);
                    builder.enterer(parseReference("enterer", reader, -1));
                    break;
                case "insurer":
                    position = checkElementOrder("insurer", 17, position, false);
                    builder.insurer(parseReference("insurer", reader, -1));
                    break;
                case "provider":
                    position = checkElementOrder("provider", 18, position, false);
                    builder.provider(parseReference("provider", reader, -1));
                    break;
                case "priority":
                    position = checkElementOrder("priority", 19, position, false);
                    builder.priority(parseCodeableConcept("priority", reader, -1));
                    break;
                case "fundsReserveRequested":
                    position = checkElementOrder("fundsReserveRequested", 20, position, false);
                    builder.fundsReserveRequested(parseCodeableConcept("fundsReserveRequested", reader, -1));
                    break;
                case "fundsReserve":
                    position = checkElementOrder("fundsReserve", 21, position, false);
                    builder.fundsReserve(parseCodeableConcept("fundsReserve", reader, -1));
                    break;
                case "related":
                    position = checkElementOrder("related", 22, position, true);
                    builder.related(parseExplanationOfBenefitRelated("related", reader, relatedElementIndex++));
                    break;
                case "prescription":
                    position = checkElementOrder("prescription", 23, position, false);
                    builder.prescription(parseReference("prescription", reader, -1));
                    break;
                case "originalPrescription":
                    position = checkElementOrder("originalPrescription", 24, position, false);
                    builder.originalPrescription(parseReference("originalPrescription", reader, -1));
                    break;
                case "payee":
                    position = checkElementOrder("payee", 25, position, false);
                    builder.payee(parseExplanationOfBenefitPayee("payee", reader, -1));
                    break;
                case "referral":
                    position = checkElementOrder("referral", 26, position, false);
                    builder.referral(parseReference("referral", reader, -1));
                    break;
                case "facility":
                    position = checkElementOrder("facility", 27, position, false);
                    builder.facility(parseReference("facility", reader, -1));
                    break;
                case "claim":
                    position = checkElementOrder("claim", 28, position, false);
                    builder.claim(parseReference("claim", reader, -1));
                    break;
                case "claimResponse":
                    position = checkElementOrder("claimResponse", 29, position, false);
                    builder.claimResponse(parseReference("claimResponse", reader, -1));
                    break;
                case "outcome":
                    position = checkElementOrder("outcome", 30, position, false);
                    builder.outcome((RemittanceOutcome) parseString(RemittanceOutcome.builder(), "outcome", reader, -1));
                    break;
                case "disposition":
                    position = checkElementOrder("disposition", 31, position, false);
                    builder.disposition(parseString("disposition", reader, -1));
                    break;
                case "preAuthRef":
                    position = checkElementOrder("preAuthRef", 32, position, true);
                    builder.preAuthRef(parseString("preAuthRef", reader, preAuthRefElementIndex++));
                    break;
                case "preAuthRefPeriod":
                    position = checkElementOrder("preAuthRefPeriod", 33, position, true);
                    builder.preAuthRefPeriod(parsePeriod("preAuthRefPeriod", reader, preAuthRefPeriodElementIndex++));
                    break;
                case "careTeam":
                    position = checkElementOrder("careTeam", 34, position, true);
                    builder.careTeam(parseExplanationOfBenefitCareTeam("careTeam", reader, careTeamElementIndex++));
                    break;
                case "supportingInfo":
                    position = checkElementOrder("supportingInfo", 35, position, true);
                    builder.supportingInfo(parseExplanationOfBenefitSupportingInfo("supportingInfo", reader, supportingInfoElementIndex++));
                    break;
                case "diagnosis":
                    position = checkElementOrder("diagnosis", 36, position, true);
                    builder.diagnosis(parseExplanationOfBenefitDiagnosis("diagnosis", reader, diagnosisElementIndex++));
                    break;
                case "procedure":
                    position = checkElementOrder("procedure", 37, position, true);
                    builder.procedure(parseExplanationOfBenefitProcedure("procedure", reader, procedureElementIndex++));
                    break;
                case "precedence":
                    position = checkElementOrder("precedence", 38, position, false);
                    builder.precedence((PositiveInt) parseInteger(PositiveInt.builder(), "precedence", reader, -1));
                    break;
                case "insurance":
                    position = checkElementOrder("insurance", 39, position, true);
                    builder.insurance(parseExplanationOfBenefitInsurance("insurance", reader, insuranceElementIndex++));
                    break;
                case "accident":
                    position = checkElementOrder("accident", 40, position, false);
                    builder.accident(parseExplanationOfBenefitAccident("accident", reader, -1));
                    break;
                case "item":
                    position = checkElementOrder("item", 41, position, true);
                    builder.item(parseExplanationOfBenefitItem("item", reader, itemElementIndex++));
                    break;
                case "addItem":
                    position = checkElementOrder("addItem", 42, position, true);
                    builder.addItem(parseExplanationOfBenefitAddItem("addItem", reader, addItemElementIndex++));
                    break;
                case "adjudication":
                    position = checkElementOrder("adjudication", 43, position, true);
                    builder.adjudication(parseExplanationOfBenefitItemAdjudication("adjudication", reader, adjudicationElementIndex++));
                    break;
                case "total":
                    position = checkElementOrder("total", 44, position, true);
                    builder.total(parseExplanationOfBenefitTotal("total", reader, totalElementIndex++));
                    break;
                case "payment":
                    position = checkElementOrder("payment", 45, position, false);
                    builder.payment(parseExplanationOfBenefitPayment("payment", reader, -1));
                    break;
                case "formCode":
                    position = checkElementOrder("formCode", 46, position, false);
                    builder.formCode(parseCodeableConcept("formCode", reader, -1));
                    break;
                case "form":
                    position = checkElementOrder("form", 47, position, false);
                    builder.form(parseAttachment("form", reader, -1));
                    break;
                case "processNote":
                    position = checkElementOrder("processNote", 48, position, true);
                    builder.processNote(parseExplanationOfBenefitProcessNote("processNote", reader, processNoteElementIndex++));
                    break;
                case "benefitPeriod":
                    position = checkElementOrder("benefitPeriod", 49, position, false);
                    builder.benefitPeriod(parsePeriod("benefitPeriod", reader, -1));
                    break;
                case "benefitBalance":
                    position = checkElementOrder("benefitBalance", 50, position, true);
                    builder.benefitBalance(parseExplanationOfBenefitBenefitBalance("benefitBalance", reader, benefitBalanceElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExplanationOfBenefit.Accident parseExplanationOfBenefitAccident(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExplanationOfBenefit.Accident.Builder builder = ExplanationOfBenefit.Accident.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "date":
                    position = checkElementOrder("date", 2, position, false);
                    builder.date(parseDate("date", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "locationAddress":
                    position = checkElementOrder("location[x]", 4, position, false);
                    builder.location(parseAddress("locationAddress", reader, -1));
                    break;
                case "locationReference":
                    position = checkElementOrder("location[x]", 4, position, false);
                    builder.location(parseReference("locationReference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExplanationOfBenefit.AddItem parseExplanationOfBenefitAddItem(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExplanationOfBenefit.AddItem.Builder builder = ExplanationOfBenefit.AddItem.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, itemSequenceElementIndex = 0, detailSequenceElementIndex = 0, subDetailSequenceElementIndex = 0, providerElementIndex = 0, modifierElementIndex = 0, programCodeElementIndex = 0, subSiteElementIndex = 0, noteNumberElementIndex = 0, adjudicationElementIndex = 0, detailElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "itemSequence":
                    position = checkElementOrder("itemSequence", 2, position, true);
                    builder.itemSequence((PositiveInt) parseInteger(PositiveInt.builder(), "itemSequence", reader, itemSequenceElementIndex++));
                    break;
                case "detailSequence":
                    position = checkElementOrder("detailSequence", 3, position, true);
                    builder.detailSequence((PositiveInt) parseInteger(PositiveInt.builder(), "detailSequence", reader, detailSequenceElementIndex++));
                    break;
                case "subDetailSequence":
                    position = checkElementOrder("subDetailSequence", 4, position, true);
                    builder.subDetailSequence((PositiveInt) parseInteger(PositiveInt.builder(), "subDetailSequence", reader, subDetailSequenceElementIndex++));
                    break;
                case "provider":
                    position = checkElementOrder("provider", 5, position, true);
                    builder.provider(parseReference("provider", reader, providerElementIndex++));
                    break;
                case "productOrService":
                    position = checkElementOrder("productOrService", 6, position, false);
                    builder.productOrService(parseCodeableConcept("productOrService", reader, -1));
                    break;
                case "modifier":
                    position = checkElementOrder("modifier", 7, position, true);
                    builder.modifier(parseCodeableConcept("modifier", reader, modifierElementIndex++));
                    break;
                case "programCode":
                    position = checkElementOrder("programCode", 8, position, true);
                    builder.programCode(parseCodeableConcept("programCode", reader, programCodeElementIndex++));
                    break;
                case "servicedDate":
                    position = checkElementOrder("serviced[x]", 9, position, false);
                    builder.serviced(parseDate("servicedDate", reader, -1));
                    break;
                case "servicedPeriod":
                    position = checkElementOrder("serviced[x]", 9, position, false);
                    builder.serviced(parsePeriod("servicedPeriod", reader, -1));
                    break;
                case "locationCodeableConcept":
                    position = checkElementOrder("location[x]", 10, position, false);
                    builder.location(parseCodeableConcept("locationCodeableConcept", reader, -1));
                    break;
                case "locationAddress":
                    position = checkElementOrder("location[x]", 10, position, false);
                    builder.location(parseAddress("locationAddress", reader, -1));
                    break;
                case "locationReference":
                    position = checkElementOrder("location[x]", 10, position, false);
                    builder.location(parseReference("locationReference", reader, -1));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 11, position, false);
                    builder.quantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "quantity", reader, -1));
                    break;
                case "unitPrice":
                    position = checkElementOrder("unitPrice", 12, position, false);
                    builder.unitPrice(parseMoney("unitPrice", reader, -1));
                    break;
                case "factor":
                    position = checkElementOrder("factor", 13, position, false);
                    builder.factor(parseDecimal("factor", reader, -1));
                    break;
                case "net":
                    position = checkElementOrder("net", 14, position, false);
                    builder.net(parseMoney("net", reader, -1));
                    break;
                case "bodySite":
                    position = checkElementOrder("bodySite", 15, position, false);
                    builder.bodySite(parseCodeableConcept("bodySite", reader, -1));
                    break;
                case "subSite":
                    position = checkElementOrder("subSite", 16, position, true);
                    builder.subSite(parseCodeableConcept("subSite", reader, subSiteElementIndex++));
                    break;
                case "noteNumber":
                    position = checkElementOrder("noteNumber", 17, position, true);
                    builder.noteNumber((PositiveInt) parseInteger(PositiveInt.builder(), "noteNumber", reader, noteNumberElementIndex++));
                    break;
                case "adjudication":
                    position = checkElementOrder("adjudication", 18, position, true);
                    builder.adjudication(parseExplanationOfBenefitItemAdjudication("adjudication", reader, adjudicationElementIndex++));
                    break;
                case "detail":
                    position = checkElementOrder("detail", 19, position, true);
                    builder.detail(parseExplanationOfBenefitAddItemDetail("detail", reader, detailElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExplanationOfBenefit.AddItem.Detail parseExplanationOfBenefitAddItemDetail(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExplanationOfBenefit.AddItem.Detail.Builder builder = ExplanationOfBenefit.AddItem.Detail.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, modifierElementIndex = 0, noteNumberElementIndex = 0, adjudicationElementIndex = 0, subDetailElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "productOrService":
                    position = checkElementOrder("productOrService", 2, position, false);
                    builder.productOrService(parseCodeableConcept("productOrService", reader, -1));
                    break;
                case "modifier":
                    position = checkElementOrder("modifier", 3, position, true);
                    builder.modifier(parseCodeableConcept("modifier", reader, modifierElementIndex++));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 4, position, false);
                    builder.quantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "quantity", reader, -1));
                    break;
                case "unitPrice":
                    position = checkElementOrder("unitPrice", 5, position, false);
                    builder.unitPrice(parseMoney("unitPrice", reader, -1));
                    break;
                case "factor":
                    position = checkElementOrder("factor", 6, position, false);
                    builder.factor(parseDecimal("factor", reader, -1));
                    break;
                case "net":
                    position = checkElementOrder("net", 7, position, false);
                    builder.net(parseMoney("net", reader, -1));
                    break;
                case "noteNumber":
                    position = checkElementOrder("noteNumber", 8, position, true);
                    builder.noteNumber((PositiveInt) parseInteger(PositiveInt.builder(), "noteNumber", reader, noteNumberElementIndex++));
                    break;
                case "adjudication":
                    position = checkElementOrder("adjudication", 9, position, true);
                    builder.adjudication(parseExplanationOfBenefitItemAdjudication("adjudication", reader, adjudicationElementIndex++));
                    break;
                case "subDetail":
                    position = checkElementOrder("subDetail", 10, position, true);
                    builder.subDetail(parseExplanationOfBenefitAddItemDetailSubDetail("subDetail", reader, subDetailElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExplanationOfBenefit.AddItem.Detail.SubDetail parseExplanationOfBenefitAddItemDetailSubDetail(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExplanationOfBenefit.AddItem.Detail.SubDetail.Builder builder = ExplanationOfBenefit.AddItem.Detail.SubDetail.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, modifierElementIndex = 0, noteNumberElementIndex = 0, adjudicationElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "productOrService":
                    position = checkElementOrder("productOrService", 2, position, false);
                    builder.productOrService(parseCodeableConcept("productOrService", reader, -1));
                    break;
                case "modifier":
                    position = checkElementOrder("modifier", 3, position, true);
                    builder.modifier(parseCodeableConcept("modifier", reader, modifierElementIndex++));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 4, position, false);
                    builder.quantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "quantity", reader, -1));
                    break;
                case "unitPrice":
                    position = checkElementOrder("unitPrice", 5, position, false);
                    builder.unitPrice(parseMoney("unitPrice", reader, -1));
                    break;
                case "factor":
                    position = checkElementOrder("factor", 6, position, false);
                    builder.factor(parseDecimal("factor", reader, -1));
                    break;
                case "net":
                    position = checkElementOrder("net", 7, position, false);
                    builder.net(parseMoney("net", reader, -1));
                    break;
                case "noteNumber":
                    position = checkElementOrder("noteNumber", 8, position, true);
                    builder.noteNumber((PositiveInt) parseInteger(PositiveInt.builder(), "noteNumber", reader, noteNumberElementIndex++));
                    break;
                case "adjudication":
                    position = checkElementOrder("adjudication", 9, position, true);
                    builder.adjudication(parseExplanationOfBenefitItemAdjudication("adjudication", reader, adjudicationElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExplanationOfBenefit.BenefitBalance parseExplanationOfBenefitBenefitBalance(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExplanationOfBenefit.BenefitBalance.Builder builder = ExplanationOfBenefit.BenefitBalance.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, financialElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "category":
                    position = checkElementOrder("category", 2, position, false);
                    builder.category(parseCodeableConcept("category", reader, -1));
                    break;
                case "excluded":
                    position = checkElementOrder("excluded", 3, position, false);
                    builder.excluded(parseBoolean("excluded", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 4, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 5, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "network":
                    position = checkElementOrder("network", 6, position, false);
                    builder.network(parseCodeableConcept("network", reader, -1));
                    break;
                case "unit":
                    position = checkElementOrder("unit", 7, position, false);
                    builder.unit(parseCodeableConcept("unit", reader, -1));
                    break;
                case "term":
                    position = checkElementOrder("term", 8, position, false);
                    builder.term(parseCodeableConcept("term", reader, -1));
                    break;
                case "financial":
                    position = checkElementOrder("financial", 9, position, true);
                    builder.financial(parseExplanationOfBenefitBenefitBalanceFinancial("financial", reader, financialElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExplanationOfBenefit.BenefitBalance.Financial parseExplanationOfBenefitBenefitBalanceFinancial(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExplanationOfBenefit.BenefitBalance.Financial.Builder builder = ExplanationOfBenefit.BenefitBalance.Financial.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "allowedUnsignedInt":
                    position = checkElementOrder("allowed[x]", 3, position, false);
                    builder.allowed((UnsignedInt) parseInteger(UnsignedInt.builder(), "allowedUnsignedInt", reader, -1));
                    break;
                case "allowedString":
                    position = checkElementOrder("allowed[x]", 3, position, false);
                    builder.allowed(parseString("allowedString", reader, -1));
                    break;
                case "allowedMoney":
                    position = checkElementOrder("allowed[x]", 3, position, false);
                    builder.allowed(parseMoney("allowedMoney", reader, -1));
                    break;
                case "usedUnsignedInt":
                    position = checkElementOrder("used[x]", 4, position, false);
                    builder.used((UnsignedInt) parseInteger(UnsignedInt.builder(), "usedUnsignedInt", reader, -1));
                    break;
                case "usedMoney":
                    position = checkElementOrder("used[x]", 4, position, false);
                    builder.used(parseMoney("usedMoney", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExplanationOfBenefit.CareTeam parseExplanationOfBenefitCareTeam(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExplanationOfBenefit.CareTeam.Builder builder = ExplanationOfBenefit.CareTeam.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "sequence":
                    position = checkElementOrder("sequence", 2, position, false);
                    builder.sequence((PositiveInt) parseInteger(PositiveInt.builder(), "sequence", reader, -1));
                    break;
                case "provider":
                    position = checkElementOrder("provider", 3, position, false);
                    builder.provider(parseReference("provider", reader, -1));
                    break;
                case "responsible":
                    position = checkElementOrder("responsible", 4, position, false);
                    builder.responsible(parseBoolean("responsible", reader, -1));
                    break;
                case "role":
                    position = checkElementOrder("role", 5, position, false);
                    builder.role(parseCodeableConcept("role", reader, -1));
                    break;
                case "qualification":
                    position = checkElementOrder("qualification", 6, position, false);
                    builder.qualification(parseCodeableConcept("qualification", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExplanationOfBenefit.Diagnosis parseExplanationOfBenefitDiagnosis(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExplanationOfBenefit.Diagnosis.Builder builder = ExplanationOfBenefit.Diagnosis.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, typeElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "sequence":
                    position = checkElementOrder("sequence", 2, position, false);
                    builder.sequence((PositiveInt) parseInteger(PositiveInt.builder(), "sequence", reader, -1));
                    break;
                case "diagnosisCodeableConcept":
                    position = checkElementOrder("diagnosis[x]", 3, position, false);
                    builder.diagnosis(parseCodeableConcept("diagnosisCodeableConcept", reader, -1));
                    break;
                case "diagnosisReference":
                    position = checkElementOrder("diagnosis[x]", 3, position, false);
                    builder.diagnosis(parseReference("diagnosisReference", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 4, position, true);
                    builder.type(parseCodeableConcept("type", reader, typeElementIndex++));
                    break;
                case "onAdmission":
                    position = checkElementOrder("onAdmission", 5, position, false);
                    builder.onAdmission(parseCodeableConcept("onAdmission", reader, -1));
                    break;
                case "packageCode":
                    position = checkElementOrder("packageCode", 6, position, false);
                    builder.packageCode(parseCodeableConcept("packageCode", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExplanationOfBenefit.Insurance parseExplanationOfBenefitInsurance(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExplanationOfBenefit.Insurance.Builder builder = ExplanationOfBenefit.Insurance.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, preAuthRefElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "focal":
                    position = checkElementOrder("focal", 2, position, false);
                    builder.focal(parseBoolean("focal", reader, -1));
                    break;
                case "coverage":
                    position = checkElementOrder("coverage", 3, position, false);
                    builder.coverage(parseReference("coverage", reader, -1));
                    break;
                case "preAuthRef":
                    position = checkElementOrder("preAuthRef", 4, position, true);
                    builder.preAuthRef(parseString("preAuthRef", reader, preAuthRefElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExplanationOfBenefit.Item parseExplanationOfBenefitItem(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExplanationOfBenefit.Item.Builder builder = ExplanationOfBenefit.Item.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, careTeamSequenceElementIndex = 0, diagnosisSequenceElementIndex = 0, procedureSequenceElementIndex = 0, informationSequenceElementIndex = 0, modifierElementIndex = 0, programCodeElementIndex = 0, udiElementIndex = 0, subSiteElementIndex = 0, encounterElementIndex = 0, noteNumberElementIndex = 0, adjudicationElementIndex = 0, detailElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "sequence":
                    position = checkElementOrder("sequence", 2, position, false);
                    builder.sequence((PositiveInt) parseInteger(PositiveInt.builder(), "sequence", reader, -1));
                    break;
                case "careTeamSequence":
                    position = checkElementOrder("careTeamSequence", 3, position, true);
                    builder.careTeamSequence((PositiveInt) parseInteger(PositiveInt.builder(), "careTeamSequence", reader, careTeamSequenceElementIndex++));
                    break;
                case "diagnosisSequence":
                    position = checkElementOrder("diagnosisSequence", 4, position, true);
                    builder.diagnosisSequence((PositiveInt) parseInteger(PositiveInt.builder(), "diagnosisSequence", reader, diagnosisSequenceElementIndex++));
                    break;
                case "procedureSequence":
                    position = checkElementOrder("procedureSequence", 5, position, true);
                    builder.procedureSequence((PositiveInt) parseInteger(PositiveInt.builder(), "procedureSequence", reader, procedureSequenceElementIndex++));
                    break;
                case "informationSequence":
                    position = checkElementOrder("informationSequence", 6, position, true);
                    builder.informationSequence((PositiveInt) parseInteger(PositiveInt.builder(), "informationSequence", reader, informationSequenceElementIndex++));
                    break;
                case "revenue":
                    position = checkElementOrder("revenue", 7, position, false);
                    builder.revenue(parseCodeableConcept("revenue", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 8, position, false);
                    builder.category(parseCodeableConcept("category", reader, -1));
                    break;
                case "productOrService":
                    position = checkElementOrder("productOrService", 9, position, false);
                    builder.productOrService(parseCodeableConcept("productOrService", reader, -1));
                    break;
                case "modifier":
                    position = checkElementOrder("modifier", 10, position, true);
                    builder.modifier(parseCodeableConcept("modifier", reader, modifierElementIndex++));
                    break;
                case "programCode":
                    position = checkElementOrder("programCode", 11, position, true);
                    builder.programCode(parseCodeableConcept("programCode", reader, programCodeElementIndex++));
                    break;
                case "servicedDate":
                    position = checkElementOrder("serviced[x]", 12, position, false);
                    builder.serviced(parseDate("servicedDate", reader, -1));
                    break;
                case "servicedPeriod":
                    position = checkElementOrder("serviced[x]", 12, position, false);
                    builder.serviced(parsePeriod("servicedPeriod", reader, -1));
                    break;
                case "locationCodeableConcept":
                    position = checkElementOrder("location[x]", 13, position, false);
                    builder.location(parseCodeableConcept("locationCodeableConcept", reader, -1));
                    break;
                case "locationAddress":
                    position = checkElementOrder("location[x]", 13, position, false);
                    builder.location(parseAddress("locationAddress", reader, -1));
                    break;
                case "locationReference":
                    position = checkElementOrder("location[x]", 13, position, false);
                    builder.location(parseReference("locationReference", reader, -1));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 14, position, false);
                    builder.quantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "quantity", reader, -1));
                    break;
                case "unitPrice":
                    position = checkElementOrder("unitPrice", 15, position, false);
                    builder.unitPrice(parseMoney("unitPrice", reader, -1));
                    break;
                case "factor":
                    position = checkElementOrder("factor", 16, position, false);
                    builder.factor(parseDecimal("factor", reader, -1));
                    break;
                case "net":
                    position = checkElementOrder("net", 17, position, false);
                    builder.net(parseMoney("net", reader, -1));
                    break;
                case "udi":
                    position = checkElementOrder("udi", 18, position, true);
                    builder.udi(parseReference("udi", reader, udiElementIndex++));
                    break;
                case "bodySite":
                    position = checkElementOrder("bodySite", 19, position, false);
                    builder.bodySite(parseCodeableConcept("bodySite", reader, -1));
                    break;
                case "subSite":
                    position = checkElementOrder("subSite", 20, position, true);
                    builder.subSite(parseCodeableConcept("subSite", reader, subSiteElementIndex++));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 21, position, true);
                    builder.encounter(parseReference("encounter", reader, encounterElementIndex++));
                    break;
                case "noteNumber":
                    position = checkElementOrder("noteNumber", 22, position, true);
                    builder.noteNumber((PositiveInt) parseInteger(PositiveInt.builder(), "noteNumber", reader, noteNumberElementIndex++));
                    break;
                case "adjudication":
                    position = checkElementOrder("adjudication", 23, position, true);
                    builder.adjudication(parseExplanationOfBenefitItemAdjudication("adjudication", reader, adjudicationElementIndex++));
                    break;
                case "detail":
                    position = checkElementOrder("detail", 24, position, true);
                    builder.detail(parseExplanationOfBenefitItemDetail("detail", reader, detailElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExplanationOfBenefit.Item.Adjudication parseExplanationOfBenefitItemAdjudication(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExplanationOfBenefit.Item.Adjudication.Builder builder = ExplanationOfBenefit.Item.Adjudication.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "category":
                    position = checkElementOrder("category", 2, position, false);
                    builder.category(parseCodeableConcept("category", reader, -1));
                    break;
                case "reason":
                    position = checkElementOrder("reason", 3, position, false);
                    builder.reason(parseCodeableConcept("reason", reader, -1));
                    break;
                case "amount":
                    position = checkElementOrder("amount", 4, position, false);
                    builder.amount(parseMoney("amount", reader, -1));
                    break;
                case "value":
                    position = checkElementOrder("value", 5, position, false);
                    builder.value(parseDecimal("value", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExplanationOfBenefit.Item.Detail parseExplanationOfBenefitItemDetail(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExplanationOfBenefit.Item.Detail.Builder builder = ExplanationOfBenefit.Item.Detail.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, modifierElementIndex = 0, programCodeElementIndex = 0, udiElementIndex = 0, noteNumberElementIndex = 0, adjudicationElementIndex = 0, subDetailElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "sequence":
                    position = checkElementOrder("sequence", 2, position, false);
                    builder.sequence((PositiveInt) parseInteger(PositiveInt.builder(), "sequence", reader, -1));
                    break;
                case "revenue":
                    position = checkElementOrder("revenue", 3, position, false);
                    builder.revenue(parseCodeableConcept("revenue", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 4, position, false);
                    builder.category(parseCodeableConcept("category", reader, -1));
                    break;
                case "productOrService":
                    position = checkElementOrder("productOrService", 5, position, false);
                    builder.productOrService(parseCodeableConcept("productOrService", reader, -1));
                    break;
                case "modifier":
                    position = checkElementOrder("modifier", 6, position, true);
                    builder.modifier(parseCodeableConcept("modifier", reader, modifierElementIndex++));
                    break;
                case "programCode":
                    position = checkElementOrder("programCode", 7, position, true);
                    builder.programCode(parseCodeableConcept("programCode", reader, programCodeElementIndex++));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 8, position, false);
                    builder.quantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "quantity", reader, -1));
                    break;
                case "unitPrice":
                    position = checkElementOrder("unitPrice", 9, position, false);
                    builder.unitPrice(parseMoney("unitPrice", reader, -1));
                    break;
                case "factor":
                    position = checkElementOrder("factor", 10, position, false);
                    builder.factor(parseDecimal("factor", reader, -1));
                    break;
                case "net":
                    position = checkElementOrder("net", 11, position, false);
                    builder.net(parseMoney("net", reader, -1));
                    break;
                case "udi":
                    position = checkElementOrder("udi", 12, position, true);
                    builder.udi(parseReference("udi", reader, udiElementIndex++));
                    break;
                case "noteNumber":
                    position = checkElementOrder("noteNumber", 13, position, true);
                    builder.noteNumber((PositiveInt) parseInteger(PositiveInt.builder(), "noteNumber", reader, noteNumberElementIndex++));
                    break;
                case "adjudication":
                    position = checkElementOrder("adjudication", 14, position, true);
                    builder.adjudication(parseExplanationOfBenefitItemAdjudication("adjudication", reader, adjudicationElementIndex++));
                    break;
                case "subDetail":
                    position = checkElementOrder("subDetail", 15, position, true);
                    builder.subDetail(parseExplanationOfBenefitItemDetailSubDetail("subDetail", reader, subDetailElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExplanationOfBenefit.Item.Detail.SubDetail parseExplanationOfBenefitItemDetailSubDetail(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExplanationOfBenefit.Item.Detail.SubDetail.Builder builder = ExplanationOfBenefit.Item.Detail.SubDetail.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, modifierElementIndex = 0, programCodeElementIndex = 0, udiElementIndex = 0, noteNumberElementIndex = 0, adjudicationElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "sequence":
                    position = checkElementOrder("sequence", 2, position, false);
                    builder.sequence((PositiveInt) parseInteger(PositiveInt.builder(), "sequence", reader, -1));
                    break;
                case "revenue":
                    position = checkElementOrder("revenue", 3, position, false);
                    builder.revenue(parseCodeableConcept("revenue", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 4, position, false);
                    builder.category(parseCodeableConcept("category", reader, -1));
                    break;
                case "productOrService":
                    position = checkElementOrder("productOrService", 5, position, false);
                    builder.productOrService(parseCodeableConcept("productOrService", reader, -1));
                    break;
                case "modifier":
                    position = checkElementOrder("modifier", 6, position, true);
                    builder.modifier(parseCodeableConcept("modifier", reader, modifierElementIndex++));
                    break;
                case "programCode":
                    position = checkElementOrder("programCode", 7, position, true);
                    builder.programCode(parseCodeableConcept("programCode", reader, programCodeElementIndex++));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 8, position, false);
                    builder.quantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "quantity", reader, -1));
                    break;
                case "unitPrice":
                    position = checkElementOrder("unitPrice", 9, position, false);
                    builder.unitPrice(parseMoney("unitPrice", reader, -1));
                    break;
                case "factor":
                    position = checkElementOrder("factor", 10, position, false);
                    builder.factor(parseDecimal("factor", reader, -1));
                    break;
                case "net":
                    position = checkElementOrder("net", 11, position, false);
                    builder.net(parseMoney("net", reader, -1));
                    break;
                case "udi":
                    position = checkElementOrder("udi", 12, position, true);
                    builder.udi(parseReference("udi", reader, udiElementIndex++));
                    break;
                case "noteNumber":
                    position = checkElementOrder("noteNumber", 13, position, true);
                    builder.noteNumber((PositiveInt) parseInteger(PositiveInt.builder(), "noteNumber", reader, noteNumberElementIndex++));
                    break;
                case "adjudication":
                    position = checkElementOrder("adjudication", 14, position, true);
                    builder.adjudication(parseExplanationOfBenefitItemAdjudication("adjudication", reader, adjudicationElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExplanationOfBenefit.Payee parseExplanationOfBenefitPayee(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExplanationOfBenefit.Payee.Builder builder = ExplanationOfBenefit.Payee.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "party":
                    position = checkElementOrder("party", 3, position, false);
                    builder.party(parseReference("party", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExplanationOfBenefit.Payment parseExplanationOfBenefitPayment(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExplanationOfBenefit.Payment.Builder builder = ExplanationOfBenefit.Payment.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "adjustment":
                    position = checkElementOrder("adjustment", 3, position, false);
                    builder.adjustment(parseMoney("adjustment", reader, -1));
                    break;
                case "adjustmentReason":
                    position = checkElementOrder("adjustmentReason", 4, position, false);
                    builder.adjustmentReason(parseCodeableConcept("adjustmentReason", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 5, position, false);
                    builder.date(parseDate("date", reader, -1));
                    break;
                case "amount":
                    position = checkElementOrder("amount", 6, position, false);
                    builder.amount(parseMoney("amount", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 7, position, false);
                    builder.identifier(parseIdentifier("identifier", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExplanationOfBenefit.Procedure parseExplanationOfBenefitProcedure(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExplanationOfBenefit.Procedure.Builder builder = ExplanationOfBenefit.Procedure.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, typeElementIndex = 0, udiElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "sequence":
                    position = checkElementOrder("sequence", 2, position, false);
                    builder.sequence((PositiveInt) parseInteger(PositiveInt.builder(), "sequence", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, true);
                    builder.type(parseCodeableConcept("type", reader, typeElementIndex++));
                    break;
                case "date":
                    position = checkElementOrder("date", 4, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "procedureCodeableConcept":
                    position = checkElementOrder("procedure[x]", 5, position, false);
                    builder.procedure(parseCodeableConcept("procedureCodeableConcept", reader, -1));
                    break;
                case "procedureReference":
                    position = checkElementOrder("procedure[x]", 5, position, false);
                    builder.procedure(parseReference("procedureReference", reader, -1));
                    break;
                case "udi":
                    position = checkElementOrder("udi", 6, position, true);
                    builder.udi(parseReference("udi", reader, udiElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExplanationOfBenefit.ProcessNote parseExplanationOfBenefitProcessNote(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExplanationOfBenefit.ProcessNote.Builder builder = ExplanationOfBenefit.ProcessNote.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "number":
                    position = checkElementOrder("number", 2, position, false);
                    builder.number((PositiveInt) parseInteger(PositiveInt.builder(), "number", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type((NoteType) parseString(NoteType.builder(), "type", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseString("text", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 5, position, false);
                    builder.language(parseCodeableConcept("language", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExplanationOfBenefit.Related parseExplanationOfBenefitRelated(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExplanationOfBenefit.Related.Builder builder = ExplanationOfBenefit.Related.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "claim":
                    position = checkElementOrder("claim", 2, position, false);
                    builder.claim(parseReference("claim", reader, -1));
                    break;
                case "relationship":
                    position = checkElementOrder("relationship", 3, position, false);
                    builder.relationship(parseCodeableConcept("relationship", reader, -1));
                    break;
                case "reference":
                    position = checkElementOrder("reference", 4, position, false);
                    builder.reference(parseIdentifier("reference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExplanationOfBenefit.SupportingInfo parseExplanationOfBenefitSupportingInfo(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExplanationOfBenefit.SupportingInfo.Builder builder = ExplanationOfBenefit.SupportingInfo.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "sequence":
                    position = checkElementOrder("sequence", 2, position, false);
                    builder.sequence((PositiveInt) parseInteger(PositiveInt.builder(), "sequence", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 3, position, false);
                    builder.category(parseCodeableConcept("category", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 4, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "timingDate":
                    position = checkElementOrder("timing[x]", 5, position, false);
                    builder.timing(parseDate("timingDate", reader, -1));
                    break;
                case "timingPeriod":
                    position = checkElementOrder("timing[x]", 5, position, false);
                    builder.timing(parsePeriod("timingPeriod", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 6, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueString":
                    position = checkElementOrder("value[x]", 6, position, false);
                    builder.value(parseString("valueString", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 6, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueAttachment":
                    position = checkElementOrder("value[x]", 6, position, false);
                    builder.value(parseAttachment("valueAttachment", reader, -1));
                    break;
                case "valueReference":
                    position = checkElementOrder("value[x]", 6, position, false);
                    builder.value(parseReference("valueReference", reader, -1));
                    break;
                case "reason":
                    position = checkElementOrder("reason", 7, position, false);
                    builder.reason(parseCoding("reason", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ExplanationOfBenefit.Total parseExplanationOfBenefitTotal(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ExplanationOfBenefit.Total.Builder builder = ExplanationOfBenefit.Total.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "category":
                    position = checkElementOrder("category", 2, position, false);
                    builder.category(parseCodeableConcept("category", reader, -1));
                    break;
                case "amount":
                    position = checkElementOrder("amount", 3, position, false);
                    builder.amount(parseMoney("amount", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Expression parseExpression(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Expression.Builder builder = Expression.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 1, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name((Id) parseString(Id.builder(), "name", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "expression":
                    position = checkElementOrder("expression", 4, position, false);
                    builder.expression(parseString("expression", reader, -1));
                    break;
                case "reference":
                    position = checkElementOrder("reference", 5, position, false);
                    builder.reference(parseUri("reference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Extension parseExtension(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Extension.Builder builder = Extension.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        java.lang.String url = reader.getAttributeValue(null, "url");
        if (url != null) {
            builder.url(url);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "valueBase64Binary":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseBase64Binary("valueBase64Binary", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueCanonical":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value((Canonical) parseUri(Canonical.builder(), "valueCanonical", reader, -1));
                    break;
                case "valueCode":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value((Code) parseString(Code.builder(), "valueCode", reader, -1));
                    break;
                case "valueDate":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseDate("valueDate", reader, -1));
                    break;
                case "valueDateTime":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseDateTime("valueDateTime", reader, -1));
                    break;
                case "valueDecimal":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseDecimal("valueDecimal", reader, -1));
                    break;
                case "valueId":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value((Id) parseString(Id.builder(), "valueId", reader, -1));
                    break;
                case "valueInstant":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseInstant("valueInstant", reader, -1));
                    break;
                case "valueInteger":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseInteger("valueInteger", reader, -1));
                    break;
                case "valueMarkdown":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value((Markdown) parseString(Markdown.builder(), "valueMarkdown", reader, -1));
                    break;
                case "valueOid":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value((Oid) parseUri(Oid.builder(), "valueOid", reader, -1));
                    break;
                case "valuePositiveInt":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value((PositiveInt) parseInteger(PositiveInt.builder(), "valuePositiveInt", reader, -1));
                    break;
                case "valueString":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseString("valueString", reader, -1));
                    break;
                case "valueTime":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseTime("valueTime", reader, -1));
                    break;
                case "valueUnsignedInt":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value((UnsignedInt) parseInteger(UnsignedInt.builder(), "valueUnsignedInt", reader, -1));
                    break;
                case "valueUri":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseUri("valueUri", reader, -1));
                    break;
                case "valueUrl":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value((Url) parseUri(Url.builder(), "valueUrl", reader, -1));
                    break;
                case "valueUuid":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value((Uuid) parseUri(Uuid.builder(), "valueUuid", reader, -1));
                    break;
                case "valueAddress":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseAddress("valueAddress", reader, -1));
                    break;
                case "valueAge":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value((Age) parseQuantity(Age.builder(), "valueAge", reader, -1));
                    break;
                case "valueAnnotation":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseAnnotation("valueAnnotation", reader, -1));
                    break;
                case "valueAttachment":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseAttachment("valueAttachment", reader, -1));
                    break;
                case "valueCodeableConcept":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseCodeableConcept("valueCodeableConcept", reader, -1));
                    break;
                case "valueCodeableReference":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseCodeableReference("valueCodeableReference", reader, -1));
                    break;
                case "valueCoding":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseCoding("valueCoding", reader, -1));
                    break;
                case "valueContactPoint":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseContactPoint("valueContactPoint", reader, -1));
                    break;
                case "valueCount":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value((Count) parseQuantity(Count.builder(), "valueCount", reader, -1));
                    break;
                case "valueDistance":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value((Distance) parseQuantity(Distance.builder(), "valueDistance", reader, -1));
                    break;
                case "valueDuration":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value((Duration) parseQuantity(Duration.builder(), "valueDuration", reader, -1));
                    break;
                case "valueHumanName":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseHumanName("valueHumanName", reader, -1));
                    break;
                case "valueIdentifier":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseIdentifier("valueIdentifier", reader, -1));
                    break;
                case "valueMoney":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseMoney("valueMoney", reader, -1));
                    break;
                case "valuePeriod":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parsePeriod("valuePeriod", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueRange":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseRange("valueRange", reader, -1));
                    break;
                case "valueRatio":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseRatio("valueRatio", reader, -1));
                    break;
                case "valueRatioRange":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseRatioRange("valueRatioRange", reader, -1));
                    break;
                case "valueReference":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseReference("valueReference", reader, -1));
                    break;
                case "valueSampledData":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseSampledData("valueSampledData", reader, -1));
                    break;
                case "valueSignature":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseSignature("valueSignature", reader, -1));
                    break;
                case "valueTiming":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseTiming("valueTiming", reader, -1));
                    break;
                case "valueContactDetail":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseContactDetail("valueContactDetail", reader, -1));
                    break;
                case "valueContributor":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseContributor("valueContributor", reader, -1));
                    break;
                case "valueDataRequirement":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseDataRequirement("valueDataRequirement", reader, -1));
                    break;
                case "valueExpression":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseExpression("valueExpression", reader, -1));
                    break;
                case "valueParameterDefinition":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseParameterDefinition("valueParameterDefinition", reader, -1));
                    break;
                case "valueRelatedArtifact":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseRelatedArtifact("valueRelatedArtifact", reader, -1));
                    break;
                case "valueTriggerDefinition":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseTriggerDefinition("valueTriggerDefinition", reader, -1));
                    break;
                case "valueUsageContext":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseUsageContext("valueUsageContext", reader, -1));
                    break;
                case "valueDosage":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseDosage("valueDosage", reader, -1));
                    break;
                case "valueMeta":
                    position = checkElementOrder("value[x]", 1, position, false);
                    builder.value(parseMeta("valueMeta", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private FamilyMemberHistory parseFamilyMemberHistory(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        FamilyMemberHistory.Builder builder = FamilyMemberHistory.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, instantiatesCanonicalElementIndex = 0, instantiatesUriElementIndex = 0, reasonCodeElementIndex = 0, reasonReferenceElementIndex = 0, noteElementIndex = 0, conditionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "instantiatesCanonical":
                    position = checkElementOrder("instantiatesCanonical", 9, position, true);
                    builder.instantiatesCanonical((Canonical) parseUri(Canonical.builder(), "instantiatesCanonical", reader, instantiatesCanonicalElementIndex++));
                    break;
                case "instantiatesUri":
                    position = checkElementOrder("instantiatesUri", 10, position, true);
                    builder.instantiatesUri(parseUri("instantiatesUri", reader, instantiatesUriElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 11, position, false);
                    builder.status((FamilyHistoryStatus) parseString(FamilyHistoryStatus.builder(), "status", reader, -1));
                    break;
                case "dataAbsentReason":
                    position = checkElementOrder("dataAbsentReason", 12, position, false);
                    builder.dataAbsentReason(parseCodeableConcept("dataAbsentReason", reader, -1));
                    break;
                case "patient":
                    position = checkElementOrder("patient", 13, position, false);
                    builder.patient(parseReference("patient", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 14, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 15, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "relationship":
                    position = checkElementOrder("relationship", 16, position, false);
                    builder.relationship(parseCodeableConcept("relationship", reader, -1));
                    break;
                case "sex":
                    position = checkElementOrder("sex", 17, position, false);
                    builder.sex(parseCodeableConcept("sex", reader, -1));
                    break;
                case "bornPeriod":
                    position = checkElementOrder("born[x]", 18, position, false);
                    builder.born(parsePeriod("bornPeriod", reader, -1));
                    break;
                case "bornDate":
                    position = checkElementOrder("born[x]", 18, position, false);
                    builder.born(parseDate("bornDate", reader, -1));
                    break;
                case "bornString":
                    position = checkElementOrder("born[x]", 18, position, false);
                    builder.born(parseString("bornString", reader, -1));
                    break;
                case "ageAge":
                    position = checkElementOrder("age[x]", 19, position, false);
                    builder.age((Age) parseQuantity(Age.builder(), "ageAge", reader, -1));
                    break;
                case "ageRange":
                    position = checkElementOrder("age[x]", 19, position, false);
                    builder.age(parseRange("ageRange", reader, -1));
                    break;
                case "ageString":
                    position = checkElementOrder("age[x]", 19, position, false);
                    builder.age(parseString("ageString", reader, -1));
                    break;
                case "estimatedAge":
                    position = checkElementOrder("estimatedAge", 20, position, false);
                    builder.estimatedAge(parseBoolean("estimatedAge", reader, -1));
                    break;
                case "deceasedBoolean":
                    position = checkElementOrder("deceased[x]", 21, position, false);
                    builder.deceased(parseBoolean("deceasedBoolean", reader, -1));
                    break;
                case "deceasedAge":
                    position = checkElementOrder("deceased[x]", 21, position, false);
                    builder.deceased((Age) parseQuantity(Age.builder(), "deceasedAge", reader, -1));
                    break;
                case "deceasedRange":
                    position = checkElementOrder("deceased[x]", 21, position, false);
                    builder.deceased(parseRange("deceasedRange", reader, -1));
                    break;
                case "deceasedDate":
                    position = checkElementOrder("deceased[x]", 21, position, false);
                    builder.deceased(parseDate("deceasedDate", reader, -1));
                    break;
                case "deceasedString":
                    position = checkElementOrder("deceased[x]", 21, position, false);
                    builder.deceased(parseString("deceasedString", reader, -1));
                    break;
                case "reasonCode":
                    position = checkElementOrder("reasonCode", 22, position, true);
                    builder.reasonCode(parseCodeableConcept("reasonCode", reader, reasonCodeElementIndex++));
                    break;
                case "reasonReference":
                    position = checkElementOrder("reasonReference", 23, position, true);
                    builder.reasonReference(parseReference("reasonReference", reader, reasonReferenceElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 24, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "condition":
                    position = checkElementOrder("condition", 25, position, true);
                    builder.condition(parseFamilyMemberHistoryCondition("condition", reader, conditionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private FamilyMemberHistory.Condition parseFamilyMemberHistoryCondition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        FamilyMemberHistory.Condition.Builder builder = FamilyMemberHistory.Condition.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, noteElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "outcome":
                    position = checkElementOrder("outcome", 3, position, false);
                    builder.outcome(parseCodeableConcept("outcome", reader, -1));
                    break;
                case "contributedToDeath":
                    position = checkElementOrder("contributedToDeath", 4, position, false);
                    builder.contributedToDeath(parseBoolean("contributedToDeath", reader, -1));
                    break;
                case "onsetAge":
                    position = checkElementOrder("onset[x]", 5, position, false);
                    builder.onset((Age) parseQuantity(Age.builder(), "onsetAge", reader, -1));
                    break;
                case "onsetRange":
                    position = checkElementOrder("onset[x]", 5, position, false);
                    builder.onset(parseRange("onsetRange", reader, -1));
                    break;
                case "onsetPeriod":
                    position = checkElementOrder("onset[x]", 5, position, false);
                    builder.onset(parsePeriod("onsetPeriod", reader, -1));
                    break;
                case "onsetString":
                    position = checkElementOrder("onset[x]", 5, position, false);
                    builder.onset(parseString("onsetString", reader, -1));
                    break;
                case "note":
                    position = checkElementOrder("note", 6, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Flag parseFlag(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Flag.Builder builder = Flag.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, categoryElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((FlagStatus) parseString(FlagStatus.builder(), "status", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 10, position, true);
                    builder.category(parseCodeableConcept("category", reader, categoryElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 11, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 12, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 13, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 14, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "author":
                    position = checkElementOrder("author", 15, position, false);
                    builder.author(parseReference("author", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Goal parseGoal(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Goal.Builder builder = Goal.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, categoryElementIndex = 0, targetElementIndex = 0, addressesElementIndex = 0, noteElementIndex = 0, outcomeCodeElementIndex = 0, outcomeReferenceElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "lifecycleStatus":
                    position = checkElementOrder("lifecycleStatus", 9, position, false);
                    builder.lifecycleStatus((GoalLifecycleStatus) parseString(GoalLifecycleStatus.builder(), "lifecycleStatus", reader, -1));
                    break;
                case "achievementStatus":
                    position = checkElementOrder("achievementStatus", 10, position, false);
                    builder.achievementStatus(parseCodeableConcept("achievementStatus", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 11, position, true);
                    builder.category(parseCodeableConcept("category", reader, categoryElementIndex++));
                    break;
                case "priority":
                    position = checkElementOrder("priority", 12, position, false);
                    builder.priority(parseCodeableConcept("priority", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 13, position, false);
                    builder.description(parseCodeableConcept("description", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 14, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "startDate":
                    position = checkElementOrder("start[x]", 15, position, false);
                    builder.start(parseDate("startDate", reader, -1));
                    break;
                case "startCodeableConcept":
                    position = checkElementOrder("start[x]", 15, position, false);
                    builder.start(parseCodeableConcept("startCodeableConcept", reader, -1));
                    break;
                case "target":
                    position = checkElementOrder("target", 16, position, true);
                    builder.target(parseGoalTarget("target", reader, targetElementIndex++));
                    break;
                case "statusDate":
                    position = checkElementOrder("statusDate", 17, position, false);
                    builder.statusDate(parseDate("statusDate", reader, -1));
                    break;
                case "statusReason":
                    position = checkElementOrder("statusReason", 18, position, false);
                    builder.statusReason(parseString("statusReason", reader, -1));
                    break;
                case "expressedBy":
                    position = checkElementOrder("expressedBy", 19, position, false);
                    builder.expressedBy(parseReference("expressedBy", reader, -1));
                    break;
                case "addresses":
                    position = checkElementOrder("addresses", 20, position, true);
                    builder.addresses(parseReference("addresses", reader, addressesElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 21, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "outcomeCode":
                    position = checkElementOrder("outcomeCode", 22, position, true);
                    builder.outcomeCode(parseCodeableConcept("outcomeCode", reader, outcomeCodeElementIndex++));
                    break;
                case "outcomeReference":
                    position = checkElementOrder("outcomeReference", 23, position, true);
                    builder.outcomeReference(parseReference("outcomeReference", reader, outcomeReferenceElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Goal.Target parseGoalTarget(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Goal.Target.Builder builder = Goal.Target.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "measure":
                    position = checkElementOrder("measure", 2, position, false);
                    builder.measure(parseCodeableConcept("measure", reader, -1));
                    break;
                case "detailQuantity":
                    position = checkElementOrder("detail[x]", 3, position, false);
                    builder.detail(parseQuantity("detailQuantity", reader, -1));
                    break;
                case "detailRange":
                    position = checkElementOrder("detail[x]", 3, position, false);
                    builder.detail(parseRange("detailRange", reader, -1));
                    break;
                case "detailCodeableConcept":
                    position = checkElementOrder("detail[x]", 3, position, false);
                    builder.detail(parseCodeableConcept("detailCodeableConcept", reader, -1));
                    break;
                case "detailString":
                    position = checkElementOrder("detail[x]", 3, position, false);
                    builder.detail(parseString("detailString", reader, -1));
                    break;
                case "detailBoolean":
                    position = checkElementOrder("detail[x]", 3, position, false);
                    builder.detail(parseBoolean("detailBoolean", reader, -1));
                    break;
                case "detailInteger":
                    position = checkElementOrder("detail[x]", 3, position, false);
                    builder.detail(parseInteger("detailInteger", reader, -1));
                    break;
                case "detailRatio":
                    position = checkElementOrder("detail[x]", 3, position, false);
                    builder.detail(parseRatio("detailRatio", reader, -1));
                    break;
                case "dueDate":
                    position = checkElementOrder("due[x]", 4, position, false);
                    builder.due(parseDate("dueDate", reader, -1));
                    break;
                case "dueDuration":
                    position = checkElementOrder("due[x]", 4, position, false);
                    builder.due((Duration) parseQuantity(Duration.builder(), "dueDuration", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private GraphDefinition parseGraphDefinition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        GraphDefinition.Builder builder = GraphDefinition.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, contactElementIndex = 0, useContextElementIndex = 0, jurisdictionElementIndex = 0, linkElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "version":
                    position = checkElementOrder("version", 9, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 10, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 11, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 12, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 13, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 14, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 15, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 16, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 17, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 18, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 19, position, false);
                    builder.purpose((Markdown) parseString(Markdown.builder(), "purpose", reader, -1));
                    break;
                case "start":
                    position = checkElementOrder("start", 20, position, false);
                    builder.start((ResourceTypeCode) parseString(ResourceTypeCode.builder(), "start", reader, -1));
                    break;
                case "profile":
                    position = checkElementOrder("profile", 21, position, false);
                    builder.profile((Canonical) parseUri(Canonical.builder(), "profile", reader, -1));
                    break;
                case "link":
                    position = checkElementOrder("link", 22, position, true);
                    builder.link(parseGraphDefinitionLink("link", reader, linkElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private GraphDefinition.Link parseGraphDefinitionLink(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        GraphDefinition.Link.Builder builder = GraphDefinition.Link.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, targetElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "path":
                    position = checkElementOrder("path", 2, position, false);
                    builder.path(parseString("path", reader, -1));
                    break;
                case "sliceName":
                    position = checkElementOrder("sliceName", 3, position, false);
                    builder.sliceName(parseString("sliceName", reader, -1));
                    break;
                case "min":
                    position = checkElementOrder("min", 4, position, false);
                    builder.min(parseInteger("min", reader, -1));
                    break;
                case "max":
                    position = checkElementOrder("max", 5, position, false);
                    builder.max(parseString("max", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 6, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "target":
                    position = checkElementOrder("target", 7, position, true);
                    builder.target(parseGraphDefinitionLinkTarget("target", reader, targetElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private GraphDefinition.Link.Target parseGraphDefinitionLinkTarget(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        GraphDefinition.Link.Target.Builder builder = GraphDefinition.Link.Target.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, compartmentElementIndex = 0, linkElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type((ResourceTypeCode) parseString(ResourceTypeCode.builder(), "type", reader, -1));
                    break;
                case "params":
                    position = checkElementOrder("params", 3, position, false);
                    builder.params(parseString("params", reader, -1));
                    break;
                case "profile":
                    position = checkElementOrder("profile", 4, position, false);
                    builder.profile((Canonical) parseUri(Canonical.builder(), "profile", reader, -1));
                    break;
                case "compartment":
                    position = checkElementOrder("compartment", 5, position, true);
                    builder.compartment(parseGraphDefinitionLinkTargetCompartment("compartment", reader, compartmentElementIndex++));
                    break;
                case "link":
                    position = checkElementOrder("link", 6, position, true);
                    builder.link(parseGraphDefinitionLink("link", reader, linkElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private GraphDefinition.Link.Target.Compartment parseGraphDefinitionLinkTargetCompartment(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        GraphDefinition.Link.Target.Compartment.Builder builder = GraphDefinition.Link.Target.Compartment.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "use":
                    position = checkElementOrder("use", 2, position, false);
                    builder.use((GraphCompartmentUse) parseString(GraphCompartmentUse.builder(), "use", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 3, position, false);
                    builder.code((CompartmentCode) parseString(CompartmentCode.builder(), "code", reader, -1));
                    break;
                case "rule":
                    position = checkElementOrder("rule", 4, position, false);
                    builder.rule((GraphCompartmentRule) parseString(GraphCompartmentRule.builder(), "rule", reader, -1));
                    break;
                case "expression":
                    position = checkElementOrder("expression", 5, position, false);
                    builder.expression(parseString("expression", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 6, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Group parseGroup(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Group.Builder builder = Group.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, characteristicElementIndex = 0, memberElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "active":
                    position = checkElementOrder("active", 9, position, false);
                    builder.active(parseBoolean("active", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 10, position, false);
                    builder.type((GroupType) parseString(GroupType.builder(), "type", reader, -1));
                    break;
                case "actual":
                    position = checkElementOrder("actual", 11, position, false);
                    builder.actual(parseBoolean("actual", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 12, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 13, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 14, position, false);
                    builder.quantity((UnsignedInt) parseInteger(UnsignedInt.builder(), "quantity", reader, -1));
                    break;
                case "managingEntity":
                    position = checkElementOrder("managingEntity", 15, position, false);
                    builder.managingEntity(parseReference("managingEntity", reader, -1));
                    break;
                case "characteristic":
                    position = checkElementOrder("characteristic", 16, position, true);
                    builder.characteristic(parseGroupCharacteristic("characteristic", reader, characteristicElementIndex++));
                    break;
                case "member":
                    position = checkElementOrder("member", 17, position, true);
                    builder.member(parseGroupMember("member", reader, memberElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Group.Characteristic parseGroupCharacteristic(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Group.Characteristic.Builder builder = Group.Characteristic.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "valueCodeableConcept":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCodeableConcept("valueCodeableConcept", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueRange":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRange("valueRange", reader, -1));
                    break;
                case "valueReference":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseReference("valueReference", reader, -1));
                    break;
                case "exclude":
                    position = checkElementOrder("exclude", 4, position, false);
                    builder.exclude(parseBoolean("exclude", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 5, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Group.Member parseGroupMember(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Group.Member.Builder builder = Group.Member.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "entity":
                    position = checkElementOrder("entity", 2, position, false);
                    builder.entity(parseReference("entity", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 3, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                case "inactive":
                    position = checkElementOrder("inactive", 4, position, false);
                    builder.inactive(parseBoolean("inactive", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private GuidanceResponse parseGuidanceResponse(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        GuidanceResponse.Builder builder = GuidanceResponse.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, reasonCodeElementIndex = 0, reasonReferenceElementIndex = 0, noteElementIndex = 0, evaluationMessageElementIndex = 0, dataRequirementElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "requestIdentifier":
                    position = checkElementOrder("requestIdentifier", 8, position, false);
                    builder.requestIdentifier(parseIdentifier("requestIdentifier", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "moduleUri":
                    position = checkElementOrder("module[x]", 10, position, false);
                    builder.module(parseUri("moduleUri", reader, -1));
                    break;
                case "moduleCanonical":
                    position = checkElementOrder("module[x]", 10, position, false);
                    builder.module((Canonical) parseUri(Canonical.builder(), "moduleCanonical", reader, -1));
                    break;
                case "moduleCodeableConcept":
                    position = checkElementOrder("module[x]", 10, position, false);
                    builder.module(parseCodeableConcept("moduleCodeableConcept", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 11, position, false);
                    builder.status((GuidanceResponseStatus) parseString(GuidanceResponseStatus.builder(), "status", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 12, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 13, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "occurrenceDateTime":
                    position = checkElementOrder("occurrenceDateTime", 14, position, false);
                    builder.occurrenceDateTime(parseDateTime("occurrenceDateTime", reader, -1));
                    break;
                case "performer":
                    position = checkElementOrder("performer", 15, position, false);
                    builder.performer(parseReference("performer", reader, -1));
                    break;
                case "reasonCode":
                    position = checkElementOrder("reasonCode", 16, position, true);
                    builder.reasonCode(parseCodeableConcept("reasonCode", reader, reasonCodeElementIndex++));
                    break;
                case "reasonReference":
                    position = checkElementOrder("reasonReference", 17, position, true);
                    builder.reasonReference(parseReference("reasonReference", reader, reasonReferenceElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 18, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "evaluationMessage":
                    position = checkElementOrder("evaluationMessage", 19, position, true);
                    builder.evaluationMessage(parseReference("evaluationMessage", reader, evaluationMessageElementIndex++));
                    break;
                case "outputParameters":
                    position = checkElementOrder("outputParameters", 20, position, false);
                    builder.outputParameters(parseReference("outputParameters", reader, -1));
                    break;
                case "result":
                    position = checkElementOrder("result", 21, position, false);
                    builder.result(parseReference("result", reader, -1));
                    break;
                case "dataRequirement":
                    position = checkElementOrder("dataRequirement", 22, position, true);
                    builder.dataRequirement(parseDataRequirement("dataRequirement", reader, dataRequirementElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private HealthcareService parseHealthcareService(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        HealthcareService.Builder builder = HealthcareService.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, categoryElementIndex = 0, typeElementIndex = 0, specialtyElementIndex = 0, locationElementIndex = 0, telecomElementIndex = 0, coverageAreaElementIndex = 0, serviceProvisionCodeElementIndex = 0, eligibilityElementIndex = 0, programElementIndex = 0, characteristicElementIndex = 0, communicationElementIndex = 0, referralMethodElementIndex = 0, availableTimeElementIndex = 0, notAvailableElementIndex = 0, endpointElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "active":
                    position = checkElementOrder("active", 9, position, false);
                    builder.active(parseBoolean("active", reader, -1));
                    break;
                case "providedBy":
                    position = checkElementOrder("providedBy", 10, position, false);
                    builder.providedBy(parseReference("providedBy", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 11, position, true);
                    builder.category(parseCodeableConcept("category", reader, categoryElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 12, position, true);
                    builder.type(parseCodeableConcept("type", reader, typeElementIndex++));
                    break;
                case "specialty":
                    position = checkElementOrder("specialty", 13, position, true);
                    builder.specialty(parseCodeableConcept("specialty", reader, specialtyElementIndex++));
                    break;
                case "location":
                    position = checkElementOrder("location", 14, position, true);
                    builder.location(parseReference("location", reader, locationElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 15, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "comment":
                    position = checkElementOrder("comment", 16, position, false);
                    builder.comment(parseString("comment", reader, -1));
                    break;
                case "extraDetails":
                    position = checkElementOrder("extraDetails", 17, position, false);
                    builder.extraDetails((Markdown) parseString(Markdown.builder(), "extraDetails", reader, -1));
                    break;
                case "photo":
                    position = checkElementOrder("photo", 18, position, false);
                    builder.photo(parseAttachment("photo", reader, -1));
                    break;
                case "telecom":
                    position = checkElementOrder("telecom", 19, position, true);
                    builder.telecom(parseContactPoint("telecom", reader, telecomElementIndex++));
                    break;
                case "coverageArea":
                    position = checkElementOrder("coverageArea", 20, position, true);
                    builder.coverageArea(parseReference("coverageArea", reader, coverageAreaElementIndex++));
                    break;
                case "serviceProvisionCode":
                    position = checkElementOrder("serviceProvisionCode", 21, position, true);
                    builder.serviceProvisionCode(parseCodeableConcept("serviceProvisionCode", reader, serviceProvisionCodeElementIndex++));
                    break;
                case "eligibility":
                    position = checkElementOrder("eligibility", 22, position, true);
                    builder.eligibility(parseHealthcareServiceEligibility("eligibility", reader, eligibilityElementIndex++));
                    break;
                case "program":
                    position = checkElementOrder("program", 23, position, true);
                    builder.program(parseCodeableConcept("program", reader, programElementIndex++));
                    break;
                case "characteristic":
                    position = checkElementOrder("characteristic", 24, position, true);
                    builder.characteristic(parseCodeableConcept("characteristic", reader, characteristicElementIndex++));
                    break;
                case "communication":
                    position = checkElementOrder("communication", 25, position, true);
                    builder.communication(parseCodeableConcept("communication", reader, communicationElementIndex++));
                    break;
                case "referralMethod":
                    position = checkElementOrder("referralMethod", 26, position, true);
                    builder.referralMethod(parseCodeableConcept("referralMethod", reader, referralMethodElementIndex++));
                    break;
                case "appointmentRequired":
                    position = checkElementOrder("appointmentRequired", 27, position, false);
                    builder.appointmentRequired(parseBoolean("appointmentRequired", reader, -1));
                    break;
                case "availableTime":
                    position = checkElementOrder("availableTime", 28, position, true);
                    builder.availableTime(parseHealthcareServiceAvailableTime("availableTime", reader, availableTimeElementIndex++));
                    break;
                case "notAvailable":
                    position = checkElementOrder("notAvailable", 29, position, true);
                    builder.notAvailable(parseHealthcareServiceNotAvailable("notAvailable", reader, notAvailableElementIndex++));
                    break;
                case "availabilityExceptions":
                    position = checkElementOrder("availabilityExceptions", 30, position, false);
                    builder.availabilityExceptions(parseString("availabilityExceptions", reader, -1));
                    break;
                case "endpoint":
                    position = checkElementOrder("endpoint", 31, position, true);
                    builder.endpoint(parseReference("endpoint", reader, endpointElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private HealthcareService.AvailableTime parseHealthcareServiceAvailableTime(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        HealthcareService.AvailableTime.Builder builder = HealthcareService.AvailableTime.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, daysOfWeekElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "daysOfWeek":
                    position = checkElementOrder("daysOfWeek", 2, position, true);
                    builder.daysOfWeek((DaysOfWeek) parseString(DaysOfWeek.builder(), "daysOfWeek", reader, daysOfWeekElementIndex++));
                    break;
                case "allDay":
                    position = checkElementOrder("allDay", 3, position, false);
                    builder.allDay(parseBoolean("allDay", reader, -1));
                    break;
                case "availableStartTime":
                    position = checkElementOrder("availableStartTime", 4, position, false);
                    builder.availableStartTime(parseTime("availableStartTime", reader, -1));
                    break;
                case "availableEndTime":
                    position = checkElementOrder("availableEndTime", 5, position, false);
                    builder.availableEndTime(parseTime("availableEndTime", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private HealthcareService.Eligibility parseHealthcareServiceEligibility(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        HealthcareService.Eligibility.Builder builder = HealthcareService.Eligibility.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "comment":
                    position = checkElementOrder("comment", 3, position, false);
                    builder.comment((Markdown) parseString(Markdown.builder(), "comment", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private HealthcareService.NotAvailable parseHealthcareServiceNotAvailable(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        HealthcareService.NotAvailable.Builder builder = HealthcareService.NotAvailable.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 2, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "during":
                    position = checkElementOrder("during", 3, position, false);
                    builder.during(parsePeriod("during", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private HumanName parseHumanName(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        HumanName.Builder builder = HumanName.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, givenElementIndex = 0, prefixElementIndex = 0, suffixElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "use":
                    position = checkElementOrder("use", 1, position, false);
                    builder.use((NameUse) parseString(NameUse.builder(), "use", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 2, position, false);
                    builder.text(parseString("text", reader, -1));
                    break;
                case "family":
                    position = checkElementOrder("family", 3, position, false);
                    builder.family(parseString("family", reader, -1));
                    break;
                case "given":
                    position = checkElementOrder("given", 4, position, true);
                    builder.given(parseString("given", reader, givenElementIndex++));
                    break;
                case "prefix":
                    position = checkElementOrder("prefix", 5, position, true);
                    builder.prefix(parseString("prefix", reader, prefixElementIndex++));
                    break;
                case "suffix":
                    position = checkElementOrder("suffix", 6, position, true);
                    builder.suffix(parseString("suffix", reader, suffixElementIndex++));
                    break;
                case "period":
                    position = checkElementOrder("period", 7, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Identifier parseIdentifier(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Identifier.Builder builder = Identifier.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "use":
                    position = checkElementOrder("use", 1, position, false);
                    builder.use((IdentifierUse) parseString(IdentifierUse.builder(), "use", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "system":
                    position = checkElementOrder("system", 3, position, false);
                    builder.system(parseUri("system", reader, -1));
                    break;
                case "value":
                    position = checkElementOrder("value", 4, position, false);
                    builder.value(parseString("value", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 5, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                case "assigner":
                    position = checkElementOrder("assigner", 6, position, false);
                    builder.assigner(parseReference("assigner", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ImagingStudy parseImagingStudy(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ImagingStudy.Builder builder = ImagingStudy.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, modalityElementIndex = 0, basedOnElementIndex = 0, interpreterElementIndex = 0, endpointElementIndex = 0, procedureCodeElementIndex = 0, reasonCodeElementIndex = 0, reasonReferenceElementIndex = 0, noteElementIndex = 0, seriesElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((ImagingStudyStatus) parseString(ImagingStudyStatus.builder(), "status", reader, -1));
                    break;
                case "modality":
                    position = checkElementOrder("modality", 10, position, true);
                    builder.modality(parseCoding("modality", reader, modalityElementIndex++));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 11, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 12, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "started":
                    position = checkElementOrder("started", 13, position, false);
                    builder.started(parseDateTime("started", reader, -1));
                    break;
                case "basedOn":
                    position = checkElementOrder("basedOn", 14, position, true);
                    builder.basedOn(parseReference("basedOn", reader, basedOnElementIndex++));
                    break;
                case "referrer":
                    position = checkElementOrder("referrer", 15, position, false);
                    builder.referrer(parseReference("referrer", reader, -1));
                    break;
                case "interpreter":
                    position = checkElementOrder("interpreter", 16, position, true);
                    builder.interpreter(parseReference("interpreter", reader, interpreterElementIndex++));
                    break;
                case "endpoint":
                    position = checkElementOrder("endpoint", 17, position, true);
                    builder.endpoint(parseReference("endpoint", reader, endpointElementIndex++));
                    break;
                case "numberOfSeries":
                    position = checkElementOrder("numberOfSeries", 18, position, false);
                    builder.numberOfSeries((UnsignedInt) parseInteger(UnsignedInt.builder(), "numberOfSeries", reader, -1));
                    break;
                case "numberOfInstances":
                    position = checkElementOrder("numberOfInstances", 19, position, false);
                    builder.numberOfInstances((UnsignedInt) parseInteger(UnsignedInt.builder(), "numberOfInstances", reader, -1));
                    break;
                case "procedureReference":
                    position = checkElementOrder("procedureReference", 20, position, false);
                    builder.procedureReference(parseReference("procedureReference", reader, -1));
                    break;
                case "procedureCode":
                    position = checkElementOrder("procedureCode", 21, position, true);
                    builder.procedureCode(parseCodeableConcept("procedureCode", reader, procedureCodeElementIndex++));
                    break;
                case "location":
                    position = checkElementOrder("location", 22, position, false);
                    builder.location(parseReference("location", reader, -1));
                    break;
                case "reasonCode":
                    position = checkElementOrder("reasonCode", 23, position, true);
                    builder.reasonCode(parseCodeableConcept("reasonCode", reader, reasonCodeElementIndex++));
                    break;
                case "reasonReference":
                    position = checkElementOrder("reasonReference", 24, position, true);
                    builder.reasonReference(parseReference("reasonReference", reader, reasonReferenceElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 25, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 26, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "series":
                    position = checkElementOrder("series", 27, position, true);
                    builder.series(parseImagingStudySeries("series", reader, seriesElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ImagingStudy.Series parseImagingStudySeries(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ImagingStudy.Series.Builder builder = ImagingStudy.Series.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, endpointElementIndex = 0, specimenElementIndex = 0, performerElementIndex = 0, instanceElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "uid":
                    position = checkElementOrder("uid", 2, position, false);
                    builder.uid((Id) parseString(Id.builder(), "uid", reader, -1));
                    break;
                case "number":
                    position = checkElementOrder("number", 3, position, false);
                    builder.number((UnsignedInt) parseInteger(UnsignedInt.builder(), "number", reader, -1));
                    break;
                case "modality":
                    position = checkElementOrder("modality", 4, position, false);
                    builder.modality(parseCoding("modality", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 5, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "numberOfInstances":
                    position = checkElementOrder("numberOfInstances", 6, position, false);
                    builder.numberOfInstances((UnsignedInt) parseInteger(UnsignedInt.builder(), "numberOfInstances", reader, -1));
                    break;
                case "endpoint":
                    position = checkElementOrder("endpoint", 7, position, true);
                    builder.endpoint(parseReference("endpoint", reader, endpointElementIndex++));
                    break;
                case "bodySite":
                    position = checkElementOrder("bodySite", 8, position, false);
                    builder.bodySite(parseCoding("bodySite", reader, -1));
                    break;
                case "laterality":
                    position = checkElementOrder("laterality", 9, position, false);
                    builder.laterality(parseCoding("laterality", reader, -1));
                    break;
                case "specimen":
                    position = checkElementOrder("specimen", 10, position, true);
                    builder.specimen(parseReference("specimen", reader, specimenElementIndex++));
                    break;
                case "started":
                    position = checkElementOrder("started", 11, position, false);
                    builder.started(parseDateTime("started", reader, -1));
                    break;
                case "performer":
                    position = checkElementOrder("performer", 12, position, true);
                    builder.performer(parseImagingStudySeriesPerformer("performer", reader, performerElementIndex++));
                    break;
                case "instance":
                    position = checkElementOrder("instance", 13, position, true);
                    builder.instance(parseImagingStudySeriesInstance("instance", reader, instanceElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ImagingStudy.Series.Instance parseImagingStudySeriesInstance(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ImagingStudy.Series.Instance.Builder builder = ImagingStudy.Series.Instance.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "uid":
                    position = checkElementOrder("uid", 2, position, false);
                    builder.uid((Id) parseString(Id.builder(), "uid", reader, -1));
                    break;
                case "sopClass":
                    position = checkElementOrder("sopClass", 3, position, false);
                    builder.sopClass(parseCoding("sopClass", reader, -1));
                    break;
                case "number":
                    position = checkElementOrder("number", 4, position, false);
                    builder.number((UnsignedInt) parseInteger(UnsignedInt.builder(), "number", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 5, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ImagingStudy.Series.Performer parseImagingStudySeriesPerformer(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ImagingStudy.Series.Performer.Builder builder = ImagingStudy.Series.Performer.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "function":
                    position = checkElementOrder("function", 2, position, false);
                    builder.function(parseCodeableConcept("function", reader, -1));
                    break;
                case "actor":
                    position = checkElementOrder("actor", 3, position, false);
                    builder.actor(parseReference("actor", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Immunization parseImmunization(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Immunization.Builder builder = Immunization.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, performerElementIndex = 0, noteElementIndex = 0, reasonCodeElementIndex = 0, reasonReferenceElementIndex = 0, subpotentReasonElementIndex = 0, educationElementIndex = 0, programEligibilityElementIndex = 0, reactionElementIndex = 0, protocolAppliedElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((ImmunizationStatus) parseString(ImmunizationStatus.builder(), "status", reader, -1));
                    break;
                case "statusReason":
                    position = checkElementOrder("statusReason", 10, position, false);
                    builder.statusReason(parseCodeableConcept("statusReason", reader, -1));
                    break;
                case "vaccineCode":
                    position = checkElementOrder("vaccineCode", 11, position, false);
                    builder.vaccineCode(parseCodeableConcept("vaccineCode", reader, -1));
                    break;
                case "patient":
                    position = checkElementOrder("patient", 12, position, false);
                    builder.patient(parseReference("patient", reader, -1));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 13, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "occurrenceDateTime":
                    position = checkElementOrder("occurrence[x]", 14, position, false);
                    builder.occurrence(parseDateTime("occurrenceDateTime", reader, -1));
                    break;
                case "occurrenceString":
                    position = checkElementOrder("occurrence[x]", 14, position, false);
                    builder.occurrence(parseString("occurrenceString", reader, -1));
                    break;
                case "recorded":
                    position = checkElementOrder("recorded", 15, position, false);
                    builder.recorded(parseDateTime("recorded", reader, -1));
                    break;
                case "primarySource":
                    position = checkElementOrder("primarySource", 16, position, false);
                    builder.primarySource(parseBoolean("primarySource", reader, -1));
                    break;
                case "reportOrigin":
                    position = checkElementOrder("reportOrigin", 17, position, false);
                    builder.reportOrigin(parseCodeableConcept("reportOrigin", reader, -1));
                    break;
                case "location":
                    position = checkElementOrder("location", 18, position, false);
                    builder.location(parseReference("location", reader, -1));
                    break;
                case "manufacturer":
                    position = checkElementOrder("manufacturer", 19, position, false);
                    builder.manufacturer(parseReference("manufacturer", reader, -1));
                    break;
                case "lotNumber":
                    position = checkElementOrder("lotNumber", 20, position, false);
                    builder.lotNumber(parseString("lotNumber", reader, -1));
                    break;
                case "expirationDate":
                    position = checkElementOrder("expirationDate", 21, position, false);
                    builder.expirationDate(parseDate("expirationDate", reader, -1));
                    break;
                case "site":
                    position = checkElementOrder("site", 22, position, false);
                    builder.site(parseCodeableConcept("site", reader, -1));
                    break;
                case "route":
                    position = checkElementOrder("route", 23, position, false);
                    builder.route(parseCodeableConcept("route", reader, -1));
                    break;
                case "doseQuantity":
                    position = checkElementOrder("doseQuantity", 24, position, false);
                    builder.doseQuantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "doseQuantity", reader, -1));
                    break;
                case "performer":
                    position = checkElementOrder("performer", 25, position, true);
                    builder.performer(parseImmunizationPerformer("performer", reader, performerElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 26, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "reasonCode":
                    position = checkElementOrder("reasonCode", 27, position, true);
                    builder.reasonCode(parseCodeableConcept("reasonCode", reader, reasonCodeElementIndex++));
                    break;
                case "reasonReference":
                    position = checkElementOrder("reasonReference", 28, position, true);
                    builder.reasonReference(parseReference("reasonReference", reader, reasonReferenceElementIndex++));
                    break;
                case "isSubpotent":
                    position = checkElementOrder("isSubpotent", 29, position, false);
                    builder.isSubpotent(parseBoolean("isSubpotent", reader, -1));
                    break;
                case "subpotentReason":
                    position = checkElementOrder("subpotentReason", 30, position, true);
                    builder.subpotentReason(parseCodeableConcept("subpotentReason", reader, subpotentReasonElementIndex++));
                    break;
                case "education":
                    position = checkElementOrder("education", 31, position, true);
                    builder.education(parseImmunizationEducation("education", reader, educationElementIndex++));
                    break;
                case "programEligibility":
                    position = checkElementOrder("programEligibility", 32, position, true);
                    builder.programEligibility(parseCodeableConcept("programEligibility", reader, programEligibilityElementIndex++));
                    break;
                case "fundingSource":
                    position = checkElementOrder("fundingSource", 33, position, false);
                    builder.fundingSource(parseCodeableConcept("fundingSource", reader, -1));
                    break;
                case "reaction":
                    position = checkElementOrder("reaction", 34, position, true);
                    builder.reaction(parseImmunizationReaction("reaction", reader, reactionElementIndex++));
                    break;
                case "protocolApplied":
                    position = checkElementOrder("protocolApplied", 35, position, true);
                    builder.protocolApplied(parseImmunizationProtocolApplied("protocolApplied", reader, protocolAppliedElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Immunization.Education parseImmunizationEducation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Immunization.Education.Builder builder = Immunization.Education.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "documentType":
                    position = checkElementOrder("documentType", 2, position, false);
                    builder.documentType(parseString("documentType", reader, -1));
                    break;
                case "reference":
                    position = checkElementOrder("reference", 3, position, false);
                    builder.reference(parseUri("reference", reader, -1));
                    break;
                case "publicationDate":
                    position = checkElementOrder("publicationDate", 4, position, false);
                    builder.publicationDate(parseDateTime("publicationDate", reader, -1));
                    break;
                case "presentationDate":
                    position = checkElementOrder("presentationDate", 5, position, false);
                    builder.presentationDate(parseDateTime("presentationDate", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Immunization.Performer parseImmunizationPerformer(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Immunization.Performer.Builder builder = Immunization.Performer.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "function":
                    position = checkElementOrder("function", 2, position, false);
                    builder.function(parseCodeableConcept("function", reader, -1));
                    break;
                case "actor":
                    position = checkElementOrder("actor", 3, position, false);
                    builder.actor(parseReference("actor", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Immunization.ProtocolApplied parseImmunizationProtocolApplied(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Immunization.ProtocolApplied.Builder builder = Immunization.ProtocolApplied.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, targetDiseaseElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "series":
                    position = checkElementOrder("series", 2, position, false);
                    builder.series(parseString("series", reader, -1));
                    break;
                case "authority":
                    position = checkElementOrder("authority", 3, position, false);
                    builder.authority(parseReference("authority", reader, -1));
                    break;
                case "targetDisease":
                    position = checkElementOrder("targetDisease", 4, position, true);
                    builder.targetDisease(parseCodeableConcept("targetDisease", reader, targetDiseaseElementIndex++));
                    break;
                case "doseNumberPositiveInt":
                    position = checkElementOrder("doseNumber[x]", 5, position, false);
                    builder.doseNumber((PositiveInt) parseInteger(PositiveInt.builder(), "doseNumberPositiveInt", reader, -1));
                    break;
                case "doseNumberString":
                    position = checkElementOrder("doseNumber[x]", 5, position, false);
                    builder.doseNumber(parseString("doseNumberString", reader, -1));
                    break;
                case "seriesDosesPositiveInt":
                    position = checkElementOrder("seriesDoses[x]", 6, position, false);
                    builder.seriesDoses((PositiveInt) parseInteger(PositiveInt.builder(), "seriesDosesPositiveInt", reader, -1));
                    break;
                case "seriesDosesString":
                    position = checkElementOrder("seriesDoses[x]", 6, position, false);
                    builder.seriesDoses(parseString("seriesDosesString", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Immunization.Reaction parseImmunizationReaction(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Immunization.Reaction.Builder builder = Immunization.Reaction.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "date":
                    position = checkElementOrder("date", 2, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "detail":
                    position = checkElementOrder("detail", 3, position, false);
                    builder.detail(parseReference("detail", reader, -1));
                    break;
                case "reported":
                    position = checkElementOrder("reported", 4, position, false);
                    builder.reported(parseBoolean("reported", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ImmunizationEvaluation parseImmunizationEvaluation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ImmunizationEvaluation.Builder builder = ImmunizationEvaluation.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, doseStatusReasonElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((ImmunizationEvaluationStatus) parseString(ImmunizationEvaluationStatus.builder(), "status", reader, -1));
                    break;
                case "patient":
                    position = checkElementOrder("patient", 10, position, false);
                    builder.patient(parseReference("patient", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 11, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "authority":
                    position = checkElementOrder("authority", 12, position, false);
                    builder.authority(parseReference("authority", reader, -1));
                    break;
                case "targetDisease":
                    position = checkElementOrder("targetDisease", 13, position, false);
                    builder.targetDisease(parseCodeableConcept("targetDisease", reader, -1));
                    break;
                case "immunizationEvent":
                    position = checkElementOrder("immunizationEvent", 14, position, false);
                    builder.immunizationEvent(parseReference("immunizationEvent", reader, -1));
                    break;
                case "doseStatus":
                    position = checkElementOrder("doseStatus", 15, position, false);
                    builder.doseStatus(parseCodeableConcept("doseStatus", reader, -1));
                    break;
                case "doseStatusReason":
                    position = checkElementOrder("doseStatusReason", 16, position, true);
                    builder.doseStatusReason(parseCodeableConcept("doseStatusReason", reader, doseStatusReasonElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 17, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "series":
                    position = checkElementOrder("series", 18, position, false);
                    builder.series(parseString("series", reader, -1));
                    break;
                case "doseNumberPositiveInt":
                    position = checkElementOrder("doseNumber[x]", 19, position, false);
                    builder.doseNumber((PositiveInt) parseInteger(PositiveInt.builder(), "doseNumberPositiveInt", reader, -1));
                    break;
                case "doseNumberString":
                    position = checkElementOrder("doseNumber[x]", 19, position, false);
                    builder.doseNumber(parseString("doseNumberString", reader, -1));
                    break;
                case "seriesDosesPositiveInt":
                    position = checkElementOrder("seriesDoses[x]", 20, position, false);
                    builder.seriesDoses((PositiveInt) parseInteger(PositiveInt.builder(), "seriesDosesPositiveInt", reader, -1));
                    break;
                case "seriesDosesString":
                    position = checkElementOrder("seriesDoses[x]", 20, position, false);
                    builder.seriesDoses(parseString("seriesDosesString", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ImmunizationRecommendation parseImmunizationRecommendation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ImmunizationRecommendation.Builder builder = ImmunizationRecommendation.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, recommendationElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "patient":
                    position = checkElementOrder("patient", 9, position, false);
                    builder.patient(parseReference("patient", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 10, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "authority":
                    position = checkElementOrder("authority", 11, position, false);
                    builder.authority(parseReference("authority", reader, -1));
                    break;
                case "recommendation":
                    position = checkElementOrder("recommendation", 12, position, true);
                    builder.recommendation(parseImmunizationRecommendationRecommendation("recommendation", reader, recommendationElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ImmunizationRecommendation.Recommendation parseImmunizationRecommendationRecommendation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ImmunizationRecommendation.Recommendation.Builder builder = ImmunizationRecommendation.Recommendation.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, vaccineCodeElementIndex = 0, contraindicatedVaccineCodeElementIndex = 0, forecastReasonElementIndex = 0, dateCriterionElementIndex = 0, supportingImmunizationElementIndex = 0, supportingPatientInformationElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "vaccineCode":
                    position = checkElementOrder("vaccineCode", 2, position, true);
                    builder.vaccineCode(parseCodeableConcept("vaccineCode", reader, vaccineCodeElementIndex++));
                    break;
                case "targetDisease":
                    position = checkElementOrder("targetDisease", 3, position, false);
                    builder.targetDisease(parseCodeableConcept("targetDisease", reader, -1));
                    break;
                case "contraindicatedVaccineCode":
                    position = checkElementOrder("contraindicatedVaccineCode", 4, position, true);
                    builder.contraindicatedVaccineCode(parseCodeableConcept("contraindicatedVaccineCode", reader, contraindicatedVaccineCodeElementIndex++));
                    break;
                case "forecastStatus":
                    position = checkElementOrder("forecastStatus", 5, position, false);
                    builder.forecastStatus(parseCodeableConcept("forecastStatus", reader, -1));
                    break;
                case "forecastReason":
                    position = checkElementOrder("forecastReason", 6, position, true);
                    builder.forecastReason(parseCodeableConcept("forecastReason", reader, forecastReasonElementIndex++));
                    break;
                case "dateCriterion":
                    position = checkElementOrder("dateCriterion", 7, position, true);
                    builder.dateCriterion(parseImmunizationRecommendationRecommendationDateCriterion("dateCriterion", reader, dateCriterionElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 8, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "series":
                    position = checkElementOrder("series", 9, position, false);
                    builder.series(parseString("series", reader, -1));
                    break;
                case "doseNumberPositiveInt":
                    position = checkElementOrder("doseNumber[x]", 10, position, false);
                    builder.doseNumber((PositiveInt) parseInteger(PositiveInt.builder(), "doseNumberPositiveInt", reader, -1));
                    break;
                case "doseNumberString":
                    position = checkElementOrder("doseNumber[x]", 10, position, false);
                    builder.doseNumber(parseString("doseNumberString", reader, -1));
                    break;
                case "seriesDosesPositiveInt":
                    position = checkElementOrder("seriesDoses[x]", 11, position, false);
                    builder.seriesDoses((PositiveInt) parseInteger(PositiveInt.builder(), "seriesDosesPositiveInt", reader, -1));
                    break;
                case "seriesDosesString":
                    position = checkElementOrder("seriesDoses[x]", 11, position, false);
                    builder.seriesDoses(parseString("seriesDosesString", reader, -1));
                    break;
                case "supportingImmunization":
                    position = checkElementOrder("supportingImmunization", 12, position, true);
                    builder.supportingImmunization(parseReference("supportingImmunization", reader, supportingImmunizationElementIndex++));
                    break;
                case "supportingPatientInformation":
                    position = checkElementOrder("supportingPatientInformation", 13, position, true);
                    builder.supportingPatientInformation(parseReference("supportingPatientInformation", reader, supportingPatientInformationElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ImmunizationRecommendation.Recommendation.DateCriterion parseImmunizationRecommendationRecommendationDateCriterion(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ImmunizationRecommendation.Recommendation.DateCriterion.Builder builder = ImmunizationRecommendation.Recommendation.DateCriterion.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "value":
                    position = checkElementOrder("value", 3, position, false);
                    builder.value(parseDateTime("value", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ImplementationGuide parseImplementationGuide(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ImplementationGuide.Builder builder = ImplementationGuide.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, contactElementIndex = 0, useContextElementIndex = 0, jurisdictionElementIndex = 0, fhirVersionElementIndex = 0, dependsOnElementIndex = 0, globalElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "version":
                    position = checkElementOrder("version", 9, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 10, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 11, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 12, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 13, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 14, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 15, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 16, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 17, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 18, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 19, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 20, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                case "packageId":
                    position = checkElementOrder("packageId", 21, position, false);
                    builder.packageId((Id) parseString(Id.builder(), "packageId", reader, -1));
                    break;
                case "license":
                    position = checkElementOrder("license", 22, position, false);
                    builder.license((SPDXLicense) parseString(SPDXLicense.builder(), "license", reader, -1));
                    break;
                case "fhirVersion":
                    position = checkElementOrder("fhirVersion", 23, position, true);
                    builder.fhirVersion((FHIRVersion) parseString(FHIRVersion.builder(), "fhirVersion", reader, fhirVersionElementIndex++));
                    break;
                case "dependsOn":
                    position = checkElementOrder("dependsOn", 24, position, true);
                    builder.dependsOn(parseImplementationGuideDependsOn("dependsOn", reader, dependsOnElementIndex++));
                    break;
                case "global":
                    position = checkElementOrder("global", 25, position, true);
                    builder.global(parseImplementationGuideGlobal("global", reader, globalElementIndex++));
                    break;
                case "definition":
                    position = checkElementOrder("definition", 26, position, false);
                    builder.definition(parseImplementationGuideDefinition("definition", reader, -1));
                    break;
                case "manifest":
                    position = checkElementOrder("manifest", 27, position, false);
                    builder.manifest(parseImplementationGuideManifest("manifest", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ImplementationGuide.Definition parseImplementationGuideDefinition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ImplementationGuide.Definition.Builder builder = ImplementationGuide.Definition.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, groupingElementIndex = 0, resourceElementIndex = 0, parameterElementIndex = 0, templateElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "grouping":
                    position = checkElementOrder("grouping", 2, position, true);
                    builder.grouping(parseImplementationGuideDefinitionGrouping("grouping", reader, groupingElementIndex++));
                    break;
                case "resource":
                    position = checkElementOrder("resource", 3, position, true);
                    builder.resource(parseImplementationGuideDefinitionResource("resource", reader, resourceElementIndex++));
                    break;
                case "page":
                    position = checkElementOrder("page", 4, position, false);
                    builder.page(parseImplementationGuideDefinitionPage("page", reader, -1));
                    break;
                case "parameter":
                    position = checkElementOrder("parameter", 5, position, true);
                    builder.parameter(parseImplementationGuideDefinitionParameter("parameter", reader, parameterElementIndex++));
                    break;
                case "template":
                    position = checkElementOrder("template", 6, position, true);
                    builder.template(parseImplementationGuideDefinitionTemplate("template", reader, templateElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ImplementationGuide.Definition.Grouping parseImplementationGuideDefinitionGrouping(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ImplementationGuide.Definition.Grouping.Builder builder = ImplementationGuide.Definition.Grouping.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 3, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ImplementationGuide.Definition.Page parseImplementationGuideDefinitionPage(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ImplementationGuide.Definition.Page.Builder builder = ImplementationGuide.Definition.Page.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, pageElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "nameUrl":
                    position = checkElementOrder("name[x]", 2, position, false);
                    builder.name((Url) parseUri(Url.builder(), "nameUrl", reader, -1));
                    break;
                case "nameReference":
                    position = checkElementOrder("name[x]", 2, position, false);
                    builder.name(parseReference("nameReference", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 3, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "generation":
                    position = checkElementOrder("generation", 4, position, false);
                    builder.generation((GuidePageGeneration) parseString(GuidePageGeneration.builder(), "generation", reader, -1));
                    break;
                case "page":
                    position = checkElementOrder("page", 5, position, true);
                    builder.page(parseImplementationGuideDefinitionPage("page", reader, pageElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ImplementationGuide.Definition.Parameter parseImplementationGuideDefinitionParameter(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ImplementationGuide.Definition.Parameter.Builder builder = ImplementationGuide.Definition.Parameter.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code((GuideParameterCode) parseString(GuideParameterCode.builder(), "code", reader, -1));
                    break;
                case "value":
                    position = checkElementOrder("value", 3, position, false);
                    builder.value(parseString("value", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ImplementationGuide.Definition.Resource parseImplementationGuideDefinitionResource(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ImplementationGuide.Definition.Resource.Builder builder = ImplementationGuide.Definition.Resource.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, fhirVersionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "reference":
                    position = checkElementOrder("reference", 2, position, false);
                    builder.reference(parseReference("reference", reader, -1));
                    break;
                case "fhirVersion":
                    position = checkElementOrder("fhirVersion", 3, position, true);
                    builder.fhirVersion((FHIRVersion) parseString(FHIRVersion.builder(), "fhirVersion", reader, fhirVersionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 4, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 5, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "exampleBoolean":
                    position = checkElementOrder("example[x]", 6, position, false);
                    builder.example(parseBoolean("exampleBoolean", reader, -1));
                    break;
                case "exampleCanonical":
                    position = checkElementOrder("example[x]", 6, position, false);
                    builder.example((Canonical) parseUri(Canonical.builder(), "exampleCanonical", reader, -1));
                    break;
                case "groupingId":
                    position = checkElementOrder("groupingId", 7, position, false);
                    builder.groupingId((Id) parseString(Id.builder(), "groupingId", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ImplementationGuide.Definition.Template parseImplementationGuideDefinitionTemplate(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ImplementationGuide.Definition.Template.Builder builder = ImplementationGuide.Definition.Template.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code((Code) parseString(Code.builder(), "code", reader, -1));
                    break;
                case "source":
                    position = checkElementOrder("source", 3, position, false);
                    builder.source(parseString("source", reader, -1));
                    break;
                case "scope":
                    position = checkElementOrder("scope", 4, position, false);
                    builder.scope(parseString("scope", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ImplementationGuide.DependsOn parseImplementationGuideDependsOn(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ImplementationGuide.DependsOn.Builder builder = ImplementationGuide.DependsOn.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "uri":
                    position = checkElementOrder("uri", 2, position, false);
                    builder.uri((Canonical) parseUri(Canonical.builder(), "uri", reader, -1));
                    break;
                case "packageId":
                    position = checkElementOrder("packageId", 3, position, false);
                    builder.packageId((Id) parseString(Id.builder(), "packageId", reader, -1));
                    break;
                case "version":
                    position = checkElementOrder("version", 4, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ImplementationGuide.Global parseImplementationGuideGlobal(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ImplementationGuide.Global.Builder builder = ImplementationGuide.Global.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type((ResourceTypeCode) parseString(ResourceTypeCode.builder(), "type", reader, -1));
                    break;
                case "profile":
                    position = checkElementOrder("profile", 3, position, false);
                    builder.profile((Canonical) parseUri(Canonical.builder(), "profile", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ImplementationGuide.Manifest parseImplementationGuideManifest(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ImplementationGuide.Manifest.Builder builder = ImplementationGuide.Manifest.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, resourceElementIndex = 0, pageElementIndex = 0, imageElementIndex = 0, otherElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "rendering":
                    position = checkElementOrder("rendering", 2, position, false);
                    builder.rendering((Url) parseUri(Url.builder(), "rendering", reader, -1));
                    break;
                case "resource":
                    position = checkElementOrder("resource", 3, position, true);
                    builder.resource(parseImplementationGuideManifestResource("resource", reader, resourceElementIndex++));
                    break;
                case "page":
                    position = checkElementOrder("page", 4, position, true);
                    builder.page(parseImplementationGuideManifestPage("page", reader, pageElementIndex++));
                    break;
                case "image":
                    position = checkElementOrder("image", 5, position, true);
                    builder.image(parseString("image", reader, imageElementIndex++));
                    break;
                case "other":
                    position = checkElementOrder("other", 6, position, true);
                    builder.other(parseString("other", reader, otherElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ImplementationGuide.Manifest.Page parseImplementationGuideManifestPage(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ImplementationGuide.Manifest.Page.Builder builder = ImplementationGuide.Manifest.Page.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, anchorElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 3, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "anchor":
                    position = checkElementOrder("anchor", 4, position, true);
                    builder.anchor(parseString("anchor", reader, anchorElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ImplementationGuide.Manifest.Resource parseImplementationGuideManifestResource(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ImplementationGuide.Manifest.Resource.Builder builder = ImplementationGuide.Manifest.Resource.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "reference":
                    position = checkElementOrder("reference", 2, position, false);
                    builder.reference(parseReference("reference", reader, -1));
                    break;
                case "exampleBoolean":
                    position = checkElementOrder("example[x]", 3, position, false);
                    builder.example(parseBoolean("exampleBoolean", reader, -1));
                    break;
                case "exampleCanonical":
                    position = checkElementOrder("example[x]", 3, position, false);
                    builder.example((Canonical) parseUri(Canonical.builder(), "exampleCanonical", reader, -1));
                    break;
                case "relativePath":
                    position = checkElementOrder("relativePath", 4, position, false);
                    builder.relativePath((Url) parseUri(Url.builder(), "relativePath", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Ingredient parseIngredient(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Ingredient.Builder builder = Ingredient.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, forElementIndex = 0, functionElementIndex = 0, manufacturerElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, false);
                    builder.identifier(parseIdentifier("identifier", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "for":
                    position = checkElementOrder("for", 10, position, true);
                    builder._for(parseReference("for", reader, forElementIndex++));
                    break;
                case "role":
                    position = checkElementOrder("role", 11, position, false);
                    builder.role(parseCodeableConcept("role", reader, -1));
                    break;
                case "function":
                    position = checkElementOrder("function", 12, position, true);
                    builder.function(parseCodeableConcept("function", reader, functionElementIndex++));
                    break;
                case "allergenicIndicator":
                    position = checkElementOrder("allergenicIndicator", 13, position, false);
                    builder.allergenicIndicator(parseBoolean("allergenicIndicator", reader, -1));
                    break;
                case "manufacturer":
                    position = checkElementOrder("manufacturer", 14, position, true);
                    builder.manufacturer(parseIngredientManufacturer("manufacturer", reader, manufacturerElementIndex++));
                    break;
                case "substance":
                    position = checkElementOrder("substance", 15, position, false);
                    builder.substance(parseIngredientSubstance("substance", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Ingredient.Manufacturer parseIngredientManufacturer(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Ingredient.Manufacturer.Builder builder = Ingredient.Manufacturer.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "role":
                    position = checkElementOrder("role", 2, position, false);
                    builder.role(parseCoding("role", reader, -1));
                    break;
                case "manufacturer":
                    position = checkElementOrder("manufacturer", 3, position, false);
                    builder.manufacturer(parseReference("manufacturer", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Ingredient.Substance parseIngredientSubstance(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Ingredient.Substance.Builder builder = Ingredient.Substance.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, strengthElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code(parseCodeableReference("code", reader, -1));
                    break;
                case "strength":
                    position = checkElementOrder("strength", 3, position, true);
                    builder.strength(parseIngredientSubstanceStrength("strength", reader, strengthElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Ingredient.Substance.Strength parseIngredientSubstanceStrength(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Ingredient.Substance.Strength.Builder builder = Ingredient.Substance.Strength.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, countryElementIndex = 0, referenceStrengthElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "presentationRatio":
                    position = checkElementOrder("presentation[x]", 2, position, false);
                    builder.presentation(parseRatio("presentationRatio", reader, -1));
                    break;
                case "presentationRatioRange":
                    position = checkElementOrder("presentation[x]", 2, position, false);
                    builder.presentation(parseRatioRange("presentationRatioRange", reader, -1));
                    break;
                case "presentationText":
                    position = checkElementOrder("presentationText", 3, position, false);
                    builder.presentationText(parseString("presentationText", reader, -1));
                    break;
                case "concentrationRatio":
                    position = checkElementOrder("concentration[x]", 4, position, false);
                    builder.concentration(parseRatio("concentrationRatio", reader, -1));
                    break;
                case "concentrationRatioRange":
                    position = checkElementOrder("concentration[x]", 4, position, false);
                    builder.concentration(parseRatioRange("concentrationRatioRange", reader, -1));
                    break;
                case "concentrationText":
                    position = checkElementOrder("concentrationText", 5, position, false);
                    builder.concentrationText(parseString("concentrationText", reader, -1));
                    break;
                case "measurementPoint":
                    position = checkElementOrder("measurementPoint", 6, position, false);
                    builder.measurementPoint(parseString("measurementPoint", reader, -1));
                    break;
                case "country":
                    position = checkElementOrder("country", 7, position, true);
                    builder.country(parseCodeableConcept("country", reader, countryElementIndex++));
                    break;
                case "referenceStrength":
                    position = checkElementOrder("referenceStrength", 8, position, true);
                    builder.referenceStrength(parseIngredientSubstanceStrengthReferenceStrength("referenceStrength", reader, referenceStrengthElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Ingredient.Substance.Strength.ReferenceStrength parseIngredientSubstanceStrengthReferenceStrength(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Ingredient.Substance.Strength.ReferenceStrength.Builder builder = Ingredient.Substance.Strength.ReferenceStrength.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, countryElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "substance":
                    position = checkElementOrder("substance", 2, position, false);
                    builder.substance(parseCodeableReference("substance", reader, -1));
                    break;
                case "strengthRatio":
                    position = checkElementOrder("strength[x]", 3, position, false);
                    builder.strength(parseRatio("strengthRatio", reader, -1));
                    break;
                case "strengthRatioRange":
                    position = checkElementOrder("strength[x]", 3, position, false);
                    builder.strength(parseRatioRange("strengthRatioRange", reader, -1));
                    break;
                case "measurementPoint":
                    position = checkElementOrder("measurementPoint", 4, position, false);
                    builder.measurementPoint(parseString("measurementPoint", reader, -1));
                    break;
                case "country":
                    position = checkElementOrder("country", 5, position, true);
                    builder.country(parseCodeableConcept("country", reader, countryElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Instant parseInstant(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Instant.Builder builder = Instant.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        java.lang.String value = reader.getAttributeValue(null, "value");
        if (value != null) {
            builder.value(value);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private InsurancePlan parseInsurancePlan(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        InsurancePlan.Builder builder = InsurancePlan.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, typeElementIndex = 0, aliasElementIndex = 0, coverageAreaElementIndex = 0, contactElementIndex = 0, endpointElementIndex = 0, networkElementIndex = 0, coverageElementIndex = 0, planElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 10, position, true);
                    builder.type(parseCodeableConcept("type", reader, typeElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 11, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "alias":
                    position = checkElementOrder("alias", 12, position, true);
                    builder.alias(parseString("alias", reader, aliasElementIndex++));
                    break;
                case "period":
                    position = checkElementOrder("period", 13, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                case "ownedBy":
                    position = checkElementOrder("ownedBy", 14, position, false);
                    builder.ownedBy(parseReference("ownedBy", reader, -1));
                    break;
                case "administeredBy":
                    position = checkElementOrder("administeredBy", 15, position, false);
                    builder.administeredBy(parseReference("administeredBy", reader, -1));
                    break;
                case "coverageArea":
                    position = checkElementOrder("coverageArea", 16, position, true);
                    builder.coverageArea(parseReference("coverageArea", reader, coverageAreaElementIndex++));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 17, position, true);
                    builder.contact(parseInsurancePlanContact("contact", reader, contactElementIndex++));
                    break;
                case "endpoint":
                    position = checkElementOrder("endpoint", 18, position, true);
                    builder.endpoint(parseReference("endpoint", reader, endpointElementIndex++));
                    break;
                case "network":
                    position = checkElementOrder("network", 19, position, true);
                    builder.network(parseReference("network", reader, networkElementIndex++));
                    break;
                case "coverage":
                    position = checkElementOrder("coverage", 20, position, true);
                    builder.coverage(parseInsurancePlanCoverage("coverage", reader, coverageElementIndex++));
                    break;
                case "plan":
                    position = checkElementOrder("plan", 21, position, true);
                    builder.plan(parseInsurancePlanPlan("plan", reader, planElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private InsurancePlan.Contact parseInsurancePlanContact(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        InsurancePlan.Contact.Builder builder = InsurancePlan.Contact.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, telecomElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 2, position, false);
                    builder.purpose(parseCodeableConcept("purpose", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 3, position, false);
                    builder.name(parseHumanName("name", reader, -1));
                    break;
                case "telecom":
                    position = checkElementOrder("telecom", 4, position, true);
                    builder.telecom(parseContactPoint("telecom", reader, telecomElementIndex++));
                    break;
                case "address":
                    position = checkElementOrder("address", 5, position, false);
                    builder.address(parseAddress("address", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private InsurancePlan.Coverage parseInsurancePlanCoverage(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        InsurancePlan.Coverage.Builder builder = InsurancePlan.Coverage.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, networkElementIndex = 0, benefitElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "network":
                    position = checkElementOrder("network", 3, position, true);
                    builder.network(parseReference("network", reader, networkElementIndex++));
                    break;
                case "benefit":
                    position = checkElementOrder("benefit", 4, position, true);
                    builder.benefit(parseInsurancePlanCoverageBenefit("benefit", reader, benefitElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private InsurancePlan.Coverage.Benefit parseInsurancePlanCoverageBenefit(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        InsurancePlan.Coverage.Benefit.Builder builder = InsurancePlan.Coverage.Benefit.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, limitElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "requirement":
                    position = checkElementOrder("requirement", 3, position, false);
                    builder.requirement(parseString("requirement", reader, -1));
                    break;
                case "limit":
                    position = checkElementOrder("limit", 4, position, true);
                    builder.limit(parseInsurancePlanCoverageBenefitLimit("limit", reader, limitElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private InsurancePlan.Coverage.Benefit.Limit parseInsurancePlanCoverageBenefitLimit(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        InsurancePlan.Coverage.Benefit.Limit.Builder builder = InsurancePlan.Coverage.Benefit.Limit.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "value":
                    position = checkElementOrder("value", 2, position, false);
                    builder.value(parseQuantity("value", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 3, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private InsurancePlan.Plan parseInsurancePlanPlan(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        InsurancePlan.Plan.Builder builder = InsurancePlan.Plan.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, coverageAreaElementIndex = 0, networkElementIndex = 0, generalCostElementIndex = 0, specificCostElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 2, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "coverageArea":
                    position = checkElementOrder("coverageArea", 4, position, true);
                    builder.coverageArea(parseReference("coverageArea", reader, coverageAreaElementIndex++));
                    break;
                case "network":
                    position = checkElementOrder("network", 5, position, true);
                    builder.network(parseReference("network", reader, networkElementIndex++));
                    break;
                case "generalCost":
                    position = checkElementOrder("generalCost", 6, position, true);
                    builder.generalCost(parseInsurancePlanPlanGeneralCost("generalCost", reader, generalCostElementIndex++));
                    break;
                case "specificCost":
                    position = checkElementOrder("specificCost", 7, position, true);
                    builder.specificCost(parseInsurancePlanPlanSpecificCost("specificCost", reader, specificCostElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private InsurancePlan.Plan.GeneralCost parseInsurancePlanPlanGeneralCost(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        InsurancePlan.Plan.GeneralCost.Builder builder = InsurancePlan.Plan.GeneralCost.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "groupSize":
                    position = checkElementOrder("groupSize", 3, position, false);
                    builder.groupSize((PositiveInt) parseInteger(PositiveInt.builder(), "groupSize", reader, -1));
                    break;
                case "cost":
                    position = checkElementOrder("cost", 4, position, false);
                    builder.cost(parseMoney("cost", reader, -1));
                    break;
                case "comment":
                    position = checkElementOrder("comment", 5, position, false);
                    builder.comment(parseString("comment", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private InsurancePlan.Plan.SpecificCost parseInsurancePlanPlanSpecificCost(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        InsurancePlan.Plan.SpecificCost.Builder builder = InsurancePlan.Plan.SpecificCost.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, benefitElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "category":
                    position = checkElementOrder("category", 2, position, false);
                    builder.category(parseCodeableConcept("category", reader, -1));
                    break;
                case "benefit":
                    position = checkElementOrder("benefit", 3, position, true);
                    builder.benefit(parseInsurancePlanPlanSpecificCostBenefit("benefit", reader, benefitElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private InsurancePlan.Plan.SpecificCost.Benefit parseInsurancePlanPlanSpecificCostBenefit(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        InsurancePlan.Plan.SpecificCost.Benefit.Builder builder = InsurancePlan.Plan.SpecificCost.Benefit.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, costElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "cost":
                    position = checkElementOrder("cost", 3, position, true);
                    builder.cost(parseInsurancePlanPlanSpecificCostBenefitCost("cost", reader, costElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private InsurancePlan.Plan.SpecificCost.Benefit.Cost parseInsurancePlanPlanSpecificCostBenefitCost(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        InsurancePlan.Plan.SpecificCost.Benefit.Cost.Builder builder = InsurancePlan.Plan.SpecificCost.Benefit.Cost.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, qualifiersElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "applicability":
                    position = checkElementOrder("applicability", 3, position, false);
                    builder.applicability(parseCodeableConcept("applicability", reader, -1));
                    break;
                case "qualifiers":
                    position = checkElementOrder("qualifiers", 4, position, true);
                    builder.qualifiers(parseCodeableConcept("qualifiers", reader, qualifiersElementIndex++));
                    break;
                case "value":
                    position = checkElementOrder("value", 5, position, false);
                    builder.value(parseQuantity("value", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Integer parseInteger(Integer.Builder builder, java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        java.lang.String value = reader.getAttributeValue(null, "value");
        if (value != null) {
            builder.value(value);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Integer parseInteger(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        return parseInteger(Integer.builder(), elementName, reader, elementIndex);
    }

    private Invoice parseInvoice(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Invoice.Builder builder = Invoice.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, participantElementIndex = 0, lineItemElementIndex = 0, totalPriceComponentElementIndex = 0, noteElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((InvoiceStatus) parseString(InvoiceStatus.builder(), "status", reader, -1));
                    break;
                case "cancelledReason":
                    position = checkElementOrder("cancelledReason", 10, position, false);
                    builder.cancelledReason(parseString("cancelledReason", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 11, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 12, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "recipient":
                    position = checkElementOrder("recipient", 13, position, false);
                    builder.recipient(parseReference("recipient", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 14, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "participant":
                    position = checkElementOrder("participant", 15, position, true);
                    builder.participant(parseInvoiceParticipant("participant", reader, participantElementIndex++));
                    break;
                case "issuer":
                    position = checkElementOrder("issuer", 16, position, false);
                    builder.issuer(parseReference("issuer", reader, -1));
                    break;
                case "account":
                    position = checkElementOrder("account", 17, position, false);
                    builder.account(parseReference("account", reader, -1));
                    break;
                case "lineItem":
                    position = checkElementOrder("lineItem", 18, position, true);
                    builder.lineItem(parseInvoiceLineItem("lineItem", reader, lineItemElementIndex++));
                    break;
                case "totalPriceComponent":
                    position = checkElementOrder("totalPriceComponent", 19, position, true);
                    builder.totalPriceComponent(parseInvoiceLineItemPriceComponent("totalPriceComponent", reader, totalPriceComponentElementIndex++));
                    break;
                case "totalNet":
                    position = checkElementOrder("totalNet", 20, position, false);
                    builder.totalNet(parseMoney("totalNet", reader, -1));
                    break;
                case "totalGross":
                    position = checkElementOrder("totalGross", 21, position, false);
                    builder.totalGross(parseMoney("totalGross", reader, -1));
                    break;
                case "paymentTerms":
                    position = checkElementOrder("paymentTerms", 22, position, false);
                    builder.paymentTerms((Markdown) parseString(Markdown.builder(), "paymentTerms", reader, -1));
                    break;
                case "note":
                    position = checkElementOrder("note", 23, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Invoice.LineItem parseInvoiceLineItem(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Invoice.LineItem.Builder builder = Invoice.LineItem.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, priceComponentElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "sequence":
                    position = checkElementOrder("sequence", 2, position, false);
                    builder.sequence((PositiveInt) parseInteger(PositiveInt.builder(), "sequence", reader, -1));
                    break;
                case "chargeItemReference":
                    position = checkElementOrder("chargeItem[x]", 3, position, false);
                    builder.chargeItem(parseReference("chargeItemReference", reader, -1));
                    break;
                case "chargeItemCodeableConcept":
                    position = checkElementOrder("chargeItem[x]", 3, position, false);
                    builder.chargeItem(parseCodeableConcept("chargeItemCodeableConcept", reader, -1));
                    break;
                case "priceComponent":
                    position = checkElementOrder("priceComponent", 4, position, true);
                    builder.priceComponent(parseInvoiceLineItemPriceComponent("priceComponent", reader, priceComponentElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Invoice.LineItem.PriceComponent parseInvoiceLineItemPriceComponent(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Invoice.LineItem.PriceComponent.Builder builder = Invoice.LineItem.PriceComponent.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type((InvoicePriceComponentType) parseString(InvoicePriceComponentType.builder(), "type", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 3, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "factor":
                    position = checkElementOrder("factor", 4, position, false);
                    builder.factor(parseDecimal("factor", reader, -1));
                    break;
                case "amount":
                    position = checkElementOrder("amount", 5, position, false);
                    builder.amount(parseMoney("amount", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Invoice.Participant parseInvoiceParticipant(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Invoice.Participant.Builder builder = Invoice.Participant.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "role":
                    position = checkElementOrder("role", 2, position, false);
                    builder.role(parseCodeableConcept("role", reader, -1));
                    break;
                case "actor":
                    position = checkElementOrder("actor", 3, position, false);
                    builder.actor(parseReference("actor", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Library parseLibrary(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Library.Builder builder = Library.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, contactElementIndex = 0, useContextElementIndex = 0, jurisdictionElementIndex = 0, topicElementIndex = 0, authorElementIndex = 0, editorElementIndex = 0, reviewerElementIndex = 0, endorserElementIndex = 0, relatedArtifactElementIndex = 0, parameterElementIndex = 0, dataRequirementElementIndex = 0, contentElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 10, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 11, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 12, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "subtitle":
                    position = checkElementOrder("subtitle", 13, position, false);
                    builder.subtitle(parseString("subtitle", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 14, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 15, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 16, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "subjectCodeableConcept":
                    position = checkElementOrder("subject[x]", 17, position, false);
                    builder.subject(parseCodeableConcept("subjectCodeableConcept", reader, -1));
                    break;
                case "subjectReference":
                    position = checkElementOrder("subject[x]", 17, position, false);
                    builder.subject(parseReference("subjectReference", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 18, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 19, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 20, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 21, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 22, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 23, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 24, position, false);
                    builder.purpose((Markdown) parseString(Markdown.builder(), "purpose", reader, -1));
                    break;
                case "usage":
                    position = checkElementOrder("usage", 25, position, false);
                    builder.usage(parseString("usage", reader, -1));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 26, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                case "approvalDate":
                    position = checkElementOrder("approvalDate", 27, position, false);
                    builder.approvalDate(parseDate("approvalDate", reader, -1));
                    break;
                case "lastReviewDate":
                    position = checkElementOrder("lastReviewDate", 28, position, false);
                    builder.lastReviewDate(parseDate("lastReviewDate", reader, -1));
                    break;
                case "effectivePeriod":
                    position = checkElementOrder("effectivePeriod", 29, position, false);
                    builder.effectivePeriod(parsePeriod("effectivePeriod", reader, -1));
                    break;
                case "topic":
                    position = checkElementOrder("topic", 30, position, true);
                    builder.topic(parseCodeableConcept("topic", reader, topicElementIndex++));
                    break;
                case "author":
                    position = checkElementOrder("author", 31, position, true);
                    builder.author(parseContactDetail("author", reader, authorElementIndex++));
                    break;
                case "editor":
                    position = checkElementOrder("editor", 32, position, true);
                    builder.editor(parseContactDetail("editor", reader, editorElementIndex++));
                    break;
                case "reviewer":
                    position = checkElementOrder("reviewer", 33, position, true);
                    builder.reviewer(parseContactDetail("reviewer", reader, reviewerElementIndex++));
                    break;
                case "endorser":
                    position = checkElementOrder("endorser", 34, position, true);
                    builder.endorser(parseContactDetail("endorser", reader, endorserElementIndex++));
                    break;
                case "relatedArtifact":
                    position = checkElementOrder("relatedArtifact", 35, position, true);
                    builder.relatedArtifact(parseRelatedArtifact("relatedArtifact", reader, relatedArtifactElementIndex++));
                    break;
                case "parameter":
                    position = checkElementOrder("parameter", 36, position, true);
                    builder.parameter(parseParameterDefinition("parameter", reader, parameterElementIndex++));
                    break;
                case "dataRequirement":
                    position = checkElementOrder("dataRequirement", 37, position, true);
                    builder.dataRequirement(parseDataRequirement("dataRequirement", reader, dataRequirementElementIndex++));
                    break;
                case "content":
                    position = checkElementOrder("content", 38, position, true);
                    builder.content(parseAttachment("content", reader, contentElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Linkage parseLinkage(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Linkage.Builder builder = Linkage.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, itemElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "active":
                    position = checkElementOrder("active", 8, position, false);
                    builder.active(parseBoolean("active", reader, -1));
                    break;
                case "author":
                    position = checkElementOrder("author", 9, position, false);
                    builder.author(parseReference("author", reader, -1));
                    break;
                case "item":
                    position = checkElementOrder("item", 10, position, true);
                    builder.item(parseLinkageItem("item", reader, itemElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Linkage.Item parseLinkageItem(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Linkage.Item.Builder builder = Linkage.Item.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type((LinkageType) parseString(LinkageType.builder(), "type", reader, -1));
                    break;
                case "resource":
                    position = checkElementOrder("resource", 3, position, false);
                    builder.resource(parseReference("resource", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private List parseList(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        List.Builder builder = List.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, noteElementIndex = 0, entryElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((ListStatus) parseString(ListStatus.builder(), "status", reader, -1));
                    break;
                case "mode":
                    position = checkElementOrder("mode", 10, position, false);
                    builder.mode((ListMode) parseString(ListMode.builder(), "mode", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 11, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 12, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 13, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 14, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 15, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "source":
                    position = checkElementOrder("source", 16, position, false);
                    builder.source(parseReference("source", reader, -1));
                    break;
                case "orderedBy":
                    position = checkElementOrder("orderedBy", 17, position, false);
                    builder.orderedBy(parseCodeableConcept("orderedBy", reader, -1));
                    break;
                case "note":
                    position = checkElementOrder("note", 18, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "entry":
                    position = checkElementOrder("entry", 19, position, true);
                    builder.entry(parseListEntry("entry", reader, entryElementIndex++));
                    break;
                case "emptyReason":
                    position = checkElementOrder("emptyReason", 20, position, false);
                    builder.emptyReason(parseCodeableConcept("emptyReason", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private List.Entry parseListEntry(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        List.Entry.Builder builder = List.Entry.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "flag":
                    position = checkElementOrder("flag", 2, position, false);
                    builder.flag(parseCodeableConcept("flag", reader, -1));
                    break;
                case "deleted":
                    position = checkElementOrder("deleted", 3, position, false);
                    builder.deleted(parseBoolean("deleted", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 4, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "item":
                    position = checkElementOrder("item", 5, position, false);
                    builder.item(parseReference("item", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Location parseLocation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Location.Builder builder = Location.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, aliasElementIndex = 0, typeElementIndex = 0, telecomElementIndex = 0, hoursOfOperationElementIndex = 0, endpointElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((LocationStatus) parseString(LocationStatus.builder(), "status", reader, -1));
                    break;
                case "operationalStatus":
                    position = checkElementOrder("operationalStatus", 10, position, false);
                    builder.operationalStatus(parseCoding("operationalStatus", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 11, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "alias":
                    position = checkElementOrder("alias", 12, position, true);
                    builder.alias(parseString("alias", reader, aliasElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 13, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "mode":
                    position = checkElementOrder("mode", 14, position, false);
                    builder.mode((LocationMode) parseString(LocationMode.builder(), "mode", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 15, position, true);
                    builder.type(parseCodeableConcept("type", reader, typeElementIndex++));
                    break;
                case "telecom":
                    position = checkElementOrder("telecom", 16, position, true);
                    builder.telecom(parseContactPoint("telecom", reader, telecomElementIndex++));
                    break;
                case "address":
                    position = checkElementOrder("address", 17, position, false);
                    builder.address(parseAddress("address", reader, -1));
                    break;
                case "physicalType":
                    position = checkElementOrder("physicalType", 18, position, false);
                    builder.physicalType(parseCodeableConcept("physicalType", reader, -1));
                    break;
                case "position":
                    position = checkElementOrder("position", 19, position, false);
                    builder.position(parseLocationPosition("position", reader, -1));
                    break;
                case "managingOrganization":
                    position = checkElementOrder("managingOrganization", 20, position, false);
                    builder.managingOrganization(parseReference("managingOrganization", reader, -1));
                    break;
                case "partOf":
                    position = checkElementOrder("partOf", 21, position, false);
                    builder.partOf(parseReference("partOf", reader, -1));
                    break;
                case "hoursOfOperation":
                    position = checkElementOrder("hoursOfOperation", 22, position, true);
                    builder.hoursOfOperation(parseLocationHoursOfOperation("hoursOfOperation", reader, hoursOfOperationElementIndex++));
                    break;
                case "availabilityExceptions":
                    position = checkElementOrder("availabilityExceptions", 23, position, false);
                    builder.availabilityExceptions(parseString("availabilityExceptions", reader, -1));
                    break;
                case "endpoint":
                    position = checkElementOrder("endpoint", 24, position, true);
                    builder.endpoint(parseReference("endpoint", reader, endpointElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Location.HoursOfOperation parseLocationHoursOfOperation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Location.HoursOfOperation.Builder builder = Location.HoursOfOperation.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, daysOfWeekElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "daysOfWeek":
                    position = checkElementOrder("daysOfWeek", 2, position, true);
                    builder.daysOfWeek((DaysOfWeek) parseString(DaysOfWeek.builder(), "daysOfWeek", reader, daysOfWeekElementIndex++));
                    break;
                case "allDay":
                    position = checkElementOrder("allDay", 3, position, false);
                    builder.allDay(parseBoolean("allDay", reader, -1));
                    break;
                case "openingTime":
                    position = checkElementOrder("openingTime", 4, position, false);
                    builder.openingTime(parseTime("openingTime", reader, -1));
                    break;
                case "closingTime":
                    position = checkElementOrder("closingTime", 5, position, false);
                    builder.closingTime(parseTime("closingTime", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Location.Position parseLocationPosition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Location.Position.Builder builder = Location.Position.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "longitude":
                    position = checkElementOrder("longitude", 2, position, false);
                    builder.longitude(parseDecimal("longitude", reader, -1));
                    break;
                case "latitude":
                    position = checkElementOrder("latitude", 3, position, false);
                    builder.latitude(parseDecimal("latitude", reader, -1));
                    break;
                case "altitude":
                    position = checkElementOrder("altitude", 4, position, false);
                    builder.altitude(parseDecimal("altitude", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ManufacturedItemDefinition parseManufacturedItemDefinition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ManufacturedItemDefinition.Builder builder = ManufacturedItemDefinition.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, manufacturerElementIndex = 0, ingredientElementIndex = 0, propertyElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "manufacturedDoseForm":
                    position = checkElementOrder("manufacturedDoseForm", 10, position, false);
                    builder.manufacturedDoseForm(parseCodeableConcept("manufacturedDoseForm", reader, -1));
                    break;
                case "unitOfPresentation":
                    position = checkElementOrder("unitOfPresentation", 11, position, false);
                    builder.unitOfPresentation(parseCodeableConcept("unitOfPresentation", reader, -1));
                    break;
                case "manufacturer":
                    position = checkElementOrder("manufacturer", 12, position, true);
                    builder.manufacturer(parseReference("manufacturer", reader, manufacturerElementIndex++));
                    break;
                case "ingredient":
                    position = checkElementOrder("ingredient", 13, position, true);
                    builder.ingredient(parseCodeableConcept("ingredient", reader, ingredientElementIndex++));
                    break;
                case "property":
                    position = checkElementOrder("property", 14, position, true);
                    builder.property(parseManufacturedItemDefinitionProperty("property", reader, propertyElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ManufacturedItemDefinition.Property parseManufacturedItemDefinitionProperty(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ManufacturedItemDefinition.Property.Builder builder = ManufacturedItemDefinition.Property.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "valueCodeableConcept":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCodeableConcept("valueCodeableConcept", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueDate":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDate("valueDate", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueAttachment":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseAttachment("valueAttachment", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MarketingStatus parseMarketingStatus(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MarketingStatus.Builder builder = MarketingStatus.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "country":
                    position = checkElementOrder("country", 2, position, false);
                    builder.country(parseCodeableConcept("country", reader, -1));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 3, position, false);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 4, position, false);
                    builder.status(parseCodeableConcept("status", reader, -1));
                    break;
                case "dateRange":
                    position = checkElementOrder("dateRange", 5, position, false);
                    builder.dateRange(parsePeriod("dateRange", reader, -1));
                    break;
                case "restoreDate":
                    position = checkElementOrder("restoreDate", 6, position, false);
                    builder.restoreDate(parseDateTime("restoreDate", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Measure parseMeasure(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Measure.Builder builder = Measure.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, contactElementIndex = 0, useContextElementIndex = 0, jurisdictionElementIndex = 0, topicElementIndex = 0, authorElementIndex = 0, editorElementIndex = 0, reviewerElementIndex = 0, endorserElementIndex = 0, relatedArtifactElementIndex = 0, libraryElementIndex = 0, typeElementIndex = 0, definitionElementIndex = 0, groupElementIndex = 0, supplementalDataElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 10, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 11, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 12, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "subtitle":
                    position = checkElementOrder("subtitle", 13, position, false);
                    builder.subtitle(parseString("subtitle", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 14, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 15, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "subjectCodeableConcept":
                    position = checkElementOrder("subject[x]", 16, position, false);
                    builder.subject(parseCodeableConcept("subjectCodeableConcept", reader, -1));
                    break;
                case "subjectReference":
                    position = checkElementOrder("subject[x]", 16, position, false);
                    builder.subject(parseReference("subjectReference", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 17, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 18, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 19, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 20, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 21, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 22, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 23, position, false);
                    builder.purpose((Markdown) parseString(Markdown.builder(), "purpose", reader, -1));
                    break;
                case "usage":
                    position = checkElementOrder("usage", 24, position, false);
                    builder.usage(parseString("usage", reader, -1));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 25, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                case "approvalDate":
                    position = checkElementOrder("approvalDate", 26, position, false);
                    builder.approvalDate(parseDate("approvalDate", reader, -1));
                    break;
                case "lastReviewDate":
                    position = checkElementOrder("lastReviewDate", 27, position, false);
                    builder.lastReviewDate(parseDate("lastReviewDate", reader, -1));
                    break;
                case "effectivePeriod":
                    position = checkElementOrder("effectivePeriod", 28, position, false);
                    builder.effectivePeriod(parsePeriod("effectivePeriod", reader, -1));
                    break;
                case "topic":
                    position = checkElementOrder("topic", 29, position, true);
                    builder.topic(parseCodeableConcept("topic", reader, topicElementIndex++));
                    break;
                case "author":
                    position = checkElementOrder("author", 30, position, true);
                    builder.author(parseContactDetail("author", reader, authorElementIndex++));
                    break;
                case "editor":
                    position = checkElementOrder("editor", 31, position, true);
                    builder.editor(parseContactDetail("editor", reader, editorElementIndex++));
                    break;
                case "reviewer":
                    position = checkElementOrder("reviewer", 32, position, true);
                    builder.reviewer(parseContactDetail("reviewer", reader, reviewerElementIndex++));
                    break;
                case "endorser":
                    position = checkElementOrder("endorser", 33, position, true);
                    builder.endorser(parseContactDetail("endorser", reader, endorserElementIndex++));
                    break;
                case "relatedArtifact":
                    position = checkElementOrder("relatedArtifact", 34, position, true);
                    builder.relatedArtifact(parseRelatedArtifact("relatedArtifact", reader, relatedArtifactElementIndex++));
                    break;
                case "library":
                    position = checkElementOrder("library", 35, position, true);
                    builder.library((Canonical) parseUri(Canonical.builder(), "library", reader, libraryElementIndex++));
                    break;
                case "disclaimer":
                    position = checkElementOrder("disclaimer", 36, position, false);
                    builder.disclaimer((Markdown) parseString(Markdown.builder(), "disclaimer", reader, -1));
                    break;
                case "scoring":
                    position = checkElementOrder("scoring", 37, position, false);
                    builder.scoring(parseCodeableConcept("scoring", reader, -1));
                    break;
                case "compositeScoring":
                    position = checkElementOrder("compositeScoring", 38, position, false);
                    builder.compositeScoring(parseCodeableConcept("compositeScoring", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 39, position, true);
                    builder.type(parseCodeableConcept("type", reader, typeElementIndex++));
                    break;
                case "riskAdjustment":
                    position = checkElementOrder("riskAdjustment", 40, position, false);
                    builder.riskAdjustment(parseString("riskAdjustment", reader, -1));
                    break;
                case "rateAggregation":
                    position = checkElementOrder("rateAggregation", 41, position, false);
                    builder.rateAggregation(parseString("rateAggregation", reader, -1));
                    break;
                case "rationale":
                    position = checkElementOrder("rationale", 42, position, false);
                    builder.rationale((Markdown) parseString(Markdown.builder(), "rationale", reader, -1));
                    break;
                case "clinicalRecommendationStatement":
                    position = checkElementOrder("clinicalRecommendationStatement", 43, position, false);
                    builder.clinicalRecommendationStatement((Markdown) parseString(Markdown.builder(), "clinicalRecommendationStatement", reader, -1));
                    break;
                case "improvementNotation":
                    position = checkElementOrder("improvementNotation", 44, position, false);
                    builder.improvementNotation(parseCodeableConcept("improvementNotation", reader, -1));
                    break;
                case "definition":
                    position = checkElementOrder("definition", 45, position, true);
                    builder.definition((Markdown) parseString(Markdown.builder(), "definition", reader, definitionElementIndex++));
                    break;
                case "guidance":
                    position = checkElementOrder("guidance", 46, position, false);
                    builder.guidance((Markdown) parseString(Markdown.builder(), "guidance", reader, -1));
                    break;
                case "group":
                    position = checkElementOrder("group", 47, position, true);
                    builder.group(parseMeasureGroup("group", reader, groupElementIndex++));
                    break;
                case "supplementalData":
                    position = checkElementOrder("supplementalData", 48, position, true);
                    builder.supplementalData(parseMeasureSupplementalData("supplementalData", reader, supplementalDataElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Measure.Group parseMeasureGroup(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Measure.Group.Builder builder = Measure.Group.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, populationElementIndex = 0, stratifierElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 3, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "population":
                    position = checkElementOrder("population", 4, position, true);
                    builder.population(parseMeasureGroupPopulation("population", reader, populationElementIndex++));
                    break;
                case "stratifier":
                    position = checkElementOrder("stratifier", 5, position, true);
                    builder.stratifier(parseMeasureGroupStratifier("stratifier", reader, stratifierElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Measure.Group.Population parseMeasureGroupPopulation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Measure.Group.Population.Builder builder = Measure.Group.Population.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 3, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "criteria":
                    position = checkElementOrder("criteria", 4, position, false);
                    builder.criteria(parseExpression("criteria", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Measure.Group.Stratifier parseMeasureGroupStratifier(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Measure.Group.Stratifier.Builder builder = Measure.Group.Stratifier.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, componentElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 3, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "criteria":
                    position = checkElementOrder("criteria", 4, position, false);
                    builder.criteria(parseExpression("criteria", reader, -1));
                    break;
                case "component":
                    position = checkElementOrder("component", 5, position, true);
                    builder.component(parseMeasureGroupStratifierComponent("component", reader, componentElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Measure.Group.Stratifier.Component parseMeasureGroupStratifierComponent(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Measure.Group.Stratifier.Component.Builder builder = Measure.Group.Stratifier.Component.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 3, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "criteria":
                    position = checkElementOrder("criteria", 4, position, false);
                    builder.criteria(parseExpression("criteria", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Measure.SupplementalData parseMeasureSupplementalData(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Measure.SupplementalData.Builder builder = Measure.SupplementalData.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, usageElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "usage":
                    position = checkElementOrder("usage", 3, position, true);
                    builder.usage(parseCodeableConcept("usage", reader, usageElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 4, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "criteria":
                    position = checkElementOrder("criteria", 5, position, false);
                    builder.criteria(parseExpression("criteria", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MeasureReport parseMeasureReport(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MeasureReport.Builder builder = MeasureReport.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, groupElementIndex = 0, evaluatedResourceElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((MeasureReportStatus) parseString(MeasureReportStatus.builder(), "status", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 10, position, false);
                    builder.type((MeasureReportType) parseString(MeasureReportType.builder(), "type", reader, -1));
                    break;
                case "measure":
                    position = checkElementOrder("measure", 11, position, false);
                    builder.measure((Canonical) parseUri(Canonical.builder(), "measure", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 12, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 13, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "reporter":
                    position = checkElementOrder("reporter", 14, position, false);
                    builder.reporter(parseReference("reporter", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 15, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                case "improvementNotation":
                    position = checkElementOrder("improvementNotation", 16, position, false);
                    builder.improvementNotation(parseCodeableConcept("improvementNotation", reader, -1));
                    break;
                case "group":
                    position = checkElementOrder("group", 17, position, true);
                    builder.group(parseMeasureReportGroup("group", reader, groupElementIndex++));
                    break;
                case "evaluatedResource":
                    position = checkElementOrder("evaluatedResource", 18, position, true);
                    builder.evaluatedResource(parseReference("evaluatedResource", reader, evaluatedResourceElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MeasureReport.Group parseMeasureReportGroup(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MeasureReport.Group.Builder builder = MeasureReport.Group.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, populationElementIndex = 0, stratifierElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "population":
                    position = checkElementOrder("population", 3, position, true);
                    builder.population(parseMeasureReportGroupPopulation("population", reader, populationElementIndex++));
                    break;
                case "measureScore":
                    position = checkElementOrder("measureScore", 4, position, false);
                    builder.measureScore(parseQuantity("measureScore", reader, -1));
                    break;
                case "stratifier":
                    position = checkElementOrder("stratifier", 5, position, true);
                    builder.stratifier(parseMeasureReportGroupStratifier("stratifier", reader, stratifierElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MeasureReport.Group.Population parseMeasureReportGroupPopulation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MeasureReport.Group.Population.Builder builder = MeasureReport.Group.Population.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "count":
                    position = checkElementOrder("count", 3, position, false);
                    builder.count(parseInteger("count", reader, -1));
                    break;
                case "subjectResults":
                    position = checkElementOrder("subjectResults", 4, position, false);
                    builder.subjectResults(parseReference("subjectResults", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MeasureReport.Group.Stratifier parseMeasureReportGroupStratifier(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MeasureReport.Group.Stratifier.Builder builder = MeasureReport.Group.Stratifier.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, codeElementIndex = 0, stratumElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, true);
                    builder.code(parseCodeableConcept("code", reader, codeElementIndex++));
                    break;
                case "stratum":
                    position = checkElementOrder("stratum", 3, position, true);
                    builder.stratum(parseMeasureReportGroupStratifierStratum("stratum", reader, stratumElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MeasureReport.Group.Stratifier.Stratum parseMeasureReportGroupStratifierStratum(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MeasureReport.Group.Stratifier.Stratum.Builder builder = MeasureReport.Group.Stratifier.Stratum.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, componentElementIndex = 0, populationElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "value":
                    position = checkElementOrder("value", 2, position, false);
                    builder.value(parseCodeableConcept("value", reader, -1));
                    break;
                case "component":
                    position = checkElementOrder("component", 3, position, true);
                    builder.component(parseMeasureReportGroupStratifierStratumComponent("component", reader, componentElementIndex++));
                    break;
                case "population":
                    position = checkElementOrder("population", 4, position, true);
                    builder.population(parseMeasureReportGroupStratifierStratumPopulation("population", reader, populationElementIndex++));
                    break;
                case "measureScore":
                    position = checkElementOrder("measureScore", 5, position, false);
                    builder.measureScore(parseQuantity("measureScore", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MeasureReport.Group.Stratifier.Stratum.Component parseMeasureReportGroupStratifierStratumComponent(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MeasureReport.Group.Stratifier.Stratum.Component.Builder builder = MeasureReport.Group.Stratifier.Stratum.Component.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "value":
                    position = checkElementOrder("value", 3, position, false);
                    builder.value(parseCodeableConcept("value", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MeasureReport.Group.Stratifier.Stratum.Population parseMeasureReportGroupStratifierStratumPopulation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MeasureReport.Group.Stratifier.Stratum.Population.Builder builder = MeasureReport.Group.Stratifier.Stratum.Population.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "count":
                    position = checkElementOrder("count", 3, position, false);
                    builder.count(parseInteger("count", reader, -1));
                    break;
                case "subjectResults":
                    position = checkElementOrder("subjectResults", 4, position, false);
                    builder.subjectResults(parseReference("subjectResults", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Media parseMedia(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Media.Builder builder = Media.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, basedOnElementIndex = 0, partOfElementIndex = 0, reasonCodeElementIndex = 0, noteElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "basedOn":
                    position = checkElementOrder("basedOn", 9, position, true);
                    builder.basedOn(parseReference("basedOn", reader, basedOnElementIndex++));
                    break;
                case "partOf":
                    position = checkElementOrder("partOf", 10, position, true);
                    builder.partOf(parseReference("partOf", reader, partOfElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 11, position, false);
                    builder.status((MediaStatus) parseString(MediaStatus.builder(), "status", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 12, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "modality":
                    position = checkElementOrder("modality", 13, position, false);
                    builder.modality(parseCodeableConcept("modality", reader, -1));
                    break;
                case "view":
                    position = checkElementOrder("view", 14, position, false);
                    builder.view(parseCodeableConcept("view", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 15, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 16, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "createdDateTime":
                    position = checkElementOrder("created[x]", 17, position, false);
                    builder.created(parseDateTime("createdDateTime", reader, -1));
                    break;
                case "createdPeriod":
                    position = checkElementOrder("created[x]", 17, position, false);
                    builder.created(parsePeriod("createdPeriod", reader, -1));
                    break;
                case "issued":
                    position = checkElementOrder("issued", 18, position, false);
                    builder.issued(parseInstant("issued", reader, -1));
                    break;
                case "operator":
                    position = checkElementOrder("operator", 19, position, false);
                    builder.operator(parseReference("operator", reader, -1));
                    break;
                case "reasonCode":
                    position = checkElementOrder("reasonCode", 20, position, true);
                    builder.reasonCode(parseCodeableConcept("reasonCode", reader, reasonCodeElementIndex++));
                    break;
                case "bodySite":
                    position = checkElementOrder("bodySite", 21, position, false);
                    builder.bodySite(parseCodeableConcept("bodySite", reader, -1));
                    break;
                case "deviceName":
                    position = checkElementOrder("deviceName", 22, position, false);
                    builder.deviceName(parseString("deviceName", reader, -1));
                    break;
                case "device":
                    position = checkElementOrder("device", 23, position, false);
                    builder.device(parseReference("device", reader, -1));
                    break;
                case "height":
                    position = checkElementOrder("height", 24, position, false);
                    builder.height((PositiveInt) parseInteger(PositiveInt.builder(), "height", reader, -1));
                    break;
                case "width":
                    position = checkElementOrder("width", 25, position, false);
                    builder.width((PositiveInt) parseInteger(PositiveInt.builder(), "width", reader, -1));
                    break;
                case "frames":
                    position = checkElementOrder("frames", 26, position, false);
                    builder.frames((PositiveInt) parseInteger(PositiveInt.builder(), "frames", reader, -1));
                    break;
                case "duration":
                    position = checkElementOrder("duration", 27, position, false);
                    builder.duration(parseDecimal("duration", reader, -1));
                    break;
                case "content":
                    position = checkElementOrder("content", 28, position, false);
                    builder.content(parseAttachment("content", reader, -1));
                    break;
                case "note":
                    position = checkElementOrder("note", 29, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Medication parseMedication(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Medication.Builder builder = Medication.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, ingredientElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 9, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 10, position, false);
                    builder.status((MedicationStatus) parseString(MedicationStatus.builder(), "status", reader, -1));
                    break;
                case "manufacturer":
                    position = checkElementOrder("manufacturer", 11, position, false);
                    builder.manufacturer(parseReference("manufacturer", reader, -1));
                    break;
                case "form":
                    position = checkElementOrder("form", 12, position, false);
                    builder.form(parseCodeableConcept("form", reader, -1));
                    break;
                case "amount":
                    position = checkElementOrder("amount", 13, position, false);
                    builder.amount(parseRatio("amount", reader, -1));
                    break;
                case "ingredient":
                    position = checkElementOrder("ingredient", 14, position, true);
                    builder.ingredient(parseMedicationIngredient("ingredient", reader, ingredientElementIndex++));
                    break;
                case "batch":
                    position = checkElementOrder("batch", 15, position, false);
                    builder.batch(parseMedicationBatch("batch", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Medication.Batch parseMedicationBatch(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Medication.Batch.Builder builder = Medication.Batch.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "lotNumber":
                    position = checkElementOrder("lotNumber", 2, position, false);
                    builder.lotNumber(parseString("lotNumber", reader, -1));
                    break;
                case "expirationDate":
                    position = checkElementOrder("expirationDate", 3, position, false);
                    builder.expirationDate(parseDateTime("expirationDate", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Medication.Ingredient parseMedicationIngredient(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Medication.Ingredient.Builder builder = Medication.Ingredient.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "itemCodeableConcept":
                    position = checkElementOrder("item[x]", 2, position, false);
                    builder.item(parseCodeableConcept("itemCodeableConcept", reader, -1));
                    break;
                case "itemReference":
                    position = checkElementOrder("item[x]", 2, position, false);
                    builder.item(parseReference("itemReference", reader, -1));
                    break;
                case "isActive":
                    position = checkElementOrder("isActive", 3, position, false);
                    builder.isActive(parseBoolean("isActive", reader, -1));
                    break;
                case "strength":
                    position = checkElementOrder("strength", 4, position, false);
                    builder.strength(parseRatio("strength", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationAdministration parseMedicationAdministration(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationAdministration.Builder builder = MedicationAdministration.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, instantiatesElementIndex = 0, partOfElementIndex = 0, statusReasonElementIndex = 0, supportingInformationElementIndex = 0, performerElementIndex = 0, reasonCodeElementIndex = 0, reasonReferenceElementIndex = 0, deviceElementIndex = 0, noteElementIndex = 0, eventHistoryElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "instantiates":
                    position = checkElementOrder("instantiates", 9, position, true);
                    builder.instantiates(parseUri("instantiates", reader, instantiatesElementIndex++));
                    break;
                case "partOf":
                    position = checkElementOrder("partOf", 10, position, true);
                    builder.partOf(parseReference("partOf", reader, partOfElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 11, position, false);
                    builder.status((MedicationAdministrationStatus) parseString(MedicationAdministrationStatus.builder(), "status", reader, -1));
                    break;
                case "statusReason":
                    position = checkElementOrder("statusReason", 12, position, true);
                    builder.statusReason(parseCodeableConcept("statusReason", reader, statusReasonElementIndex++));
                    break;
                case "category":
                    position = checkElementOrder("category", 13, position, false);
                    builder.category(parseCodeableConcept("category", reader, -1));
                    break;
                case "medicationCodeableConcept":
                    position = checkElementOrder("medication[x]", 14, position, false);
                    builder.medication(parseCodeableConcept("medicationCodeableConcept", reader, -1));
                    break;
                case "medicationReference":
                    position = checkElementOrder("medication[x]", 14, position, false);
                    builder.medication(parseReference("medicationReference", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 15, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "context":
                    position = checkElementOrder("context", 16, position, false);
                    builder.context(parseReference("context", reader, -1));
                    break;
                case "supportingInformation":
                    position = checkElementOrder("supportingInformation", 17, position, true);
                    builder.supportingInformation(parseReference("supportingInformation", reader, supportingInformationElementIndex++));
                    break;
                case "effectiveDateTime":
                    position = checkElementOrder("effective[x]", 18, position, false);
                    builder.effective(parseDateTime("effectiveDateTime", reader, -1));
                    break;
                case "effectivePeriod":
                    position = checkElementOrder("effective[x]", 18, position, false);
                    builder.effective(parsePeriod("effectivePeriod", reader, -1));
                    break;
                case "performer":
                    position = checkElementOrder("performer", 19, position, true);
                    builder.performer(parseMedicationAdministrationPerformer("performer", reader, performerElementIndex++));
                    break;
                case "reasonCode":
                    position = checkElementOrder("reasonCode", 20, position, true);
                    builder.reasonCode(parseCodeableConcept("reasonCode", reader, reasonCodeElementIndex++));
                    break;
                case "reasonReference":
                    position = checkElementOrder("reasonReference", 21, position, true);
                    builder.reasonReference(parseReference("reasonReference", reader, reasonReferenceElementIndex++));
                    break;
                case "request":
                    position = checkElementOrder("request", 22, position, false);
                    builder.request(parseReference("request", reader, -1));
                    break;
                case "device":
                    position = checkElementOrder("device", 23, position, true);
                    builder.device(parseReference("device", reader, deviceElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 24, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "dosage":
                    position = checkElementOrder("dosage", 25, position, false);
                    builder.dosage(parseMedicationAdministrationDosage("dosage", reader, -1));
                    break;
                case "eventHistory":
                    position = checkElementOrder("eventHistory", 26, position, true);
                    builder.eventHistory(parseReference("eventHistory", reader, eventHistoryElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationAdministration.Dosage parseMedicationAdministrationDosage(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationAdministration.Dosage.Builder builder = MedicationAdministration.Dosage.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "text":
                    position = checkElementOrder("text", 2, position, false);
                    builder.text(parseString("text", reader, -1));
                    break;
                case "site":
                    position = checkElementOrder("site", 3, position, false);
                    builder.site(parseCodeableConcept("site", reader, -1));
                    break;
                case "route":
                    position = checkElementOrder("route", 4, position, false);
                    builder.route(parseCodeableConcept("route", reader, -1));
                    break;
                case "method":
                    position = checkElementOrder("method", 5, position, false);
                    builder.method(parseCodeableConcept("method", reader, -1));
                    break;
                case "dose":
                    position = checkElementOrder("dose", 6, position, false);
                    builder.dose((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "dose", reader, -1));
                    break;
                case "rateRatio":
                    position = checkElementOrder("rate[x]", 7, position, false);
                    builder.rate(parseRatio("rateRatio", reader, -1));
                    break;
                case "rateQuantity":
                    position = checkElementOrder("rate[x]", 7, position, false);
                    builder.rate((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "rateQuantity", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationAdministration.Performer parseMedicationAdministrationPerformer(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationAdministration.Performer.Builder builder = MedicationAdministration.Performer.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "function":
                    position = checkElementOrder("function", 2, position, false);
                    builder.function(parseCodeableConcept("function", reader, -1));
                    break;
                case "actor":
                    position = checkElementOrder("actor", 3, position, false);
                    builder.actor(parseReference("actor", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationDispense parseMedicationDispense(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationDispense.Builder builder = MedicationDispense.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, partOfElementIndex = 0, supportingInformationElementIndex = 0, performerElementIndex = 0, authorizingPrescriptionElementIndex = 0, receiverElementIndex = 0, noteElementIndex = 0, dosageInstructionElementIndex = 0, detectedIssueElementIndex = 0, eventHistoryElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "partOf":
                    position = checkElementOrder("partOf", 9, position, true);
                    builder.partOf(parseReference("partOf", reader, partOfElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 10, position, false);
                    builder.status((MedicationDispenseStatus) parseString(MedicationDispenseStatus.builder(), "status", reader, -1));
                    break;
                case "statusReasonCodeableConcept":
                    position = checkElementOrder("statusReason[x]", 11, position, false);
                    builder.statusReason(parseCodeableConcept("statusReasonCodeableConcept", reader, -1));
                    break;
                case "statusReasonReference":
                    position = checkElementOrder("statusReason[x]", 11, position, false);
                    builder.statusReason(parseReference("statusReasonReference", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 12, position, false);
                    builder.category(parseCodeableConcept("category", reader, -1));
                    break;
                case "medicationCodeableConcept":
                    position = checkElementOrder("medication[x]", 13, position, false);
                    builder.medication(parseCodeableConcept("medicationCodeableConcept", reader, -1));
                    break;
                case "medicationReference":
                    position = checkElementOrder("medication[x]", 13, position, false);
                    builder.medication(parseReference("medicationReference", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 14, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "context":
                    position = checkElementOrder("context", 15, position, false);
                    builder.context(parseReference("context", reader, -1));
                    break;
                case "supportingInformation":
                    position = checkElementOrder("supportingInformation", 16, position, true);
                    builder.supportingInformation(parseReference("supportingInformation", reader, supportingInformationElementIndex++));
                    break;
                case "performer":
                    position = checkElementOrder("performer", 17, position, true);
                    builder.performer(parseMedicationDispensePerformer("performer", reader, performerElementIndex++));
                    break;
                case "location":
                    position = checkElementOrder("location", 18, position, false);
                    builder.location(parseReference("location", reader, -1));
                    break;
                case "authorizingPrescription":
                    position = checkElementOrder("authorizingPrescription", 19, position, true);
                    builder.authorizingPrescription(parseReference("authorizingPrescription", reader, authorizingPrescriptionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 20, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 21, position, false);
                    builder.quantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "quantity", reader, -1));
                    break;
                case "daysSupply":
                    position = checkElementOrder("daysSupply", 22, position, false);
                    builder.daysSupply((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "daysSupply", reader, -1));
                    break;
                case "whenPrepared":
                    position = checkElementOrder("whenPrepared", 23, position, false);
                    builder.whenPrepared(parseDateTime("whenPrepared", reader, -1));
                    break;
                case "whenHandedOver":
                    position = checkElementOrder("whenHandedOver", 24, position, false);
                    builder.whenHandedOver(parseDateTime("whenHandedOver", reader, -1));
                    break;
                case "destination":
                    position = checkElementOrder("destination", 25, position, false);
                    builder.destination(parseReference("destination", reader, -1));
                    break;
                case "receiver":
                    position = checkElementOrder("receiver", 26, position, true);
                    builder.receiver(parseReference("receiver", reader, receiverElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 27, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "dosageInstruction":
                    position = checkElementOrder("dosageInstruction", 28, position, true);
                    builder.dosageInstruction(parseDosage("dosageInstruction", reader, dosageInstructionElementIndex++));
                    break;
                case "substitution":
                    position = checkElementOrder("substitution", 29, position, false);
                    builder.substitution(parseMedicationDispenseSubstitution("substitution", reader, -1));
                    break;
                case "detectedIssue":
                    position = checkElementOrder("detectedIssue", 30, position, true);
                    builder.detectedIssue(parseReference("detectedIssue", reader, detectedIssueElementIndex++));
                    break;
                case "eventHistory":
                    position = checkElementOrder("eventHistory", 31, position, true);
                    builder.eventHistory(parseReference("eventHistory", reader, eventHistoryElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationDispense.Performer parseMedicationDispensePerformer(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationDispense.Performer.Builder builder = MedicationDispense.Performer.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "function":
                    position = checkElementOrder("function", 2, position, false);
                    builder.function(parseCodeableConcept("function", reader, -1));
                    break;
                case "actor":
                    position = checkElementOrder("actor", 3, position, false);
                    builder.actor(parseReference("actor", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationDispense.Substitution parseMedicationDispenseSubstitution(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationDispense.Substitution.Builder builder = MedicationDispense.Substitution.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, reasonElementIndex = 0, responsiblePartyElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "wasSubstituted":
                    position = checkElementOrder("wasSubstituted", 2, position, false);
                    builder.wasSubstituted(parseBoolean("wasSubstituted", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "reason":
                    position = checkElementOrder("reason", 4, position, true);
                    builder.reason(parseCodeableConcept("reason", reader, reasonElementIndex++));
                    break;
                case "responsibleParty":
                    position = checkElementOrder("responsibleParty", 5, position, true);
                    builder.responsibleParty(parseReference("responsibleParty", reader, responsiblePartyElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationKnowledge parseMedicationKnowledge(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationKnowledge.Builder builder = MedicationKnowledge.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, synonymElementIndex = 0, relatedMedicationKnowledgeElementIndex = 0, associatedMedicationElementIndex = 0, productTypeElementIndex = 0, monographElementIndex = 0, ingredientElementIndex = 0, intendedRouteElementIndex = 0, costElementIndex = 0, monitoringProgramElementIndex = 0, administrationGuidelinesElementIndex = 0, medicineClassificationElementIndex = 0, drugCharacteristicElementIndex = 0, contraindicationElementIndex = 0, regulatoryElementIndex = 0, kineticsElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 8, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((MedicationKnowledgeStatus) parseString(MedicationKnowledgeStatus.builder(), "status", reader, -1));
                    break;
                case "manufacturer":
                    position = checkElementOrder("manufacturer", 10, position, false);
                    builder.manufacturer(parseReference("manufacturer", reader, -1));
                    break;
                case "doseForm":
                    position = checkElementOrder("doseForm", 11, position, false);
                    builder.doseForm(parseCodeableConcept("doseForm", reader, -1));
                    break;
                case "amount":
                    position = checkElementOrder("amount", 12, position, false);
                    builder.amount((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "amount", reader, -1));
                    break;
                case "synonym":
                    position = checkElementOrder("synonym", 13, position, true);
                    builder.synonym(parseString("synonym", reader, synonymElementIndex++));
                    break;
                case "relatedMedicationKnowledge":
                    position = checkElementOrder("relatedMedicationKnowledge", 14, position, true);
                    builder.relatedMedicationKnowledge(parseMedicationKnowledgeRelatedMedicationKnowledge("relatedMedicationKnowledge", reader, relatedMedicationKnowledgeElementIndex++));
                    break;
                case "associatedMedication":
                    position = checkElementOrder("associatedMedication", 15, position, true);
                    builder.associatedMedication(parseReference("associatedMedication", reader, associatedMedicationElementIndex++));
                    break;
                case "productType":
                    position = checkElementOrder("productType", 16, position, true);
                    builder.productType(parseCodeableConcept("productType", reader, productTypeElementIndex++));
                    break;
                case "monograph":
                    position = checkElementOrder("monograph", 17, position, true);
                    builder.monograph(parseMedicationKnowledgeMonograph("monograph", reader, monographElementIndex++));
                    break;
                case "ingredient":
                    position = checkElementOrder("ingredient", 18, position, true);
                    builder.ingredient(parseMedicationKnowledgeIngredient("ingredient", reader, ingredientElementIndex++));
                    break;
                case "preparationInstruction":
                    position = checkElementOrder("preparationInstruction", 19, position, false);
                    builder.preparationInstruction((Markdown) parseString(Markdown.builder(), "preparationInstruction", reader, -1));
                    break;
                case "intendedRoute":
                    position = checkElementOrder("intendedRoute", 20, position, true);
                    builder.intendedRoute(parseCodeableConcept("intendedRoute", reader, intendedRouteElementIndex++));
                    break;
                case "cost":
                    position = checkElementOrder("cost", 21, position, true);
                    builder.cost(parseMedicationKnowledgeCost("cost", reader, costElementIndex++));
                    break;
                case "monitoringProgram":
                    position = checkElementOrder("monitoringProgram", 22, position, true);
                    builder.monitoringProgram(parseMedicationKnowledgeMonitoringProgram("monitoringProgram", reader, monitoringProgramElementIndex++));
                    break;
                case "administrationGuidelines":
                    position = checkElementOrder("administrationGuidelines", 23, position, true);
                    builder.administrationGuidelines(parseMedicationKnowledgeAdministrationGuidelines("administrationGuidelines", reader, administrationGuidelinesElementIndex++));
                    break;
                case "medicineClassification":
                    position = checkElementOrder("medicineClassification", 24, position, true);
                    builder.medicineClassification(parseMedicationKnowledgeMedicineClassification("medicineClassification", reader, medicineClassificationElementIndex++));
                    break;
                case "packaging":
                    position = checkElementOrder("packaging", 25, position, false);
                    builder.packaging(parseMedicationKnowledgePackaging("packaging", reader, -1));
                    break;
                case "drugCharacteristic":
                    position = checkElementOrder("drugCharacteristic", 26, position, true);
                    builder.drugCharacteristic(parseMedicationKnowledgeDrugCharacteristic("drugCharacteristic", reader, drugCharacteristicElementIndex++));
                    break;
                case "contraindication":
                    position = checkElementOrder("contraindication", 27, position, true);
                    builder.contraindication(parseReference("contraindication", reader, contraindicationElementIndex++));
                    break;
                case "regulatory":
                    position = checkElementOrder("regulatory", 28, position, true);
                    builder.regulatory(parseMedicationKnowledgeRegulatory("regulatory", reader, regulatoryElementIndex++));
                    break;
                case "kinetics":
                    position = checkElementOrder("kinetics", 29, position, true);
                    builder.kinetics(parseMedicationKnowledgeKinetics("kinetics", reader, kineticsElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationKnowledge.AdministrationGuidelines parseMedicationKnowledgeAdministrationGuidelines(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationKnowledge.AdministrationGuidelines.Builder builder = MedicationKnowledge.AdministrationGuidelines.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, dosageElementIndex = 0, patientCharacteristicsElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "dosage":
                    position = checkElementOrder("dosage", 2, position, true);
                    builder.dosage(parseMedicationKnowledgeAdministrationGuidelinesDosage("dosage", reader, dosageElementIndex++));
                    break;
                case "indicationCodeableConcept":
                    position = checkElementOrder("indication[x]", 3, position, false);
                    builder.indication(parseCodeableConcept("indicationCodeableConcept", reader, -1));
                    break;
                case "indicationReference":
                    position = checkElementOrder("indication[x]", 3, position, false);
                    builder.indication(parseReference("indicationReference", reader, -1));
                    break;
                case "patientCharacteristics":
                    position = checkElementOrder("patientCharacteristics", 4, position, true);
                    builder.patientCharacteristics(parseMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics("patientCharacteristics", reader, patientCharacteristicsElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationKnowledge.AdministrationGuidelines.Dosage parseMedicationKnowledgeAdministrationGuidelinesDosage(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationKnowledge.AdministrationGuidelines.Dosage.Builder builder = MedicationKnowledge.AdministrationGuidelines.Dosage.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, dosageElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "dosage":
                    position = checkElementOrder("dosage", 3, position, true);
                    builder.dosage(parseDosage("dosage", reader, dosageElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationKnowledge.AdministrationGuidelines.PatientCharacteristics parseMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationKnowledge.AdministrationGuidelines.PatientCharacteristics.Builder builder = MedicationKnowledge.AdministrationGuidelines.PatientCharacteristics.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, valueElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "characteristicCodeableConcept":
                    position = checkElementOrder("characteristic[x]", 2, position, false);
                    builder.characteristic(parseCodeableConcept("characteristicCodeableConcept", reader, -1));
                    break;
                case "characteristicQuantity":
                    position = checkElementOrder("characteristic[x]", 2, position, false);
                    builder.characteristic((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "characteristicQuantity", reader, -1));
                    break;
                case "value":
                    position = checkElementOrder("value", 3, position, true);
                    builder.value(parseString("value", reader, valueElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationKnowledge.Cost parseMedicationKnowledgeCost(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationKnowledge.Cost.Builder builder = MedicationKnowledge.Cost.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "source":
                    position = checkElementOrder("source", 3, position, false);
                    builder.source(parseString("source", reader, -1));
                    break;
                case "cost":
                    position = checkElementOrder("cost", 4, position, false);
                    builder.cost(parseMoney("cost", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationKnowledge.DrugCharacteristic parseMedicationKnowledgeDrugCharacteristic(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationKnowledge.DrugCharacteristic.Builder builder = MedicationKnowledge.DrugCharacteristic.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "valueCodeableConcept":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCodeableConcept("valueCodeableConcept", reader, -1));
                    break;
                case "valueString":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseString("valueString", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "valueQuantity", reader, -1));
                    break;
                case "valueBase64Binary":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBase64Binary("valueBase64Binary", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationKnowledge.Ingredient parseMedicationKnowledgeIngredient(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationKnowledge.Ingredient.Builder builder = MedicationKnowledge.Ingredient.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "itemCodeableConcept":
                    position = checkElementOrder("item[x]", 2, position, false);
                    builder.item(parseCodeableConcept("itemCodeableConcept", reader, -1));
                    break;
                case "itemReference":
                    position = checkElementOrder("item[x]", 2, position, false);
                    builder.item(parseReference("itemReference", reader, -1));
                    break;
                case "isActive":
                    position = checkElementOrder("isActive", 3, position, false);
                    builder.isActive(parseBoolean("isActive", reader, -1));
                    break;
                case "strength":
                    position = checkElementOrder("strength", 4, position, false);
                    builder.strength(parseRatio("strength", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationKnowledge.Kinetics parseMedicationKnowledgeKinetics(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationKnowledge.Kinetics.Builder builder = MedicationKnowledge.Kinetics.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, areaUnderCurveElementIndex = 0, lethalDose50ElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "areaUnderCurve":
                    position = checkElementOrder("areaUnderCurve", 2, position, true);
                    builder.areaUnderCurve((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "areaUnderCurve", reader, areaUnderCurveElementIndex++));
                    break;
                case "lethalDose50":
                    position = checkElementOrder("lethalDose50", 3, position, true);
                    builder.lethalDose50((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "lethalDose50", reader, lethalDose50ElementIndex++));
                    break;
                case "halfLifePeriod":
                    position = checkElementOrder("halfLifePeriod", 4, position, false);
                    builder.halfLifePeriod((Duration) parseQuantity(Duration.builder(), "halfLifePeriod", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationKnowledge.MedicineClassification parseMedicationKnowledgeMedicineClassification(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationKnowledge.MedicineClassification.Builder builder = MedicationKnowledge.MedicineClassification.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, classificationElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "classification":
                    position = checkElementOrder("classification", 3, position, true);
                    builder.classification(parseCodeableConcept("classification", reader, classificationElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationKnowledge.MonitoringProgram parseMedicationKnowledgeMonitoringProgram(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationKnowledge.MonitoringProgram.Builder builder = MedicationKnowledge.MonitoringProgram.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 3, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationKnowledge.Monograph parseMedicationKnowledgeMonograph(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationKnowledge.Monograph.Builder builder = MedicationKnowledge.Monograph.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "source":
                    position = checkElementOrder("source", 3, position, false);
                    builder.source(parseReference("source", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationKnowledge.Packaging parseMedicationKnowledgePackaging(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationKnowledge.Packaging.Builder builder = MedicationKnowledge.Packaging.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 3, position, false);
                    builder.quantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "quantity", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationKnowledge.Regulatory parseMedicationKnowledgeRegulatory(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationKnowledge.Regulatory.Builder builder = MedicationKnowledge.Regulatory.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, substitutionElementIndex = 0, scheduleElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "regulatoryAuthority":
                    position = checkElementOrder("regulatoryAuthority", 2, position, false);
                    builder.regulatoryAuthority(parseReference("regulatoryAuthority", reader, -1));
                    break;
                case "substitution":
                    position = checkElementOrder("substitution", 3, position, true);
                    builder.substitution(parseMedicationKnowledgeRegulatorySubstitution("substitution", reader, substitutionElementIndex++));
                    break;
                case "schedule":
                    position = checkElementOrder("schedule", 4, position, true);
                    builder.schedule(parseMedicationKnowledgeRegulatorySchedule("schedule", reader, scheduleElementIndex++));
                    break;
                case "maxDispense":
                    position = checkElementOrder("maxDispense", 5, position, false);
                    builder.maxDispense(parseMedicationKnowledgeRegulatoryMaxDispense("maxDispense", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationKnowledge.Regulatory.MaxDispense parseMedicationKnowledgeRegulatoryMaxDispense(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationKnowledge.Regulatory.MaxDispense.Builder builder = MedicationKnowledge.Regulatory.MaxDispense.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 2, position, false);
                    builder.quantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "quantity", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 3, position, false);
                    builder.period((Duration) parseQuantity(Duration.builder(), "period", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationKnowledge.Regulatory.Schedule parseMedicationKnowledgeRegulatorySchedule(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationKnowledge.Regulatory.Schedule.Builder builder = MedicationKnowledge.Regulatory.Schedule.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "schedule":
                    position = checkElementOrder("schedule", 2, position, false);
                    builder.schedule(parseCodeableConcept("schedule", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationKnowledge.Regulatory.Substitution parseMedicationKnowledgeRegulatorySubstitution(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationKnowledge.Regulatory.Substitution.Builder builder = MedicationKnowledge.Regulatory.Substitution.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "allowed":
                    position = checkElementOrder("allowed", 3, position, false);
                    builder.allowed(parseBoolean("allowed", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationKnowledge.RelatedMedicationKnowledge parseMedicationKnowledgeRelatedMedicationKnowledge(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationKnowledge.RelatedMedicationKnowledge.Builder builder = MedicationKnowledge.RelatedMedicationKnowledge.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, referenceElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "reference":
                    position = checkElementOrder("reference", 3, position, true);
                    builder.reference(parseReference("reference", reader, referenceElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationRequest parseMedicationRequest(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationRequest.Builder builder = MedicationRequest.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, categoryElementIndex = 0, supportingInformationElementIndex = 0, reasonCodeElementIndex = 0, reasonReferenceElementIndex = 0, instantiatesCanonicalElementIndex = 0, instantiatesUriElementIndex = 0, basedOnElementIndex = 0, insuranceElementIndex = 0, noteElementIndex = 0, dosageInstructionElementIndex = 0, detectedIssueElementIndex = 0, eventHistoryElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((MedicationRequestStatus) parseString(MedicationRequestStatus.builder(), "status", reader, -1));
                    break;
                case "statusReason":
                    position = checkElementOrder("statusReason", 10, position, false);
                    builder.statusReason(parseCodeableConcept("statusReason", reader, -1));
                    break;
                case "intent":
                    position = checkElementOrder("intent", 11, position, false);
                    builder.intent((MedicationRequestIntent) parseString(MedicationRequestIntent.builder(), "intent", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 12, position, true);
                    builder.category(parseCodeableConcept("category", reader, categoryElementIndex++));
                    break;
                case "priority":
                    position = checkElementOrder("priority", 13, position, false);
                    builder.priority((MedicationRequestPriority) parseString(MedicationRequestPriority.builder(), "priority", reader, -1));
                    break;
                case "doNotPerform":
                    position = checkElementOrder("doNotPerform", 14, position, false);
                    builder.doNotPerform(parseBoolean("doNotPerform", reader, -1));
                    break;
                case "reportedBoolean":
                    position = checkElementOrder("reported[x]", 15, position, false);
                    builder.reported(parseBoolean("reportedBoolean", reader, -1));
                    break;
                case "reportedReference":
                    position = checkElementOrder("reported[x]", 15, position, false);
                    builder.reported(parseReference("reportedReference", reader, -1));
                    break;
                case "medicationCodeableConcept":
                    position = checkElementOrder("medication[x]", 16, position, false);
                    builder.medication(parseCodeableConcept("medicationCodeableConcept", reader, -1));
                    break;
                case "medicationReference":
                    position = checkElementOrder("medication[x]", 16, position, false);
                    builder.medication(parseReference("medicationReference", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 17, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 18, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "supportingInformation":
                    position = checkElementOrder("supportingInformation", 19, position, true);
                    builder.supportingInformation(parseReference("supportingInformation", reader, supportingInformationElementIndex++));
                    break;
                case "authoredOn":
                    position = checkElementOrder("authoredOn", 20, position, false);
                    builder.authoredOn(parseDateTime("authoredOn", reader, -1));
                    break;
                case "requester":
                    position = checkElementOrder("requester", 21, position, false);
                    builder.requester(parseReference("requester", reader, -1));
                    break;
                case "performer":
                    position = checkElementOrder("performer", 22, position, false);
                    builder.performer(parseReference("performer", reader, -1));
                    break;
                case "performerType":
                    position = checkElementOrder("performerType", 23, position, false);
                    builder.performerType(parseCodeableConcept("performerType", reader, -1));
                    break;
                case "recorder":
                    position = checkElementOrder("recorder", 24, position, false);
                    builder.recorder(parseReference("recorder", reader, -1));
                    break;
                case "reasonCode":
                    position = checkElementOrder("reasonCode", 25, position, true);
                    builder.reasonCode(parseCodeableConcept("reasonCode", reader, reasonCodeElementIndex++));
                    break;
                case "reasonReference":
                    position = checkElementOrder("reasonReference", 26, position, true);
                    builder.reasonReference(parseReference("reasonReference", reader, reasonReferenceElementIndex++));
                    break;
                case "instantiatesCanonical":
                    position = checkElementOrder("instantiatesCanonical", 27, position, true);
                    builder.instantiatesCanonical((Canonical) parseUri(Canonical.builder(), "instantiatesCanonical", reader, instantiatesCanonicalElementIndex++));
                    break;
                case "instantiatesUri":
                    position = checkElementOrder("instantiatesUri", 28, position, true);
                    builder.instantiatesUri(parseUri("instantiatesUri", reader, instantiatesUriElementIndex++));
                    break;
                case "basedOn":
                    position = checkElementOrder("basedOn", 29, position, true);
                    builder.basedOn(parseReference("basedOn", reader, basedOnElementIndex++));
                    break;
                case "groupIdentifier":
                    position = checkElementOrder("groupIdentifier", 30, position, false);
                    builder.groupIdentifier(parseIdentifier("groupIdentifier", reader, -1));
                    break;
                case "courseOfTherapyType":
                    position = checkElementOrder("courseOfTherapyType", 31, position, false);
                    builder.courseOfTherapyType(parseCodeableConcept("courseOfTherapyType", reader, -1));
                    break;
                case "insurance":
                    position = checkElementOrder("insurance", 32, position, true);
                    builder.insurance(parseReference("insurance", reader, insuranceElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 33, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "dosageInstruction":
                    position = checkElementOrder("dosageInstruction", 34, position, true);
                    builder.dosageInstruction(parseDosage("dosageInstruction", reader, dosageInstructionElementIndex++));
                    break;
                case "dispenseRequest":
                    position = checkElementOrder("dispenseRequest", 35, position, false);
                    builder.dispenseRequest(parseMedicationRequestDispenseRequest("dispenseRequest", reader, -1));
                    break;
                case "substitution":
                    position = checkElementOrder("substitution", 36, position, false);
                    builder.substitution(parseMedicationRequestSubstitution("substitution", reader, -1));
                    break;
                case "priorPrescription":
                    position = checkElementOrder("priorPrescription", 37, position, false);
                    builder.priorPrescription(parseReference("priorPrescription", reader, -1));
                    break;
                case "detectedIssue":
                    position = checkElementOrder("detectedIssue", 38, position, true);
                    builder.detectedIssue(parseReference("detectedIssue", reader, detectedIssueElementIndex++));
                    break;
                case "eventHistory":
                    position = checkElementOrder("eventHistory", 39, position, true);
                    builder.eventHistory(parseReference("eventHistory", reader, eventHistoryElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationRequest.DispenseRequest parseMedicationRequestDispenseRequest(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationRequest.DispenseRequest.Builder builder = MedicationRequest.DispenseRequest.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "initialFill":
                    position = checkElementOrder("initialFill", 2, position, false);
                    builder.initialFill(parseMedicationRequestDispenseRequestInitialFill("initialFill", reader, -1));
                    break;
                case "dispenseInterval":
                    position = checkElementOrder("dispenseInterval", 3, position, false);
                    builder.dispenseInterval((Duration) parseQuantity(Duration.builder(), "dispenseInterval", reader, -1));
                    break;
                case "validityPeriod":
                    position = checkElementOrder("validityPeriod", 4, position, false);
                    builder.validityPeriod(parsePeriod("validityPeriod", reader, -1));
                    break;
                case "numberOfRepeatsAllowed":
                    position = checkElementOrder("numberOfRepeatsAllowed", 5, position, false);
                    builder.numberOfRepeatsAllowed((UnsignedInt) parseInteger(UnsignedInt.builder(), "numberOfRepeatsAllowed", reader, -1));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 6, position, false);
                    builder.quantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "quantity", reader, -1));
                    break;
                case "expectedSupplyDuration":
                    position = checkElementOrder("expectedSupplyDuration", 7, position, false);
                    builder.expectedSupplyDuration((Duration) parseQuantity(Duration.builder(), "expectedSupplyDuration", reader, -1));
                    break;
                case "performer":
                    position = checkElementOrder("performer", 8, position, false);
                    builder.performer(parseReference("performer", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationRequest.DispenseRequest.InitialFill parseMedicationRequestDispenseRequestInitialFill(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationRequest.DispenseRequest.InitialFill.Builder builder = MedicationRequest.DispenseRequest.InitialFill.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 2, position, false);
                    builder.quantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "quantity", reader, -1));
                    break;
                case "duration":
                    position = checkElementOrder("duration", 3, position, false);
                    builder.duration((Duration) parseQuantity(Duration.builder(), "duration", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationRequest.Substitution parseMedicationRequestSubstitution(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationRequest.Substitution.Builder builder = MedicationRequest.Substitution.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "allowedBoolean":
                    position = checkElementOrder("allowed[x]", 2, position, false);
                    builder.allowed(parseBoolean("allowedBoolean", reader, -1));
                    break;
                case "allowedCodeableConcept":
                    position = checkElementOrder("allowed[x]", 2, position, false);
                    builder.allowed(parseCodeableConcept("allowedCodeableConcept", reader, -1));
                    break;
                case "reason":
                    position = checkElementOrder("reason", 3, position, false);
                    builder.reason(parseCodeableConcept("reason", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicationStatement parseMedicationStatement(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicationStatement.Builder builder = MedicationStatement.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, basedOnElementIndex = 0, partOfElementIndex = 0, statusReasonElementIndex = 0, derivedFromElementIndex = 0, reasonCodeElementIndex = 0, reasonReferenceElementIndex = 0, noteElementIndex = 0, dosageElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "basedOn":
                    position = checkElementOrder("basedOn", 9, position, true);
                    builder.basedOn(parseReference("basedOn", reader, basedOnElementIndex++));
                    break;
                case "partOf":
                    position = checkElementOrder("partOf", 10, position, true);
                    builder.partOf(parseReference("partOf", reader, partOfElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 11, position, false);
                    builder.status((MedicationStatementStatus) parseString(MedicationStatementStatus.builder(), "status", reader, -1));
                    break;
                case "statusReason":
                    position = checkElementOrder("statusReason", 12, position, true);
                    builder.statusReason(parseCodeableConcept("statusReason", reader, statusReasonElementIndex++));
                    break;
                case "category":
                    position = checkElementOrder("category", 13, position, false);
                    builder.category(parseCodeableConcept("category", reader, -1));
                    break;
                case "medicationCodeableConcept":
                    position = checkElementOrder("medication[x]", 14, position, false);
                    builder.medication(parseCodeableConcept("medicationCodeableConcept", reader, -1));
                    break;
                case "medicationReference":
                    position = checkElementOrder("medication[x]", 14, position, false);
                    builder.medication(parseReference("medicationReference", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 15, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "context":
                    position = checkElementOrder("context", 16, position, false);
                    builder.context(parseReference("context", reader, -1));
                    break;
                case "effectiveDateTime":
                    position = checkElementOrder("effective[x]", 17, position, false);
                    builder.effective(parseDateTime("effectiveDateTime", reader, -1));
                    break;
                case "effectivePeriod":
                    position = checkElementOrder("effective[x]", 17, position, false);
                    builder.effective(parsePeriod("effectivePeriod", reader, -1));
                    break;
                case "dateAsserted":
                    position = checkElementOrder("dateAsserted", 18, position, false);
                    builder.dateAsserted(parseDateTime("dateAsserted", reader, -1));
                    break;
                case "informationSource":
                    position = checkElementOrder("informationSource", 19, position, false);
                    builder.informationSource(parseReference("informationSource", reader, -1));
                    break;
                case "derivedFrom":
                    position = checkElementOrder("derivedFrom", 20, position, true);
                    builder.derivedFrom(parseReference("derivedFrom", reader, derivedFromElementIndex++));
                    break;
                case "reasonCode":
                    position = checkElementOrder("reasonCode", 21, position, true);
                    builder.reasonCode(parseCodeableConcept("reasonCode", reader, reasonCodeElementIndex++));
                    break;
                case "reasonReference":
                    position = checkElementOrder("reasonReference", 22, position, true);
                    builder.reasonReference(parseReference("reasonReference", reader, reasonReferenceElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 23, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "dosage":
                    position = checkElementOrder("dosage", 24, position, true);
                    builder.dosage(parseDosage("dosage", reader, dosageElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicinalProductDefinition parseMedicinalProductDefinition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicinalProductDefinition.Builder builder = MedicinalProductDefinition.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, routeElementIndex = 0, specialMeasuresElementIndex = 0, classificationElementIndex = 0, marketingStatusElementIndex = 0, packagedMedicinalProductElementIndex = 0, ingredientElementIndex = 0, impurityElementIndex = 0, attachedDocumentElementIndex = 0, masterFileElementIndex = 0, contactElementIndex = 0, clinicalTrialElementIndex = 0, codeElementIndex = 0, nameElementIndex = 0, crossReferenceElementIndex = 0, operationElementIndex = 0, characteristicElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 9, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "domain":
                    position = checkElementOrder("domain", 10, position, false);
                    builder.domain(parseCodeableConcept("domain", reader, -1));
                    break;
                case "version":
                    position = checkElementOrder("version", 11, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 12, position, false);
                    builder.status(parseCodeableConcept("status", reader, -1));
                    break;
                case "statusDate":
                    position = checkElementOrder("statusDate", 13, position, false);
                    builder.statusDate(parseDateTime("statusDate", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 14, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "combinedPharmaceuticalDoseForm":
                    position = checkElementOrder("combinedPharmaceuticalDoseForm", 15, position, false);
                    builder.combinedPharmaceuticalDoseForm(parseCodeableConcept("combinedPharmaceuticalDoseForm", reader, -1));
                    break;
                case "route":
                    position = checkElementOrder("route", 16, position, true);
                    builder.route(parseCodeableConcept("route", reader, routeElementIndex++));
                    break;
                case "indication":
                    position = checkElementOrder("indication", 17, position, false);
                    builder.indication((Markdown) parseString(Markdown.builder(), "indication", reader, -1));
                    break;
                case "legalStatusOfSupply":
                    position = checkElementOrder("legalStatusOfSupply", 18, position, false);
                    builder.legalStatusOfSupply(parseCodeableConcept("legalStatusOfSupply", reader, -1));
                    break;
                case "additionalMonitoringIndicator":
                    position = checkElementOrder("additionalMonitoringIndicator", 19, position, false);
                    builder.additionalMonitoringIndicator(parseCodeableConcept("additionalMonitoringIndicator", reader, -1));
                    break;
                case "specialMeasures":
                    position = checkElementOrder("specialMeasures", 20, position, true);
                    builder.specialMeasures(parseCodeableConcept("specialMeasures", reader, specialMeasuresElementIndex++));
                    break;
                case "pediatricUseIndicator":
                    position = checkElementOrder("pediatricUseIndicator", 21, position, false);
                    builder.pediatricUseIndicator(parseCodeableConcept("pediatricUseIndicator", reader, -1));
                    break;
                case "classification":
                    position = checkElementOrder("classification", 22, position, true);
                    builder.classification(parseCodeableConcept("classification", reader, classificationElementIndex++));
                    break;
                case "marketingStatus":
                    position = checkElementOrder("marketingStatus", 23, position, true);
                    builder.marketingStatus(parseMarketingStatus("marketingStatus", reader, marketingStatusElementIndex++));
                    break;
                case "packagedMedicinalProduct":
                    position = checkElementOrder("packagedMedicinalProduct", 24, position, true);
                    builder.packagedMedicinalProduct(parseCodeableConcept("packagedMedicinalProduct", reader, packagedMedicinalProductElementIndex++));
                    break;
                case "ingredient":
                    position = checkElementOrder("ingredient", 25, position, true);
                    builder.ingredient(parseCodeableConcept("ingredient", reader, ingredientElementIndex++));
                    break;
                case "impurity":
                    position = checkElementOrder("impurity", 26, position, true);
                    builder.impurity(parseCodeableReference("impurity", reader, impurityElementIndex++));
                    break;
                case "attachedDocument":
                    position = checkElementOrder("attachedDocument", 27, position, true);
                    builder.attachedDocument(parseReference("attachedDocument", reader, attachedDocumentElementIndex++));
                    break;
                case "masterFile":
                    position = checkElementOrder("masterFile", 28, position, true);
                    builder.masterFile(parseReference("masterFile", reader, masterFileElementIndex++));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 29, position, true);
                    builder.contact(parseMedicinalProductDefinitionContact("contact", reader, contactElementIndex++));
                    break;
                case "clinicalTrial":
                    position = checkElementOrder("clinicalTrial", 30, position, true);
                    builder.clinicalTrial(parseReference("clinicalTrial", reader, clinicalTrialElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 31, position, true);
                    builder.code(parseCoding("code", reader, codeElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 32, position, true);
                    builder.name(parseMedicinalProductDefinitionName("name", reader, nameElementIndex++));
                    break;
                case "crossReference":
                    position = checkElementOrder("crossReference", 33, position, true);
                    builder.crossReference(parseMedicinalProductDefinitionCrossReference("crossReference", reader, crossReferenceElementIndex++));
                    break;
                case "operation":
                    position = checkElementOrder("operation", 34, position, true);
                    builder.operation(parseMedicinalProductDefinitionOperation("operation", reader, operationElementIndex++));
                    break;
                case "characteristic":
                    position = checkElementOrder("characteristic", 35, position, true);
                    builder.characteristic(parseMedicinalProductDefinitionCharacteristic("characteristic", reader, characteristicElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicinalProductDefinition.Characteristic parseMedicinalProductDefinitionCharacteristic(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicinalProductDefinition.Characteristic.Builder builder = MedicinalProductDefinition.Characteristic.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "valueCodeableConcept":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCodeableConcept("valueCodeableConcept", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueDate":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDate("valueDate", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueAttachment":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseAttachment("valueAttachment", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicinalProductDefinition.Contact parseMedicinalProductDefinitionContact(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicinalProductDefinition.Contact.Builder builder = MedicinalProductDefinition.Contact.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 3, position, false);
                    builder.contact(parseReference("contact", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicinalProductDefinition.CrossReference parseMedicinalProductDefinitionCrossReference(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicinalProductDefinition.CrossReference.Builder builder = MedicinalProductDefinition.CrossReference.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "product":
                    position = checkElementOrder("product", 2, position, false);
                    builder.product(parseCodeableReference("product", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicinalProductDefinition.Name parseMedicinalProductDefinitionName(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicinalProductDefinition.Name.Builder builder = MedicinalProductDefinition.Name.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, namePartElementIndex = 0, countryLanguageElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "productName":
                    position = checkElementOrder("productName", 2, position, false);
                    builder.productName(parseString("productName", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "namePart":
                    position = checkElementOrder("namePart", 4, position, true);
                    builder.namePart(parseMedicinalProductDefinitionNameNamePart("namePart", reader, namePartElementIndex++));
                    break;
                case "countryLanguage":
                    position = checkElementOrder("countryLanguage", 5, position, true);
                    builder.countryLanguage(parseMedicinalProductDefinitionNameCountryLanguage("countryLanguage", reader, countryLanguageElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicinalProductDefinition.Name.CountryLanguage parseMedicinalProductDefinitionNameCountryLanguage(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicinalProductDefinition.Name.CountryLanguage.Builder builder = MedicinalProductDefinition.Name.CountryLanguage.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "country":
                    position = checkElementOrder("country", 2, position, false);
                    builder.country(parseCodeableConcept("country", reader, -1));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 3, position, false);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 4, position, false);
                    builder.language(parseCodeableConcept("language", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicinalProductDefinition.Name.NamePart parseMedicinalProductDefinitionNameNamePart(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicinalProductDefinition.Name.NamePart.Builder builder = MedicinalProductDefinition.Name.NamePart.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "part":
                    position = checkElementOrder("part", 2, position, false);
                    builder.part(parseString("part", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MedicinalProductDefinition.Operation parseMedicinalProductDefinitionOperation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MedicinalProductDefinition.Operation.Builder builder = MedicinalProductDefinition.Operation.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, organizationElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableReference("type", reader, -1));
                    break;
                case "effectiveDate":
                    position = checkElementOrder("effectiveDate", 3, position, false);
                    builder.effectiveDate(parsePeriod("effectiveDate", reader, -1));
                    break;
                case "organization":
                    position = checkElementOrder("organization", 4, position, true);
                    builder.organization(parseReference("organization", reader, organizationElementIndex++));
                    break;
                case "confidentialityIndicator":
                    position = checkElementOrder("confidentialityIndicator", 5, position, false);
                    builder.confidentialityIndicator(parseCodeableConcept("confidentialityIndicator", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MessageDefinition parseMessageDefinition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MessageDefinition.Builder builder = MessageDefinition.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, replacesElementIndex = 0, contactElementIndex = 0, useContextElementIndex = 0, jurisdictionElementIndex = 0, parentElementIndex = 0, focusElementIndex = 0, allowedResponseElementIndex = 0, graphElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 10, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 11, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 12, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "replaces":
                    position = checkElementOrder("replaces", 13, position, true);
                    builder.replaces((Canonical) parseUri(Canonical.builder(), "replaces", reader, replacesElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 14, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 15, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 16, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 17, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 18, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 19, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 20, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 21, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 22, position, false);
                    builder.purpose((Markdown) parseString(Markdown.builder(), "purpose", reader, -1));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 23, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                case "base":
                    position = checkElementOrder("base", 24, position, false);
                    builder.base((Canonical) parseUri(Canonical.builder(), "base", reader, -1));
                    break;
                case "parent":
                    position = checkElementOrder("parent", 25, position, true);
                    builder.parent((Canonical) parseUri(Canonical.builder(), "parent", reader, parentElementIndex++));
                    break;
                case "eventCoding":
                    position = checkElementOrder("event[x]", 26, position, false);
                    builder.event(parseCoding("eventCoding", reader, -1));
                    break;
                case "eventUri":
                    position = checkElementOrder("event[x]", 26, position, false);
                    builder.event(parseUri("eventUri", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 27, position, false);
                    builder.category((MessageSignificanceCategory) parseString(MessageSignificanceCategory.builder(), "category", reader, -1));
                    break;
                case "focus":
                    position = checkElementOrder("focus", 28, position, true);
                    builder.focus(parseMessageDefinitionFocus("focus", reader, focusElementIndex++));
                    break;
                case "responseRequired":
                    position = checkElementOrder("responseRequired", 29, position, false);
                    builder.responseRequired((MessageHeaderResponseRequest) parseString(MessageHeaderResponseRequest.builder(), "responseRequired", reader, -1));
                    break;
                case "allowedResponse":
                    position = checkElementOrder("allowedResponse", 30, position, true);
                    builder.allowedResponse(parseMessageDefinitionAllowedResponse("allowedResponse", reader, allowedResponseElementIndex++));
                    break;
                case "graph":
                    position = checkElementOrder("graph", 31, position, true);
                    builder.graph((Canonical) parseUri(Canonical.builder(), "graph", reader, graphElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MessageDefinition.AllowedResponse parseMessageDefinitionAllowedResponse(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MessageDefinition.AllowedResponse.Builder builder = MessageDefinition.AllowedResponse.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "message":
                    position = checkElementOrder("message", 2, position, false);
                    builder.message((Canonical) parseUri(Canonical.builder(), "message", reader, -1));
                    break;
                case "situation":
                    position = checkElementOrder("situation", 3, position, false);
                    builder.situation((Markdown) parseString(Markdown.builder(), "situation", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MessageDefinition.Focus parseMessageDefinitionFocus(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MessageDefinition.Focus.Builder builder = MessageDefinition.Focus.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code((ResourceTypeCode) parseString(ResourceTypeCode.builder(), "code", reader, -1));
                    break;
                case "profile":
                    position = checkElementOrder("profile", 3, position, false);
                    builder.profile((Canonical) parseUri(Canonical.builder(), "profile", reader, -1));
                    break;
                case "min":
                    position = checkElementOrder("min", 4, position, false);
                    builder.min((UnsignedInt) parseInteger(UnsignedInt.builder(), "min", reader, -1));
                    break;
                case "max":
                    position = checkElementOrder("max", 5, position, false);
                    builder.max(parseString("max", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MessageHeader parseMessageHeader(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MessageHeader.Builder builder = MessageHeader.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, destinationElementIndex = 0, focusElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "eventCoding":
                    position = checkElementOrder("event[x]", 8, position, false);
                    builder.event(parseCoding("eventCoding", reader, -1));
                    break;
                case "eventUri":
                    position = checkElementOrder("event[x]", 8, position, false);
                    builder.event(parseUri("eventUri", reader, -1));
                    break;
                case "destination":
                    position = checkElementOrder("destination", 9, position, true);
                    builder.destination(parseMessageHeaderDestination("destination", reader, destinationElementIndex++));
                    break;
                case "sender":
                    position = checkElementOrder("sender", 10, position, false);
                    builder.sender(parseReference("sender", reader, -1));
                    break;
                case "enterer":
                    position = checkElementOrder("enterer", 11, position, false);
                    builder.enterer(parseReference("enterer", reader, -1));
                    break;
                case "author":
                    position = checkElementOrder("author", 12, position, false);
                    builder.author(parseReference("author", reader, -1));
                    break;
                case "source":
                    position = checkElementOrder("source", 13, position, false);
                    builder.source(parseMessageHeaderSource("source", reader, -1));
                    break;
                case "responsible":
                    position = checkElementOrder("responsible", 14, position, false);
                    builder.responsible(parseReference("responsible", reader, -1));
                    break;
                case "reason":
                    position = checkElementOrder("reason", 15, position, false);
                    builder.reason(parseCodeableConcept("reason", reader, -1));
                    break;
                case "response":
                    position = checkElementOrder("response", 16, position, false);
                    builder.response(parseMessageHeaderResponse("response", reader, -1));
                    break;
                case "focus":
                    position = checkElementOrder("focus", 17, position, true);
                    builder.focus(parseReference("focus", reader, focusElementIndex++));
                    break;
                case "definition":
                    position = checkElementOrder("definition", 18, position, false);
                    builder.definition((Canonical) parseUri(Canonical.builder(), "definition", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MessageHeader.Destination parseMessageHeaderDestination(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MessageHeader.Destination.Builder builder = MessageHeader.Destination.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "target":
                    position = checkElementOrder("target", 3, position, false);
                    builder.target(parseReference("target", reader, -1));
                    break;
                case "endpoint":
                    position = checkElementOrder("endpoint", 4, position, false);
                    builder.endpoint((Url) parseUri(Url.builder(), "endpoint", reader, -1));
                    break;
                case "receiver":
                    position = checkElementOrder("receiver", 5, position, false);
                    builder.receiver(parseReference("receiver", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MessageHeader.Response parseMessageHeaderResponse(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MessageHeader.Response.Builder builder = MessageHeader.Response.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 2, position, false);
                    builder.identifier((Id) parseString(Id.builder(), "identifier", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 3, position, false);
                    builder.code((ResponseType) parseString(ResponseType.builder(), "code", reader, -1));
                    break;
                case "details":
                    position = checkElementOrder("details", 4, position, false);
                    builder.details(parseReference("details", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MessageHeader.Source parseMessageHeaderSource(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MessageHeader.Source.Builder builder = MessageHeader.Source.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "software":
                    position = checkElementOrder("software", 3, position, false);
                    builder.software(parseString("software", reader, -1));
                    break;
                case "version":
                    position = checkElementOrder("version", 4, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 5, position, false);
                    builder.contact(parseContactPoint("contact", reader, -1));
                    break;
                case "endpoint":
                    position = checkElementOrder("endpoint", 6, position, false);
                    builder.endpoint((Url) parseUri(Url.builder(), "endpoint", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Meta parseMeta(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Meta.Builder builder = Meta.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, profileElementIndex = 0, securityElementIndex = 0, tagElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "versionId":
                    position = checkElementOrder("versionId", 1, position, false);
                    builder.versionId((Id) parseString(Id.builder(), "versionId", reader, -1));
                    break;
                case "lastUpdated":
                    position = checkElementOrder("lastUpdated", 2, position, false);
                    builder.lastUpdated(parseInstant("lastUpdated", reader, -1));
                    break;
                case "source":
                    position = checkElementOrder("source", 3, position, false);
                    builder.source(parseUri("source", reader, -1));
                    break;
                case "profile":
                    position = checkElementOrder("profile", 4, position, true);
                    builder.profile((Canonical) parseUri(Canonical.builder(), "profile", reader, profileElementIndex++));
                    break;
                case "security":
                    position = checkElementOrder("security", 5, position, true);
                    builder.security(parseCoding("security", reader, securityElementIndex++));
                    break;
                case "tag":
                    position = checkElementOrder("tag", 6, position, true);
                    builder.tag(parseCoding("tag", reader, tagElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MolecularSequence parseMolecularSequence(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MolecularSequence.Builder builder = MolecularSequence.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, variantElementIndex = 0, qualityElementIndex = 0, repositoryElementIndex = 0, pointerElementIndex = 0, structureVariantElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 9, position, false);
                    builder.type((SequenceType) parseString(SequenceType.builder(), "type", reader, -1));
                    break;
                case "coordinateSystem":
                    position = checkElementOrder("coordinateSystem", 10, position, false);
                    builder.coordinateSystem(parseInteger("coordinateSystem", reader, -1));
                    break;
                case "patient":
                    position = checkElementOrder("patient", 11, position, false);
                    builder.patient(parseReference("patient", reader, -1));
                    break;
                case "specimen":
                    position = checkElementOrder("specimen", 12, position, false);
                    builder.specimen(parseReference("specimen", reader, -1));
                    break;
                case "device":
                    position = checkElementOrder("device", 13, position, false);
                    builder.device(parseReference("device", reader, -1));
                    break;
                case "performer":
                    position = checkElementOrder("performer", 14, position, false);
                    builder.performer(parseReference("performer", reader, -1));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 15, position, false);
                    builder.quantity(parseQuantity("quantity", reader, -1));
                    break;
                case "referenceSeq":
                    position = checkElementOrder("referenceSeq", 16, position, false);
                    builder.referenceSeq(parseMolecularSequenceReferenceSeq("referenceSeq", reader, -1));
                    break;
                case "variant":
                    position = checkElementOrder("variant", 17, position, true);
                    builder.variant(parseMolecularSequenceVariant("variant", reader, variantElementIndex++));
                    break;
                case "observedSeq":
                    position = checkElementOrder("observedSeq", 18, position, false);
                    builder.observedSeq(parseString("observedSeq", reader, -1));
                    break;
                case "quality":
                    position = checkElementOrder("quality", 19, position, true);
                    builder.quality(parseMolecularSequenceQuality("quality", reader, qualityElementIndex++));
                    break;
                case "readCoverage":
                    position = checkElementOrder("readCoverage", 20, position, false);
                    builder.readCoverage(parseInteger("readCoverage", reader, -1));
                    break;
                case "repository":
                    position = checkElementOrder("repository", 21, position, true);
                    builder.repository(parseMolecularSequenceRepository("repository", reader, repositoryElementIndex++));
                    break;
                case "pointer":
                    position = checkElementOrder("pointer", 22, position, true);
                    builder.pointer(parseReference("pointer", reader, pointerElementIndex++));
                    break;
                case "structureVariant":
                    position = checkElementOrder("structureVariant", 23, position, true);
                    builder.structureVariant(parseMolecularSequenceStructureVariant("structureVariant", reader, structureVariantElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MolecularSequence.Quality parseMolecularSequenceQuality(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MolecularSequence.Quality.Builder builder = MolecularSequence.Quality.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type((QualityType) parseString(QualityType.builder(), "type", reader, -1));
                    break;
                case "standardSequence":
                    position = checkElementOrder("standardSequence", 3, position, false);
                    builder.standardSequence(parseCodeableConcept("standardSequence", reader, -1));
                    break;
                case "start":
                    position = checkElementOrder("start", 4, position, false);
                    builder.start(parseInteger("start", reader, -1));
                    break;
                case "end":
                    position = checkElementOrder("end", 5, position, false);
                    builder.end(parseInteger("end", reader, -1));
                    break;
                case "score":
                    position = checkElementOrder("score", 6, position, false);
                    builder.score(parseQuantity("score", reader, -1));
                    break;
                case "method":
                    position = checkElementOrder("method", 7, position, false);
                    builder.method(parseCodeableConcept("method", reader, -1));
                    break;
                case "truthTP":
                    position = checkElementOrder("truthTP", 8, position, false);
                    builder.truthTP(parseDecimal("truthTP", reader, -1));
                    break;
                case "queryTP":
                    position = checkElementOrder("queryTP", 9, position, false);
                    builder.queryTP(parseDecimal("queryTP", reader, -1));
                    break;
                case "truthFN":
                    position = checkElementOrder("truthFN", 10, position, false);
                    builder.truthFN(parseDecimal("truthFN", reader, -1));
                    break;
                case "queryFP":
                    position = checkElementOrder("queryFP", 11, position, false);
                    builder.queryFP(parseDecimal("queryFP", reader, -1));
                    break;
                case "gtFP":
                    position = checkElementOrder("gtFP", 12, position, false);
                    builder.gtFP(parseDecimal("gtFP", reader, -1));
                    break;
                case "precision":
                    position = checkElementOrder("precision", 13, position, false);
                    builder.precision(parseDecimal("precision", reader, -1));
                    break;
                case "recall":
                    position = checkElementOrder("recall", 14, position, false);
                    builder.recall(parseDecimal("recall", reader, -1));
                    break;
                case "fScore":
                    position = checkElementOrder("fScore", 15, position, false);
                    builder.fScore(parseDecimal("fScore", reader, -1));
                    break;
                case "roc":
                    position = checkElementOrder("roc", 16, position, false);
                    builder.roc(parseMolecularSequenceQualityRoc("roc", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MolecularSequence.Quality.Roc parseMolecularSequenceQualityRoc(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MolecularSequence.Quality.Roc.Builder builder = MolecularSequence.Quality.Roc.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, scoreElementIndex = 0, numTPElementIndex = 0, numFPElementIndex = 0, numFNElementIndex = 0, precisionElementIndex = 0, sensitivityElementIndex = 0, fMeasureElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "score":
                    position = checkElementOrder("score", 2, position, true);
                    builder.score(parseInteger("score", reader, scoreElementIndex++));
                    break;
                case "numTP":
                    position = checkElementOrder("numTP", 3, position, true);
                    builder.numTP(parseInteger("numTP", reader, numTPElementIndex++));
                    break;
                case "numFP":
                    position = checkElementOrder("numFP", 4, position, true);
                    builder.numFP(parseInteger("numFP", reader, numFPElementIndex++));
                    break;
                case "numFN":
                    position = checkElementOrder("numFN", 5, position, true);
                    builder.numFN(parseInteger("numFN", reader, numFNElementIndex++));
                    break;
                case "precision":
                    position = checkElementOrder("precision", 6, position, true);
                    builder.precision(parseDecimal("precision", reader, precisionElementIndex++));
                    break;
                case "sensitivity":
                    position = checkElementOrder("sensitivity", 7, position, true);
                    builder.sensitivity(parseDecimal("sensitivity", reader, sensitivityElementIndex++));
                    break;
                case "fMeasure":
                    position = checkElementOrder("fMeasure", 8, position, true);
                    builder.fMeasure(parseDecimal("fMeasure", reader, fMeasureElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MolecularSequence.ReferenceSeq parseMolecularSequenceReferenceSeq(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MolecularSequence.ReferenceSeq.Builder builder = MolecularSequence.ReferenceSeq.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "chromosome":
                    position = checkElementOrder("chromosome", 2, position, false);
                    builder.chromosome(parseCodeableConcept("chromosome", reader, -1));
                    break;
                case "genomeBuild":
                    position = checkElementOrder("genomeBuild", 3, position, false);
                    builder.genomeBuild(parseString("genomeBuild", reader, -1));
                    break;
                case "orientation":
                    position = checkElementOrder("orientation", 4, position, false);
                    builder.orientation((OrientationType) parseString(OrientationType.builder(), "orientation", reader, -1));
                    break;
                case "referenceSeqId":
                    position = checkElementOrder("referenceSeqId", 5, position, false);
                    builder.referenceSeqId(parseCodeableConcept("referenceSeqId", reader, -1));
                    break;
                case "referenceSeqPointer":
                    position = checkElementOrder("referenceSeqPointer", 6, position, false);
                    builder.referenceSeqPointer(parseReference("referenceSeqPointer", reader, -1));
                    break;
                case "referenceSeqString":
                    position = checkElementOrder("referenceSeqString", 7, position, false);
                    builder.referenceSeqString(parseString("referenceSeqString", reader, -1));
                    break;
                case "strand":
                    position = checkElementOrder("strand", 8, position, false);
                    builder.strand((StrandType) parseString(StrandType.builder(), "strand", reader, -1));
                    break;
                case "windowStart":
                    position = checkElementOrder("windowStart", 9, position, false);
                    builder.windowStart(parseInteger("windowStart", reader, -1));
                    break;
                case "windowEnd":
                    position = checkElementOrder("windowEnd", 10, position, false);
                    builder.windowEnd(parseInteger("windowEnd", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MolecularSequence.Repository parseMolecularSequenceRepository(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MolecularSequence.Repository.Builder builder = MolecularSequence.Repository.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type((RepositoryType) parseString(RepositoryType.builder(), "type", reader, -1));
                    break;
                case "url":
                    position = checkElementOrder("url", 3, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 4, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "datasetId":
                    position = checkElementOrder("datasetId", 5, position, false);
                    builder.datasetId(parseString("datasetId", reader, -1));
                    break;
                case "variantsetId":
                    position = checkElementOrder("variantsetId", 6, position, false);
                    builder.variantsetId(parseString("variantsetId", reader, -1));
                    break;
                case "readsetId":
                    position = checkElementOrder("readsetId", 7, position, false);
                    builder.readsetId(parseString("readsetId", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MolecularSequence.StructureVariant parseMolecularSequenceStructureVariant(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MolecularSequence.StructureVariant.Builder builder = MolecularSequence.StructureVariant.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "variantType":
                    position = checkElementOrder("variantType", 2, position, false);
                    builder.variantType(parseCodeableConcept("variantType", reader, -1));
                    break;
                case "exact":
                    position = checkElementOrder("exact", 3, position, false);
                    builder.exact(parseBoolean("exact", reader, -1));
                    break;
                case "length":
                    position = checkElementOrder("length", 4, position, false);
                    builder.length(parseInteger("length", reader, -1));
                    break;
                case "outer":
                    position = checkElementOrder("outer", 5, position, false);
                    builder.outer(parseMolecularSequenceStructureVariantOuter("outer", reader, -1));
                    break;
                case "inner":
                    position = checkElementOrder("inner", 6, position, false);
                    builder.inner(parseMolecularSequenceStructureVariantInner("inner", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MolecularSequence.StructureVariant.Inner parseMolecularSequenceStructureVariantInner(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MolecularSequence.StructureVariant.Inner.Builder builder = MolecularSequence.StructureVariant.Inner.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "start":
                    position = checkElementOrder("start", 2, position, false);
                    builder.start(parseInteger("start", reader, -1));
                    break;
                case "end":
                    position = checkElementOrder("end", 3, position, false);
                    builder.end(parseInteger("end", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MolecularSequence.StructureVariant.Outer parseMolecularSequenceStructureVariantOuter(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MolecularSequence.StructureVariant.Outer.Builder builder = MolecularSequence.StructureVariant.Outer.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "start":
                    position = checkElementOrder("start", 2, position, false);
                    builder.start(parseInteger("start", reader, -1));
                    break;
                case "end":
                    position = checkElementOrder("end", 3, position, false);
                    builder.end(parseInteger("end", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private MolecularSequence.Variant parseMolecularSequenceVariant(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        MolecularSequence.Variant.Builder builder = MolecularSequence.Variant.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "start":
                    position = checkElementOrder("start", 2, position, false);
                    builder.start(parseInteger("start", reader, -1));
                    break;
                case "end":
                    position = checkElementOrder("end", 3, position, false);
                    builder.end(parseInteger("end", reader, -1));
                    break;
                case "observedAllele":
                    position = checkElementOrder("observedAllele", 4, position, false);
                    builder.observedAllele(parseString("observedAllele", reader, -1));
                    break;
                case "referenceAllele":
                    position = checkElementOrder("referenceAllele", 5, position, false);
                    builder.referenceAllele(parseString("referenceAllele", reader, -1));
                    break;
                case "cigar":
                    position = checkElementOrder("cigar", 6, position, false);
                    builder.cigar(parseString("cigar", reader, -1));
                    break;
                case "variantPointer":
                    position = checkElementOrder("variantPointer", 7, position, false);
                    builder.variantPointer(parseReference("variantPointer", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Money parseMoney(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Money.Builder builder = Money.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "value":
                    position = checkElementOrder("value", 1, position, false);
                    builder.value(parseDecimal("value", reader, -1));
                    break;
                case "currency":
                    position = checkElementOrder("currency", 2, position, false);
                    builder.currency((Code) parseString(Code.builder(), "currency", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private NamingSystem parseNamingSystem(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        NamingSystem.Builder builder = NamingSystem.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, contactElementIndex = 0, useContextElementIndex = 0, jurisdictionElementIndex = 0, uniqueIdElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 8, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "kind":
                    position = checkElementOrder("kind", 10, position, false);
                    builder.kind((NamingSystemType) parseString(NamingSystemType.builder(), "kind", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 11, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 12, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 13, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "responsible":
                    position = checkElementOrder("responsible", 14, position, false);
                    builder.responsible(parseString("responsible", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 15, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 16, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 17, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 18, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "usage":
                    position = checkElementOrder("usage", 19, position, false);
                    builder.usage(parseString("usage", reader, -1));
                    break;
                case "uniqueId":
                    position = checkElementOrder("uniqueId", 20, position, true);
                    builder.uniqueId(parseNamingSystemUniqueId("uniqueId", reader, uniqueIdElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private NamingSystem.UniqueId parseNamingSystemUniqueId(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        NamingSystem.UniqueId.Builder builder = NamingSystem.UniqueId.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type((NamingSystemIdentifierType) parseString(NamingSystemIdentifierType.builder(), "type", reader, -1));
                    break;
                case "value":
                    position = checkElementOrder("value", 3, position, false);
                    builder.value(parseString("value", reader, -1));
                    break;
                case "preferred":
                    position = checkElementOrder("preferred", 4, position, false);
                    builder.preferred(parseBoolean("preferred", reader, -1));
                    break;
                case "comment":
                    position = checkElementOrder("comment", 5, position, false);
                    builder.comment(parseString("comment", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 6, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Narrative parseNarrative(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Narrative.Builder builder = Narrative.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                if ("div".equals(localName)) {
                    requireNamespace(reader, XHTML_NS_URI);
                } else {
                    requireNamespace(reader, FHIR_NS_URI);
                }
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 1, position, false);
                    builder.status((NarrativeStatus) parseString(NarrativeStatus.builder(), "status", reader, -1));
                    break;
                case "div":
                    position = checkElementOrder("div", 2, position, false);
                    builder.div(parseXhtml("div", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private NutritionOrder parseNutritionOrder(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        NutritionOrder.Builder builder = NutritionOrder.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, instantiatesCanonicalElementIndex = 0, instantiatesUriElementIndex = 0, instantiatesElementIndex = 0, allergyIntoleranceElementIndex = 0, foodPreferenceModifierElementIndex = 0, excludeFoodModifierElementIndex = 0, supplementElementIndex = 0, noteElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "instantiatesCanonical":
                    position = checkElementOrder("instantiatesCanonical", 9, position, true);
                    builder.instantiatesCanonical((Canonical) parseUri(Canonical.builder(), "instantiatesCanonical", reader, instantiatesCanonicalElementIndex++));
                    break;
                case "instantiatesUri":
                    position = checkElementOrder("instantiatesUri", 10, position, true);
                    builder.instantiatesUri(parseUri("instantiatesUri", reader, instantiatesUriElementIndex++));
                    break;
                case "instantiates":
                    position = checkElementOrder("instantiates", 11, position, true);
                    builder.instantiates(parseUri("instantiates", reader, instantiatesElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 12, position, false);
                    builder.status((NutritionOrderStatus) parseString(NutritionOrderStatus.builder(), "status", reader, -1));
                    break;
                case "intent":
                    position = checkElementOrder("intent", 13, position, false);
                    builder.intent((NutritionOrderIntent) parseString(NutritionOrderIntent.builder(), "intent", reader, -1));
                    break;
                case "patient":
                    position = checkElementOrder("patient", 14, position, false);
                    builder.patient(parseReference("patient", reader, -1));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 15, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "dateTime":
                    position = checkElementOrder("dateTime", 16, position, false);
                    builder.dateTime(parseDateTime("dateTime", reader, -1));
                    break;
                case "orderer":
                    position = checkElementOrder("orderer", 17, position, false);
                    builder.orderer(parseReference("orderer", reader, -1));
                    break;
                case "allergyIntolerance":
                    position = checkElementOrder("allergyIntolerance", 18, position, true);
                    builder.allergyIntolerance(parseReference("allergyIntolerance", reader, allergyIntoleranceElementIndex++));
                    break;
                case "foodPreferenceModifier":
                    position = checkElementOrder("foodPreferenceModifier", 19, position, true);
                    builder.foodPreferenceModifier(parseCodeableConcept("foodPreferenceModifier", reader, foodPreferenceModifierElementIndex++));
                    break;
                case "excludeFoodModifier":
                    position = checkElementOrder("excludeFoodModifier", 20, position, true);
                    builder.excludeFoodModifier(parseCodeableConcept("excludeFoodModifier", reader, excludeFoodModifierElementIndex++));
                    break;
                case "oralDiet":
                    position = checkElementOrder("oralDiet", 21, position, false);
                    builder.oralDiet(parseNutritionOrderOralDiet("oralDiet", reader, -1));
                    break;
                case "supplement":
                    position = checkElementOrder("supplement", 22, position, true);
                    builder.supplement(parseNutritionOrderSupplement("supplement", reader, supplementElementIndex++));
                    break;
                case "enteralFormula":
                    position = checkElementOrder("enteralFormula", 23, position, false);
                    builder.enteralFormula(parseNutritionOrderEnteralFormula("enteralFormula", reader, -1));
                    break;
                case "note":
                    position = checkElementOrder("note", 24, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private NutritionOrder.EnteralFormula parseNutritionOrderEnteralFormula(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        NutritionOrder.EnteralFormula.Builder builder = NutritionOrder.EnteralFormula.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, administrationElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "baseFormulaType":
                    position = checkElementOrder("baseFormulaType", 2, position, false);
                    builder.baseFormulaType(parseCodeableConcept("baseFormulaType", reader, -1));
                    break;
                case "baseFormulaProductName":
                    position = checkElementOrder("baseFormulaProductName", 3, position, false);
                    builder.baseFormulaProductName(parseString("baseFormulaProductName", reader, -1));
                    break;
                case "additiveType":
                    position = checkElementOrder("additiveType", 4, position, false);
                    builder.additiveType(parseCodeableConcept("additiveType", reader, -1));
                    break;
                case "additiveProductName":
                    position = checkElementOrder("additiveProductName", 5, position, false);
                    builder.additiveProductName(parseString("additiveProductName", reader, -1));
                    break;
                case "caloricDensity":
                    position = checkElementOrder("caloricDensity", 6, position, false);
                    builder.caloricDensity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "caloricDensity", reader, -1));
                    break;
                case "routeofAdministration":
                    position = checkElementOrder("routeofAdministration", 7, position, false);
                    builder.routeofAdministration(parseCodeableConcept("routeofAdministration", reader, -1));
                    break;
                case "administration":
                    position = checkElementOrder("administration", 8, position, true);
                    builder.administration(parseNutritionOrderEnteralFormulaAdministration("administration", reader, administrationElementIndex++));
                    break;
                case "maxVolumeToDeliver":
                    position = checkElementOrder("maxVolumeToDeliver", 9, position, false);
                    builder.maxVolumeToDeliver((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "maxVolumeToDeliver", reader, -1));
                    break;
                case "administrationInstruction":
                    position = checkElementOrder("administrationInstruction", 10, position, false);
                    builder.administrationInstruction(parseString("administrationInstruction", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private NutritionOrder.EnteralFormula.Administration parseNutritionOrderEnteralFormulaAdministration(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        NutritionOrder.EnteralFormula.Administration.Builder builder = NutritionOrder.EnteralFormula.Administration.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "schedule":
                    position = checkElementOrder("schedule", 2, position, false);
                    builder.schedule(parseTiming("schedule", reader, -1));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 3, position, false);
                    builder.quantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "quantity", reader, -1));
                    break;
                case "rateQuantity":
                    position = checkElementOrder("rate[x]", 4, position, false);
                    builder.rate((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "rateQuantity", reader, -1));
                    break;
                case "rateRatio":
                    position = checkElementOrder("rate[x]", 4, position, false);
                    builder.rate(parseRatio("rateRatio", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private NutritionOrder.OralDiet parseNutritionOrderOralDiet(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        NutritionOrder.OralDiet.Builder builder = NutritionOrder.OralDiet.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, typeElementIndex = 0, scheduleElementIndex = 0, nutrientElementIndex = 0, textureElementIndex = 0, fluidConsistencyTypeElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, true);
                    builder.type(parseCodeableConcept("type", reader, typeElementIndex++));
                    break;
                case "schedule":
                    position = checkElementOrder("schedule", 3, position, true);
                    builder.schedule(parseTiming("schedule", reader, scheduleElementIndex++));
                    break;
                case "nutrient":
                    position = checkElementOrder("nutrient", 4, position, true);
                    builder.nutrient(parseNutritionOrderOralDietNutrient("nutrient", reader, nutrientElementIndex++));
                    break;
                case "texture":
                    position = checkElementOrder("texture", 5, position, true);
                    builder.texture(parseNutritionOrderOralDietTexture("texture", reader, textureElementIndex++));
                    break;
                case "fluidConsistencyType":
                    position = checkElementOrder("fluidConsistencyType", 6, position, true);
                    builder.fluidConsistencyType(parseCodeableConcept("fluidConsistencyType", reader, fluidConsistencyTypeElementIndex++));
                    break;
                case "instruction":
                    position = checkElementOrder("instruction", 7, position, false);
                    builder.instruction(parseString("instruction", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private NutritionOrder.OralDiet.Nutrient parseNutritionOrderOralDietNutrient(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        NutritionOrder.OralDiet.Nutrient.Builder builder = NutritionOrder.OralDiet.Nutrient.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "modifier":
                    position = checkElementOrder("modifier", 2, position, false);
                    builder.modifier(parseCodeableConcept("modifier", reader, -1));
                    break;
                case "amount":
                    position = checkElementOrder("amount", 3, position, false);
                    builder.amount((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "amount", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private NutritionOrder.OralDiet.Texture parseNutritionOrderOralDietTexture(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        NutritionOrder.OralDiet.Texture.Builder builder = NutritionOrder.OralDiet.Texture.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "modifier":
                    position = checkElementOrder("modifier", 2, position, false);
                    builder.modifier(parseCodeableConcept("modifier", reader, -1));
                    break;
                case "foodType":
                    position = checkElementOrder("foodType", 3, position, false);
                    builder.foodType(parseCodeableConcept("foodType", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private NutritionOrder.Supplement parseNutritionOrderSupplement(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        NutritionOrder.Supplement.Builder builder = NutritionOrder.Supplement.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, scheduleElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "productName":
                    position = checkElementOrder("productName", 3, position, false);
                    builder.productName(parseString("productName", reader, -1));
                    break;
                case "schedule":
                    position = checkElementOrder("schedule", 4, position, true);
                    builder.schedule(parseTiming("schedule", reader, scheduleElementIndex++));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 5, position, false);
                    builder.quantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "quantity", reader, -1));
                    break;
                case "instruction":
                    position = checkElementOrder("instruction", 6, position, false);
                    builder.instruction(parseString("instruction", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private NutritionProduct parseNutritionProduct(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        NutritionProduct.Builder builder = NutritionProduct.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, categoryElementIndex = 0, manufacturerElementIndex = 0, nutrientElementIndex = 0, ingredientElementIndex = 0, knownAllergenElementIndex = 0, productCharacteristicElementIndex = 0, noteElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 8, position, false);
                    builder.status((NutritionProductStatus) parseString(NutritionProductStatus.builder(), "status", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 9, position, true);
                    builder.category(parseCodeableConcept("category", reader, categoryElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 10, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "manufacturer":
                    position = checkElementOrder("manufacturer", 11, position, true);
                    builder.manufacturer(parseReference("manufacturer", reader, manufacturerElementIndex++));
                    break;
                case "nutrient":
                    position = checkElementOrder("nutrient", 12, position, true);
                    builder.nutrient(parseNutritionProductNutrient("nutrient", reader, nutrientElementIndex++));
                    break;
                case "ingredient":
                    position = checkElementOrder("ingredient", 13, position, true);
                    builder.ingredient(parseNutritionProductIngredient("ingredient", reader, ingredientElementIndex++));
                    break;
                case "knownAllergen":
                    position = checkElementOrder("knownAllergen", 14, position, true);
                    builder.knownAllergen(parseCodeableReference("knownAllergen", reader, knownAllergenElementIndex++));
                    break;
                case "productCharacteristic":
                    position = checkElementOrder("productCharacteristic", 15, position, true);
                    builder.productCharacteristic(parseNutritionProductProductCharacteristic("productCharacteristic", reader, productCharacteristicElementIndex++));
                    break;
                case "instance":
                    position = checkElementOrder("instance", 16, position, false);
                    builder.instance(parseNutritionProductInstance("instance", reader, -1));
                    break;
                case "note":
                    position = checkElementOrder("note", 17, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private NutritionProduct.Ingredient parseNutritionProductIngredient(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        NutritionProduct.Ingredient.Builder builder = NutritionProduct.Ingredient.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, amountElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "item":
                    position = checkElementOrder("item", 2, position, false);
                    builder.item(parseCodeableReference("item", reader, -1));
                    break;
                case "amount":
                    position = checkElementOrder("amount", 3, position, true);
                    builder.amount(parseRatio("amount", reader, amountElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private NutritionProduct.Instance parseNutritionProductInstance(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        NutritionProduct.Instance.Builder builder = NutritionProduct.Instance.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 2, position, false);
                    builder.quantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "quantity", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 3, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "lotNumber":
                    position = checkElementOrder("lotNumber", 4, position, false);
                    builder.lotNumber(parseString("lotNumber", reader, -1));
                    break;
                case "expiry":
                    position = checkElementOrder("expiry", 5, position, false);
                    builder.expiry(parseDateTime("expiry", reader, -1));
                    break;
                case "useBy":
                    position = checkElementOrder("useBy", 6, position, false);
                    builder.useBy(parseDateTime("useBy", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private NutritionProduct.Nutrient parseNutritionProductNutrient(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        NutritionProduct.Nutrient.Builder builder = NutritionProduct.Nutrient.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, amountElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "item":
                    position = checkElementOrder("item", 2, position, false);
                    builder.item(parseCodeableReference("item", reader, -1));
                    break;
                case "amount":
                    position = checkElementOrder("amount", 3, position, true);
                    builder.amount(parseRatio("amount", reader, amountElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private NutritionProduct.ProductCharacteristic parseNutritionProductProductCharacteristic(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        NutritionProduct.ProductCharacteristic.Builder builder = NutritionProduct.ProductCharacteristic.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "valueCodeableConcept":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCodeableConcept("valueCodeableConcept", reader, -1));
                    break;
                case "valueString":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseString("valueString", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "valueQuantity", reader, -1));
                    break;
                case "valueBase64Binary":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBase64Binary("valueBase64Binary", reader, -1));
                    break;
                case "valueAttachment":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseAttachment("valueAttachment", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Observation parseObservation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Observation.Builder builder = Observation.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, basedOnElementIndex = 0, partOfElementIndex = 0, categoryElementIndex = 0, focusElementIndex = 0, performerElementIndex = 0, interpretationElementIndex = 0, noteElementIndex = 0, referenceRangeElementIndex = 0, hasMemberElementIndex = 0, derivedFromElementIndex = 0, componentElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "basedOn":
                    position = checkElementOrder("basedOn", 9, position, true);
                    builder.basedOn(parseReference("basedOn", reader, basedOnElementIndex++));
                    break;
                case "partOf":
                    position = checkElementOrder("partOf", 10, position, true);
                    builder.partOf(parseReference("partOf", reader, partOfElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 11, position, false);
                    builder.status((ObservationStatus) parseString(ObservationStatus.builder(), "status", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 12, position, true);
                    builder.category(parseCodeableConcept("category", reader, categoryElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 13, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 14, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "focus":
                    position = checkElementOrder("focus", 15, position, true);
                    builder.focus(parseReference("focus", reader, focusElementIndex++));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 16, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "effectiveDateTime":
                    position = checkElementOrder("effective[x]", 17, position, false);
                    builder.effective(parseDateTime("effectiveDateTime", reader, -1));
                    break;
                case "effectivePeriod":
                    position = checkElementOrder("effective[x]", 17, position, false);
                    builder.effective(parsePeriod("effectivePeriod", reader, -1));
                    break;
                case "effectiveTiming":
                    position = checkElementOrder("effective[x]", 17, position, false);
                    builder.effective(parseTiming("effectiveTiming", reader, -1));
                    break;
                case "effectiveInstant":
                    position = checkElementOrder("effective[x]", 17, position, false);
                    builder.effective(parseInstant("effectiveInstant", reader, -1));
                    break;
                case "issued":
                    position = checkElementOrder("issued", 18, position, false);
                    builder.issued(parseInstant("issued", reader, -1));
                    break;
                case "performer":
                    position = checkElementOrder("performer", 19, position, true);
                    builder.performer(parseReference("performer", reader, performerElementIndex++));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 20, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueCodeableConcept":
                    position = checkElementOrder("value[x]", 20, position, false);
                    builder.value(parseCodeableConcept("valueCodeableConcept", reader, -1));
                    break;
                case "valueString":
                    position = checkElementOrder("value[x]", 20, position, false);
                    builder.value(parseString("valueString", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 20, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueInteger":
                    position = checkElementOrder("value[x]", 20, position, false);
                    builder.value(parseInteger("valueInteger", reader, -1));
                    break;
                case "valueRange":
                    position = checkElementOrder("value[x]", 20, position, false);
                    builder.value(parseRange("valueRange", reader, -1));
                    break;
                case "valueRatio":
                    position = checkElementOrder("value[x]", 20, position, false);
                    builder.value(parseRatio("valueRatio", reader, -1));
                    break;
                case "valueSampledData":
                    position = checkElementOrder("value[x]", 20, position, false);
                    builder.value(parseSampledData("valueSampledData", reader, -1));
                    break;
                case "valueTime":
                    position = checkElementOrder("value[x]", 20, position, false);
                    builder.value(parseTime("valueTime", reader, -1));
                    break;
                case "valueDateTime":
                    position = checkElementOrder("value[x]", 20, position, false);
                    builder.value(parseDateTime("valueDateTime", reader, -1));
                    break;
                case "valuePeriod":
                    position = checkElementOrder("value[x]", 20, position, false);
                    builder.value(parsePeriod("valuePeriod", reader, -1));
                    break;
                case "dataAbsentReason":
                    position = checkElementOrder("dataAbsentReason", 21, position, false);
                    builder.dataAbsentReason(parseCodeableConcept("dataAbsentReason", reader, -1));
                    break;
                case "interpretation":
                    position = checkElementOrder("interpretation", 22, position, true);
                    builder.interpretation(parseCodeableConcept("interpretation", reader, interpretationElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 23, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "bodySite":
                    position = checkElementOrder("bodySite", 24, position, false);
                    builder.bodySite(parseCodeableConcept("bodySite", reader, -1));
                    break;
                case "method":
                    position = checkElementOrder("method", 25, position, false);
                    builder.method(parseCodeableConcept("method", reader, -1));
                    break;
                case "specimen":
                    position = checkElementOrder("specimen", 26, position, false);
                    builder.specimen(parseReference("specimen", reader, -1));
                    break;
                case "device":
                    position = checkElementOrder("device", 27, position, false);
                    builder.device(parseReference("device", reader, -1));
                    break;
                case "referenceRange":
                    position = checkElementOrder("referenceRange", 28, position, true);
                    builder.referenceRange(parseObservationReferenceRange("referenceRange", reader, referenceRangeElementIndex++));
                    break;
                case "hasMember":
                    position = checkElementOrder("hasMember", 29, position, true);
                    builder.hasMember(parseReference("hasMember", reader, hasMemberElementIndex++));
                    break;
                case "derivedFrom":
                    position = checkElementOrder("derivedFrom", 30, position, true);
                    builder.derivedFrom(parseReference("derivedFrom", reader, derivedFromElementIndex++));
                    break;
                case "component":
                    position = checkElementOrder("component", 31, position, true);
                    builder.component(parseObservationComponent("component", reader, componentElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Observation.Component parseObservationComponent(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Observation.Component.Builder builder = Observation.Component.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, interpretationElementIndex = 0, referenceRangeElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueCodeableConcept":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCodeableConcept("valueCodeableConcept", reader, -1));
                    break;
                case "valueString":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseString("valueString", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueInteger":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseInteger("valueInteger", reader, -1));
                    break;
                case "valueRange":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRange("valueRange", reader, -1));
                    break;
                case "valueRatio":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRatio("valueRatio", reader, -1));
                    break;
                case "valueSampledData":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseSampledData("valueSampledData", reader, -1));
                    break;
                case "valueTime":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseTime("valueTime", reader, -1));
                    break;
                case "valueDateTime":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDateTime("valueDateTime", reader, -1));
                    break;
                case "valuePeriod":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parsePeriod("valuePeriod", reader, -1));
                    break;
                case "dataAbsentReason":
                    position = checkElementOrder("dataAbsentReason", 4, position, false);
                    builder.dataAbsentReason(parseCodeableConcept("dataAbsentReason", reader, -1));
                    break;
                case "interpretation":
                    position = checkElementOrder("interpretation", 5, position, true);
                    builder.interpretation(parseCodeableConcept("interpretation", reader, interpretationElementIndex++));
                    break;
                case "referenceRange":
                    position = checkElementOrder("referenceRange", 6, position, true);
                    builder.referenceRange(parseObservationReferenceRange("referenceRange", reader, referenceRangeElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Observation.ReferenceRange parseObservationReferenceRange(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Observation.ReferenceRange.Builder builder = Observation.ReferenceRange.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, appliesToElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "low":
                    position = checkElementOrder("low", 2, position, false);
                    builder.low((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "low", reader, -1));
                    break;
                case "high":
                    position = checkElementOrder("high", 3, position, false);
                    builder.high((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "high", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 4, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "appliesTo":
                    position = checkElementOrder("appliesTo", 5, position, true);
                    builder.appliesTo(parseCodeableConcept("appliesTo", reader, appliesToElementIndex++));
                    break;
                case "age":
                    position = checkElementOrder("age", 6, position, false);
                    builder.age(parseRange("age", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 7, position, false);
                    builder.text(parseString("text", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ObservationDefinition parseObservationDefinition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ObservationDefinition.Builder builder = ObservationDefinition.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, categoryElementIndex = 0, identifierElementIndex = 0, permittedDataTypeElementIndex = 0, qualifiedIntervalElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "category":
                    position = checkElementOrder("category", 8, position, true);
                    builder.category(parseCodeableConcept("category", reader, categoryElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 9, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 10, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "permittedDataType":
                    position = checkElementOrder("permittedDataType", 11, position, true);
                    builder.permittedDataType((ObservationDataType) parseString(ObservationDataType.builder(), "permittedDataType", reader, permittedDataTypeElementIndex++));
                    break;
                case "multipleResultsAllowed":
                    position = checkElementOrder("multipleResultsAllowed", 12, position, false);
                    builder.multipleResultsAllowed(parseBoolean("multipleResultsAllowed", reader, -1));
                    break;
                case "method":
                    position = checkElementOrder("method", 13, position, false);
                    builder.method(parseCodeableConcept("method", reader, -1));
                    break;
                case "preferredReportName":
                    position = checkElementOrder("preferredReportName", 14, position, false);
                    builder.preferredReportName(parseString("preferredReportName", reader, -1));
                    break;
                case "quantitativeDetails":
                    position = checkElementOrder("quantitativeDetails", 15, position, false);
                    builder.quantitativeDetails(parseObservationDefinitionQuantitativeDetails("quantitativeDetails", reader, -1));
                    break;
                case "qualifiedInterval":
                    position = checkElementOrder("qualifiedInterval", 16, position, true);
                    builder.qualifiedInterval(parseObservationDefinitionQualifiedInterval("qualifiedInterval", reader, qualifiedIntervalElementIndex++));
                    break;
                case "validCodedValueSet":
                    position = checkElementOrder("validCodedValueSet", 17, position, false);
                    builder.validCodedValueSet(parseReference("validCodedValueSet", reader, -1));
                    break;
                case "normalCodedValueSet":
                    position = checkElementOrder("normalCodedValueSet", 18, position, false);
                    builder.normalCodedValueSet(parseReference("normalCodedValueSet", reader, -1));
                    break;
                case "abnormalCodedValueSet":
                    position = checkElementOrder("abnormalCodedValueSet", 19, position, false);
                    builder.abnormalCodedValueSet(parseReference("abnormalCodedValueSet", reader, -1));
                    break;
                case "criticalCodedValueSet":
                    position = checkElementOrder("criticalCodedValueSet", 20, position, false);
                    builder.criticalCodedValueSet(parseReference("criticalCodedValueSet", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ObservationDefinition.QualifiedInterval parseObservationDefinitionQualifiedInterval(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ObservationDefinition.QualifiedInterval.Builder builder = ObservationDefinition.QualifiedInterval.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, appliesToElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "category":
                    position = checkElementOrder("category", 2, position, false);
                    builder.category((ObservationRangeCategory) parseString(ObservationRangeCategory.builder(), "category", reader, -1));
                    break;
                case "range":
                    position = checkElementOrder("range", 3, position, false);
                    builder.range(parseRange("range", reader, -1));
                    break;
                case "context":
                    position = checkElementOrder("context", 4, position, false);
                    builder.context(parseCodeableConcept("context", reader, -1));
                    break;
                case "appliesTo":
                    position = checkElementOrder("appliesTo", 5, position, true);
                    builder.appliesTo(parseCodeableConcept("appliesTo", reader, appliesToElementIndex++));
                    break;
                case "gender":
                    position = checkElementOrder("gender", 6, position, false);
                    builder.gender((AdministrativeGender) parseString(AdministrativeGender.builder(), "gender", reader, -1));
                    break;
                case "age":
                    position = checkElementOrder("age", 7, position, false);
                    builder.age(parseRange("age", reader, -1));
                    break;
                case "gestationalAge":
                    position = checkElementOrder("gestationalAge", 8, position, false);
                    builder.gestationalAge(parseRange("gestationalAge", reader, -1));
                    break;
                case "condition":
                    position = checkElementOrder("condition", 9, position, false);
                    builder.condition(parseString("condition", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ObservationDefinition.QuantitativeDetails parseObservationDefinitionQuantitativeDetails(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ObservationDefinition.QuantitativeDetails.Builder builder = ObservationDefinition.QuantitativeDetails.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "customaryUnit":
                    position = checkElementOrder("customaryUnit", 2, position, false);
                    builder.customaryUnit(parseCodeableConcept("customaryUnit", reader, -1));
                    break;
                case "unit":
                    position = checkElementOrder("unit", 3, position, false);
                    builder.unit(parseCodeableConcept("unit", reader, -1));
                    break;
                case "conversionFactor":
                    position = checkElementOrder("conversionFactor", 4, position, false);
                    builder.conversionFactor(parseDecimal("conversionFactor", reader, -1));
                    break;
                case "decimalPrecision":
                    position = checkElementOrder("decimalPrecision", 5, position, false);
                    builder.decimalPrecision(parseInteger("decimalPrecision", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private OperationDefinition parseOperationDefinition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        OperationDefinition.Builder builder = OperationDefinition.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, contactElementIndex = 0, useContextElementIndex = 0, jurisdictionElementIndex = 0, resourceElementIndex = 0, parameterElementIndex = 0, overloadElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "version":
                    position = checkElementOrder("version", 9, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 10, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 11, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 12, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "kind":
                    position = checkElementOrder("kind", 13, position, false);
                    builder.kind((OperationKind) parseString(OperationKind.builder(), "kind", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 14, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 15, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 16, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 17, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 18, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 19, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 20, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 21, position, false);
                    builder.purpose((Markdown) parseString(Markdown.builder(), "purpose", reader, -1));
                    break;
                case "affectsState":
                    position = checkElementOrder("affectsState", 22, position, false);
                    builder.affectsState(parseBoolean("affectsState", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 23, position, false);
                    builder.code((Code) parseString(Code.builder(), "code", reader, -1));
                    break;
                case "comment":
                    position = checkElementOrder("comment", 24, position, false);
                    builder.comment((Markdown) parseString(Markdown.builder(), "comment", reader, -1));
                    break;
                case "base":
                    position = checkElementOrder("base", 25, position, false);
                    builder.base((Canonical) parseUri(Canonical.builder(), "base", reader, -1));
                    break;
                case "resource":
                    position = checkElementOrder("resource", 26, position, true);
                    builder.resource((ResourceTypeCode) parseString(ResourceTypeCode.builder(), "resource", reader, resourceElementIndex++));
                    break;
                case "system":
                    position = checkElementOrder("system", 27, position, false);
                    builder.system(parseBoolean("system", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 28, position, false);
                    builder.type(parseBoolean("type", reader, -1));
                    break;
                case "instance":
                    position = checkElementOrder("instance", 29, position, false);
                    builder.instance(parseBoolean("instance", reader, -1));
                    break;
                case "inputProfile":
                    position = checkElementOrder("inputProfile", 30, position, false);
                    builder.inputProfile((Canonical) parseUri(Canonical.builder(), "inputProfile", reader, -1));
                    break;
                case "outputProfile":
                    position = checkElementOrder("outputProfile", 31, position, false);
                    builder.outputProfile((Canonical) parseUri(Canonical.builder(), "outputProfile", reader, -1));
                    break;
                case "parameter":
                    position = checkElementOrder("parameter", 32, position, true);
                    builder.parameter(parseOperationDefinitionParameter("parameter", reader, parameterElementIndex++));
                    break;
                case "overload":
                    position = checkElementOrder("overload", 33, position, true);
                    builder.overload(parseOperationDefinitionOverload("overload", reader, overloadElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private OperationDefinition.Overload parseOperationDefinitionOverload(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        OperationDefinition.Overload.Builder builder = OperationDefinition.Overload.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, parameterNameElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "parameterName":
                    position = checkElementOrder("parameterName", 2, position, true);
                    builder.parameterName(parseString("parameterName", reader, parameterNameElementIndex++));
                    break;
                case "comment":
                    position = checkElementOrder("comment", 3, position, false);
                    builder.comment(parseString("comment", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private OperationDefinition.Parameter parseOperationDefinitionParameter(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        OperationDefinition.Parameter.Builder builder = OperationDefinition.Parameter.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, targetProfileElementIndex = 0, referencedFromElementIndex = 0, partElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name((Code) parseString(Code.builder(), "name", reader, -1));
                    break;
                case "use":
                    position = checkElementOrder("use", 3, position, false);
                    builder.use((OperationParameterUse) parseString(OperationParameterUse.builder(), "use", reader, -1));
                    break;
                case "min":
                    position = checkElementOrder("min", 4, position, false);
                    builder.min(parseInteger("min", reader, -1));
                    break;
                case "max":
                    position = checkElementOrder("max", 5, position, false);
                    builder.max(parseString("max", reader, -1));
                    break;
                case "documentation":
                    position = checkElementOrder("documentation", 6, position, false);
                    builder.documentation(parseString("documentation", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 7, position, false);
                    builder.type((FHIRAllTypes) parseString(FHIRAllTypes.builder(), "type", reader, -1));
                    break;
                case "targetProfile":
                    position = checkElementOrder("targetProfile", 8, position, true);
                    builder.targetProfile((Canonical) parseUri(Canonical.builder(), "targetProfile", reader, targetProfileElementIndex++));
                    break;
                case "searchType":
                    position = checkElementOrder("searchType", 9, position, false);
                    builder.searchType((SearchParamType) parseString(SearchParamType.builder(), "searchType", reader, -1));
                    break;
                case "binding":
                    position = checkElementOrder("binding", 10, position, false);
                    builder.binding(parseOperationDefinitionParameterBinding("binding", reader, -1));
                    break;
                case "referencedFrom":
                    position = checkElementOrder("referencedFrom", 11, position, true);
                    builder.referencedFrom(parseOperationDefinitionParameterReferencedFrom("referencedFrom", reader, referencedFromElementIndex++));
                    break;
                case "part":
                    position = checkElementOrder("part", 12, position, true);
                    builder.part(parseOperationDefinitionParameter("part", reader, partElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private OperationDefinition.Parameter.Binding parseOperationDefinitionParameterBinding(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        OperationDefinition.Parameter.Binding.Builder builder = OperationDefinition.Parameter.Binding.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "strength":
                    position = checkElementOrder("strength", 2, position, false);
                    builder.strength((BindingStrength) parseString(BindingStrength.builder(), "strength", reader, -1));
                    break;
                case "valueSet":
                    position = checkElementOrder("valueSet", 3, position, false);
                    builder.valueSet((Canonical) parseUri(Canonical.builder(), "valueSet", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private OperationDefinition.Parameter.ReferencedFrom parseOperationDefinitionParameterReferencedFrom(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        OperationDefinition.Parameter.ReferencedFrom.Builder builder = OperationDefinition.Parameter.ReferencedFrom.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "source":
                    position = checkElementOrder("source", 2, position, false);
                    builder.source(parseString("source", reader, -1));
                    break;
                case "sourceId":
                    position = checkElementOrder("sourceId", 3, position, false);
                    builder.sourceId(parseString("sourceId", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private OperationOutcome parseOperationOutcome(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        OperationOutcome.Builder builder = OperationOutcome.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, issueElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "issue":
                    position = checkElementOrder("issue", 8, position, true);
                    builder.issue(parseOperationOutcomeIssue("issue", reader, issueElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private OperationOutcome.Issue parseOperationOutcomeIssue(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        OperationOutcome.Issue.Builder builder = OperationOutcome.Issue.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, locationElementIndex = 0, expressionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "severity":
                    position = checkElementOrder("severity", 2, position, false);
                    builder.severity((IssueSeverity) parseString(IssueSeverity.builder(), "severity", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 3, position, false);
                    builder.code((IssueType) parseString(IssueType.builder(), "code", reader, -1));
                    break;
                case "details":
                    position = checkElementOrder("details", 4, position, false);
                    builder.details(parseCodeableConcept("details", reader, -1));
                    break;
                case "diagnostics":
                    position = checkElementOrder("diagnostics", 5, position, false);
                    builder.diagnostics(parseString("diagnostics", reader, -1));
                    break;
                case "location":
                    position = checkElementOrder("location", 6, position, true);
                    builder.location(parseString("location", reader, locationElementIndex++));
                    break;
                case "expression":
                    position = checkElementOrder("expression", 7, position, true);
                    builder.expression(parseString("expression", reader, expressionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Organization parseOrganization(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Organization.Builder builder = Organization.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, typeElementIndex = 0, aliasElementIndex = 0, telecomElementIndex = 0, addressElementIndex = 0, contactElementIndex = 0, endpointElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "active":
                    position = checkElementOrder("active", 9, position, false);
                    builder.active(parseBoolean("active", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 10, position, true);
                    builder.type(parseCodeableConcept("type", reader, typeElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 11, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "alias":
                    position = checkElementOrder("alias", 12, position, true);
                    builder.alias(parseString("alias", reader, aliasElementIndex++));
                    break;
                case "telecom":
                    position = checkElementOrder("telecom", 13, position, true);
                    builder.telecom(parseContactPoint("telecom", reader, telecomElementIndex++));
                    break;
                case "address":
                    position = checkElementOrder("address", 14, position, true);
                    builder.address(parseAddress("address", reader, addressElementIndex++));
                    break;
                case "partOf":
                    position = checkElementOrder("partOf", 15, position, false);
                    builder.partOf(parseReference("partOf", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 16, position, true);
                    builder.contact(parseOrganizationContact("contact", reader, contactElementIndex++));
                    break;
                case "endpoint":
                    position = checkElementOrder("endpoint", 17, position, true);
                    builder.endpoint(parseReference("endpoint", reader, endpointElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Organization.Contact parseOrganizationContact(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Organization.Contact.Builder builder = Organization.Contact.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, telecomElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 2, position, false);
                    builder.purpose(parseCodeableConcept("purpose", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 3, position, false);
                    builder.name(parseHumanName("name", reader, -1));
                    break;
                case "telecom":
                    position = checkElementOrder("telecom", 4, position, true);
                    builder.telecom(parseContactPoint("telecom", reader, telecomElementIndex++));
                    break;
                case "address":
                    position = checkElementOrder("address", 5, position, false);
                    builder.address(parseAddress("address", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private OrganizationAffiliation parseOrganizationAffiliation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        OrganizationAffiliation.Builder builder = OrganizationAffiliation.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, networkElementIndex = 0, codeElementIndex = 0, specialtyElementIndex = 0, locationElementIndex = 0, healthcareServiceElementIndex = 0, telecomElementIndex = 0, endpointElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "active":
                    position = checkElementOrder("active", 9, position, false);
                    builder.active(parseBoolean("active", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 10, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                case "organization":
                    position = checkElementOrder("organization", 11, position, false);
                    builder.organization(parseReference("organization", reader, -1));
                    break;
                case "participatingOrganization":
                    position = checkElementOrder("participatingOrganization", 12, position, false);
                    builder.participatingOrganization(parseReference("participatingOrganization", reader, -1));
                    break;
                case "network":
                    position = checkElementOrder("network", 13, position, true);
                    builder.network(parseReference("network", reader, networkElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 14, position, true);
                    builder.code(parseCodeableConcept("code", reader, codeElementIndex++));
                    break;
                case "specialty":
                    position = checkElementOrder("specialty", 15, position, true);
                    builder.specialty(parseCodeableConcept("specialty", reader, specialtyElementIndex++));
                    break;
                case "location":
                    position = checkElementOrder("location", 16, position, true);
                    builder.location(parseReference("location", reader, locationElementIndex++));
                    break;
                case "healthcareService":
                    position = checkElementOrder("healthcareService", 17, position, true);
                    builder.healthcareService(parseReference("healthcareService", reader, healthcareServiceElementIndex++));
                    break;
                case "telecom":
                    position = checkElementOrder("telecom", 18, position, true);
                    builder.telecom(parseContactPoint("telecom", reader, telecomElementIndex++));
                    break;
                case "endpoint":
                    position = checkElementOrder("endpoint", 19, position, true);
                    builder.endpoint(parseReference("endpoint", reader, endpointElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private PackagedProductDefinition parsePackagedProductDefinition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        PackagedProductDefinition.Builder builder = PackagedProductDefinition.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, packageForElementIndex = 0, containedItemQuantityElementIndex = 0, legalStatusOfSupplyElementIndex = 0, marketingStatusElementIndex = 0, characteristicElementIndex = 0, manufacturerElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 9, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 10, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "packageFor":
                    position = checkElementOrder("packageFor", 11, position, true);
                    builder.packageFor(parseReference("packageFor", reader, packageForElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 12, position, false);
                    builder.status(parseCodeableConcept("status", reader, -1));
                    break;
                case "statusDate":
                    position = checkElementOrder("statusDate", 13, position, false);
                    builder.statusDate(parseDateTime("statusDate", reader, -1));
                    break;
                case "containedItemQuantity":
                    position = checkElementOrder("containedItemQuantity", 14, position, true);
                    builder.containedItemQuantity(parseQuantity("containedItemQuantity", reader, containedItemQuantityElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 15, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "legalStatusOfSupply":
                    position = checkElementOrder("legalStatusOfSupply", 16, position, true);
                    builder.legalStatusOfSupply(parsePackagedProductDefinitionLegalStatusOfSupply("legalStatusOfSupply", reader, legalStatusOfSupplyElementIndex++));
                    break;
                case "marketingStatus":
                    position = checkElementOrder("marketingStatus", 17, position, true);
                    builder.marketingStatus(parseMarketingStatus("marketingStatus", reader, marketingStatusElementIndex++));
                    break;
                case "characteristic":
                    position = checkElementOrder("characteristic", 18, position, true);
                    builder.characteristic(parseCodeableConcept("characteristic", reader, characteristicElementIndex++));
                    break;
                case "copackagedIndicator":
                    position = checkElementOrder("copackagedIndicator", 19, position, false);
                    builder.copackagedIndicator(parseBoolean("copackagedIndicator", reader, -1));
                    break;
                case "manufacturer":
                    position = checkElementOrder("manufacturer", 20, position, true);
                    builder.manufacturer(parseReference("manufacturer", reader, manufacturerElementIndex++));
                    break;
                case "package":
                    position = checkElementOrder("package", 21, position, false);
                    builder._package(parsePackagedProductDefinitionPackage("package", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private PackagedProductDefinition.LegalStatusOfSupply parsePackagedProductDefinitionLegalStatusOfSupply(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        PackagedProductDefinition.LegalStatusOfSupply.Builder builder = PackagedProductDefinition.LegalStatusOfSupply.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 3, position, false);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private PackagedProductDefinition.Package parsePackagedProductDefinitionPackage(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        PackagedProductDefinition.Package.Builder builder = PackagedProductDefinition.Package.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, materialElementIndex = 0, alternateMaterialElementIndex = 0, shelfLifeStorageElementIndex = 0, manufacturerElementIndex = 0, propertyElementIndex = 0, containedItemElementIndex = 0, packageElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 2, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 4, position, false);
                    builder.quantity(parseInteger("quantity", reader, -1));
                    break;
                case "material":
                    position = checkElementOrder("material", 5, position, true);
                    builder.material(parseCodeableConcept("material", reader, materialElementIndex++));
                    break;
                case "alternateMaterial":
                    position = checkElementOrder("alternateMaterial", 6, position, true);
                    builder.alternateMaterial(parseCodeableConcept("alternateMaterial", reader, alternateMaterialElementIndex++));
                    break;
                case "shelfLifeStorage":
                    position = checkElementOrder("shelfLifeStorage", 7, position, true);
                    builder.shelfLifeStorage(parseProductShelfLife("shelfLifeStorage", reader, shelfLifeStorageElementIndex++));
                    break;
                case "manufacturer":
                    position = checkElementOrder("manufacturer", 8, position, true);
                    builder.manufacturer(parseReference("manufacturer", reader, manufacturerElementIndex++));
                    break;
                case "property":
                    position = checkElementOrder("property", 9, position, true);
                    builder.property(parsePackagedProductDefinitionPackageProperty("property", reader, propertyElementIndex++));
                    break;
                case "containedItem":
                    position = checkElementOrder("containedItem", 10, position, true);
                    builder.containedItem(parsePackagedProductDefinitionPackageContainedItem("containedItem", reader, containedItemElementIndex++));
                    break;
                case "package":
                    position = checkElementOrder("package", 11, position, true);
                    builder._package(parsePackagedProductDefinitionPackage("package", reader, packageElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private PackagedProductDefinition.Package.ContainedItem parsePackagedProductDefinitionPackageContainedItem(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        PackagedProductDefinition.Package.ContainedItem.Builder builder = PackagedProductDefinition.Package.ContainedItem.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "item":
                    position = checkElementOrder("item", 2, position, false);
                    builder.item(parseCodeableReference("item", reader, -1));
                    break;
                case "amount":
                    position = checkElementOrder("amount", 3, position, false);
                    builder.amount(parseQuantity("amount", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private PackagedProductDefinition.Package.Property parsePackagedProductDefinitionPackageProperty(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        PackagedProductDefinition.Package.Property.Builder builder = PackagedProductDefinition.Package.Property.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "valueCodeableConcept":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCodeableConcept("valueCodeableConcept", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueDate":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDate("valueDate", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueAttachment":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseAttachment("valueAttachment", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ParameterDefinition parseParameterDefinition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ParameterDefinition.Builder builder = ParameterDefinition.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 1, position, false);
                    builder.name((Code) parseString(Code.builder(), "name", reader, -1));
                    break;
                case "use":
                    position = checkElementOrder("use", 2, position, false);
                    builder.use((ParameterUse) parseString(ParameterUse.builder(), "use", reader, -1));
                    break;
                case "min":
                    position = checkElementOrder("min", 3, position, false);
                    builder.min(parseInteger("min", reader, -1));
                    break;
                case "max":
                    position = checkElementOrder("max", 4, position, false);
                    builder.max(parseString("max", reader, -1));
                    break;
                case "documentation":
                    position = checkElementOrder("documentation", 5, position, false);
                    builder.documentation(parseString("documentation", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 6, position, false);
                    builder.type((FHIRAllTypes) parseString(FHIRAllTypes.builder(), "type", reader, -1));
                    break;
                case "profile":
                    position = checkElementOrder("profile", 7, position, false);
                    builder.profile((Canonical) parseUri(Canonical.builder(), "profile", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Parameters parseParameters(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Parameters.Builder builder = Parameters.builder();
        builder.setValidating(validating);
        int position = -1;
        int parameterElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "parameter":
                    position = checkElementOrder("parameter", 4, position, true);
                    builder.parameter(parseParametersParameter("parameter", reader, parameterElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Parameters.Parameter parseParametersParameter(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Parameters.Parameter.Builder builder = Parameters.Parameter.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, partElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "valueBase64Binary":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBase64Binary("valueBase64Binary", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueCanonical":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Canonical) parseUri(Canonical.builder(), "valueCanonical", reader, -1));
                    break;
                case "valueCode":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Code) parseString(Code.builder(), "valueCode", reader, -1));
                    break;
                case "valueDate":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDate("valueDate", reader, -1));
                    break;
                case "valueDateTime":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDateTime("valueDateTime", reader, -1));
                    break;
                case "valueDecimal":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDecimal("valueDecimal", reader, -1));
                    break;
                case "valueId":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Id) parseString(Id.builder(), "valueId", reader, -1));
                    break;
                case "valueInstant":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseInstant("valueInstant", reader, -1));
                    break;
                case "valueInteger":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseInteger("valueInteger", reader, -1));
                    break;
                case "valueMarkdown":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Markdown) parseString(Markdown.builder(), "valueMarkdown", reader, -1));
                    break;
                case "valueOid":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Oid) parseUri(Oid.builder(), "valueOid", reader, -1));
                    break;
                case "valuePositiveInt":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((PositiveInt) parseInteger(PositiveInt.builder(), "valuePositiveInt", reader, -1));
                    break;
                case "valueString":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseString("valueString", reader, -1));
                    break;
                case "valueTime":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseTime("valueTime", reader, -1));
                    break;
                case "valueUnsignedInt":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((UnsignedInt) parseInteger(UnsignedInt.builder(), "valueUnsignedInt", reader, -1));
                    break;
                case "valueUri":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseUri("valueUri", reader, -1));
                    break;
                case "valueUrl":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Url) parseUri(Url.builder(), "valueUrl", reader, -1));
                    break;
                case "valueUuid":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Uuid) parseUri(Uuid.builder(), "valueUuid", reader, -1));
                    break;
                case "valueAddress":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseAddress("valueAddress", reader, -1));
                    break;
                case "valueAge":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Age) parseQuantity(Age.builder(), "valueAge", reader, -1));
                    break;
                case "valueAnnotation":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseAnnotation("valueAnnotation", reader, -1));
                    break;
                case "valueAttachment":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseAttachment("valueAttachment", reader, -1));
                    break;
                case "valueCodeableConcept":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCodeableConcept("valueCodeableConcept", reader, -1));
                    break;
                case "valueCoding":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCoding("valueCoding", reader, -1));
                    break;
                case "valueContactPoint":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseContactPoint("valueContactPoint", reader, -1));
                    break;
                case "valueCount":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Count) parseQuantity(Count.builder(), "valueCount", reader, -1));
                    break;
                case "valueDistance":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Distance) parseQuantity(Distance.builder(), "valueDistance", reader, -1));
                    break;
                case "valueDuration":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Duration) parseQuantity(Duration.builder(), "valueDuration", reader, -1));
                    break;
                case "valueHumanName":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseHumanName("valueHumanName", reader, -1));
                    break;
                case "valueIdentifier":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseIdentifier("valueIdentifier", reader, -1));
                    break;
                case "valueMoney":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseMoney("valueMoney", reader, -1));
                    break;
                case "valuePeriod":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parsePeriod("valuePeriod", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueRange":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRange("valueRange", reader, -1));
                    break;
                case "valueRatio":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRatio("valueRatio", reader, -1));
                    break;
                case "valueReference":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseReference("valueReference", reader, -1));
                    break;
                case "valueSampledData":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseSampledData("valueSampledData", reader, -1));
                    break;
                case "valueSignature":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseSignature("valueSignature", reader, -1));
                    break;
                case "valueTiming":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseTiming("valueTiming", reader, -1));
                    break;
                case "valueContactDetail":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseContactDetail("valueContactDetail", reader, -1));
                    break;
                case "valueContributor":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseContributor("valueContributor", reader, -1));
                    break;
                case "valueDataRequirement":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDataRequirement("valueDataRequirement", reader, -1));
                    break;
                case "valueExpression":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseExpression("valueExpression", reader, -1));
                    break;
                case "valueParameterDefinition":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseParameterDefinition("valueParameterDefinition", reader, -1));
                    break;
                case "valueRelatedArtifact":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRelatedArtifact("valueRelatedArtifact", reader, -1));
                    break;
                case "valueTriggerDefinition":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseTriggerDefinition("valueTriggerDefinition", reader, -1));
                    break;
                case "valueUsageContext":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseUsageContext("valueUsageContext", reader, -1));
                    break;
                case "valueDosage":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDosage("valueDosage", reader, -1));
                    break;
                case "valueMeta":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseMeta("valueMeta", reader, -1));
                    break;
                case "resource":
                    position = checkElementOrder("resource", 4, position, false);
                    builder.resource(parseResource("resource", reader, -1));
                    break;
                case "part":
                    position = checkElementOrder("part", 5, position, true);
                    builder.part(parseParametersParameter("part", reader, partElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Patient parsePatient(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Patient.Builder builder = Patient.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, nameElementIndex = 0, telecomElementIndex = 0, addressElementIndex = 0, photoElementIndex = 0, contactElementIndex = 0, communicationElementIndex = 0, generalPractitionerElementIndex = 0, linkElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "active":
                    position = checkElementOrder("active", 9, position, false);
                    builder.active(parseBoolean("active", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 10, position, true);
                    builder.name(parseHumanName("name", reader, nameElementIndex++));
                    break;
                case "telecom":
                    position = checkElementOrder("telecom", 11, position, true);
                    builder.telecom(parseContactPoint("telecom", reader, telecomElementIndex++));
                    break;
                case "gender":
                    position = checkElementOrder("gender", 12, position, false);
                    builder.gender((AdministrativeGender) parseString(AdministrativeGender.builder(), "gender", reader, -1));
                    break;
                case "birthDate":
                    position = checkElementOrder("birthDate", 13, position, false);
                    builder.birthDate(parseDate("birthDate", reader, -1));
                    break;
                case "deceasedBoolean":
                    position = checkElementOrder("deceased[x]", 14, position, false);
                    builder.deceased(parseBoolean("deceasedBoolean", reader, -1));
                    break;
                case "deceasedDateTime":
                    position = checkElementOrder("deceased[x]", 14, position, false);
                    builder.deceased(parseDateTime("deceasedDateTime", reader, -1));
                    break;
                case "address":
                    position = checkElementOrder("address", 15, position, true);
                    builder.address(parseAddress("address", reader, addressElementIndex++));
                    break;
                case "maritalStatus":
                    position = checkElementOrder("maritalStatus", 16, position, false);
                    builder.maritalStatus(parseCodeableConcept("maritalStatus", reader, -1));
                    break;
                case "multipleBirthBoolean":
                    position = checkElementOrder("multipleBirth[x]", 17, position, false);
                    builder.multipleBirth(parseBoolean("multipleBirthBoolean", reader, -1));
                    break;
                case "multipleBirthInteger":
                    position = checkElementOrder("multipleBirth[x]", 17, position, false);
                    builder.multipleBirth(parseInteger("multipleBirthInteger", reader, -1));
                    break;
                case "photo":
                    position = checkElementOrder("photo", 18, position, true);
                    builder.photo(parseAttachment("photo", reader, photoElementIndex++));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 19, position, true);
                    builder.contact(parsePatientContact("contact", reader, contactElementIndex++));
                    break;
                case "communication":
                    position = checkElementOrder("communication", 20, position, true);
                    builder.communication(parsePatientCommunication("communication", reader, communicationElementIndex++));
                    break;
                case "generalPractitioner":
                    position = checkElementOrder("generalPractitioner", 21, position, true);
                    builder.generalPractitioner(parseReference("generalPractitioner", reader, generalPractitionerElementIndex++));
                    break;
                case "managingOrganization":
                    position = checkElementOrder("managingOrganization", 22, position, false);
                    builder.managingOrganization(parseReference("managingOrganization", reader, -1));
                    break;
                case "link":
                    position = checkElementOrder("link", 23, position, true);
                    builder.link(parsePatientLink("link", reader, linkElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Patient.Communication parsePatientCommunication(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Patient.Communication.Builder builder = Patient.Communication.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "language":
                    position = checkElementOrder("language", 2, position, false);
                    builder.language(parseCodeableConcept("language", reader, -1));
                    break;
                case "preferred":
                    position = checkElementOrder("preferred", 3, position, false);
                    builder.preferred(parseBoolean("preferred", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Patient.Contact parsePatientContact(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Patient.Contact.Builder builder = Patient.Contact.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, relationshipElementIndex = 0, telecomElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "relationship":
                    position = checkElementOrder("relationship", 2, position, true);
                    builder.relationship(parseCodeableConcept("relationship", reader, relationshipElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 3, position, false);
                    builder.name(parseHumanName("name", reader, -1));
                    break;
                case "telecom":
                    position = checkElementOrder("telecom", 4, position, true);
                    builder.telecom(parseContactPoint("telecom", reader, telecomElementIndex++));
                    break;
                case "address":
                    position = checkElementOrder("address", 5, position, false);
                    builder.address(parseAddress("address", reader, -1));
                    break;
                case "gender":
                    position = checkElementOrder("gender", 6, position, false);
                    builder.gender((AdministrativeGender) parseString(AdministrativeGender.builder(), "gender", reader, -1));
                    break;
                case "organization":
                    position = checkElementOrder("organization", 7, position, false);
                    builder.organization(parseReference("organization", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 8, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Patient.Link parsePatientLink(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Patient.Link.Builder builder = Patient.Link.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "other":
                    position = checkElementOrder("other", 2, position, false);
                    builder.other(parseReference("other", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type((LinkType) parseString(LinkType.builder(), "type", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private PaymentNotice parsePaymentNotice(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        PaymentNotice.Builder builder = PaymentNotice.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((PaymentNoticeStatus) parseString(PaymentNoticeStatus.builder(), "status", reader, -1));
                    break;
                case "request":
                    position = checkElementOrder("request", 10, position, false);
                    builder.request(parseReference("request", reader, -1));
                    break;
                case "response":
                    position = checkElementOrder("response", 11, position, false);
                    builder.response(parseReference("response", reader, -1));
                    break;
                case "created":
                    position = checkElementOrder("created", 12, position, false);
                    builder.created(parseDateTime("created", reader, -1));
                    break;
                case "provider":
                    position = checkElementOrder("provider", 13, position, false);
                    builder.provider(parseReference("provider", reader, -1));
                    break;
                case "payment":
                    position = checkElementOrder("payment", 14, position, false);
                    builder.payment(parseReference("payment", reader, -1));
                    break;
                case "paymentDate":
                    position = checkElementOrder("paymentDate", 15, position, false);
                    builder.paymentDate(parseDate("paymentDate", reader, -1));
                    break;
                case "payee":
                    position = checkElementOrder("payee", 16, position, false);
                    builder.payee(parseReference("payee", reader, -1));
                    break;
                case "recipient":
                    position = checkElementOrder("recipient", 17, position, false);
                    builder.recipient(parseReference("recipient", reader, -1));
                    break;
                case "amount":
                    position = checkElementOrder("amount", 18, position, false);
                    builder.amount(parseMoney("amount", reader, -1));
                    break;
                case "paymentStatus":
                    position = checkElementOrder("paymentStatus", 19, position, false);
                    builder.paymentStatus(parseCodeableConcept("paymentStatus", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private PaymentReconciliation parsePaymentReconciliation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        PaymentReconciliation.Builder builder = PaymentReconciliation.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, detailElementIndex = 0, processNoteElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((PaymentReconciliationStatus) parseString(PaymentReconciliationStatus.builder(), "status", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 10, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                case "created":
                    position = checkElementOrder("created", 11, position, false);
                    builder.created(parseDateTime("created", reader, -1));
                    break;
                case "paymentIssuer":
                    position = checkElementOrder("paymentIssuer", 12, position, false);
                    builder.paymentIssuer(parseReference("paymentIssuer", reader, -1));
                    break;
                case "request":
                    position = checkElementOrder("request", 13, position, false);
                    builder.request(parseReference("request", reader, -1));
                    break;
                case "requestor":
                    position = checkElementOrder("requestor", 14, position, false);
                    builder.requestor(parseReference("requestor", reader, -1));
                    break;
                case "outcome":
                    position = checkElementOrder("outcome", 15, position, false);
                    builder.outcome((RemittanceOutcome) parseString(RemittanceOutcome.builder(), "outcome", reader, -1));
                    break;
                case "disposition":
                    position = checkElementOrder("disposition", 16, position, false);
                    builder.disposition(parseString("disposition", reader, -1));
                    break;
                case "paymentDate":
                    position = checkElementOrder("paymentDate", 17, position, false);
                    builder.paymentDate(parseDate("paymentDate", reader, -1));
                    break;
                case "paymentAmount":
                    position = checkElementOrder("paymentAmount", 18, position, false);
                    builder.paymentAmount(parseMoney("paymentAmount", reader, -1));
                    break;
                case "paymentIdentifier":
                    position = checkElementOrder("paymentIdentifier", 19, position, false);
                    builder.paymentIdentifier(parseIdentifier("paymentIdentifier", reader, -1));
                    break;
                case "detail":
                    position = checkElementOrder("detail", 20, position, true);
                    builder.detail(parsePaymentReconciliationDetail("detail", reader, detailElementIndex++));
                    break;
                case "formCode":
                    position = checkElementOrder("formCode", 21, position, false);
                    builder.formCode(parseCodeableConcept("formCode", reader, -1));
                    break;
                case "processNote":
                    position = checkElementOrder("processNote", 22, position, true);
                    builder.processNote(parsePaymentReconciliationProcessNote("processNote", reader, processNoteElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private PaymentReconciliation.Detail parsePaymentReconciliationDetail(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        PaymentReconciliation.Detail.Builder builder = PaymentReconciliation.Detail.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 2, position, false);
                    builder.identifier(parseIdentifier("identifier", reader, -1));
                    break;
                case "predecessor":
                    position = checkElementOrder("predecessor", 3, position, false);
                    builder.predecessor(parseIdentifier("predecessor", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 4, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "request":
                    position = checkElementOrder("request", 5, position, false);
                    builder.request(parseReference("request", reader, -1));
                    break;
                case "submitter":
                    position = checkElementOrder("submitter", 6, position, false);
                    builder.submitter(parseReference("submitter", reader, -1));
                    break;
                case "response":
                    position = checkElementOrder("response", 7, position, false);
                    builder.response(parseReference("response", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 8, position, false);
                    builder.date(parseDate("date", reader, -1));
                    break;
                case "responsible":
                    position = checkElementOrder("responsible", 9, position, false);
                    builder.responsible(parseReference("responsible", reader, -1));
                    break;
                case "payee":
                    position = checkElementOrder("payee", 10, position, false);
                    builder.payee(parseReference("payee", reader, -1));
                    break;
                case "amount":
                    position = checkElementOrder("amount", 11, position, false);
                    builder.amount(parseMoney("amount", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private PaymentReconciliation.ProcessNote parsePaymentReconciliationProcessNote(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        PaymentReconciliation.ProcessNote.Builder builder = PaymentReconciliation.ProcessNote.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type((NoteType) parseString(NoteType.builder(), "type", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 3, position, false);
                    builder.text(parseString("text", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Period parsePeriod(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Period.Builder builder = Period.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "start":
                    position = checkElementOrder("start", 1, position, false);
                    builder.start(parseDateTime("start", reader, -1));
                    break;
                case "end":
                    position = checkElementOrder("end", 2, position, false);
                    builder.end(parseDateTime("end", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Person parsePerson(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Person.Builder builder = Person.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, nameElementIndex = 0, telecomElementIndex = 0, addressElementIndex = 0, linkElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 9, position, true);
                    builder.name(parseHumanName("name", reader, nameElementIndex++));
                    break;
                case "telecom":
                    position = checkElementOrder("telecom", 10, position, true);
                    builder.telecom(parseContactPoint("telecom", reader, telecomElementIndex++));
                    break;
                case "gender":
                    position = checkElementOrder("gender", 11, position, false);
                    builder.gender((AdministrativeGender) parseString(AdministrativeGender.builder(), "gender", reader, -1));
                    break;
                case "birthDate":
                    position = checkElementOrder("birthDate", 12, position, false);
                    builder.birthDate(parseDate("birthDate", reader, -1));
                    break;
                case "address":
                    position = checkElementOrder("address", 13, position, true);
                    builder.address(parseAddress("address", reader, addressElementIndex++));
                    break;
                case "photo":
                    position = checkElementOrder("photo", 14, position, false);
                    builder.photo(parseAttachment("photo", reader, -1));
                    break;
                case "managingOrganization":
                    position = checkElementOrder("managingOrganization", 15, position, false);
                    builder.managingOrganization(parseReference("managingOrganization", reader, -1));
                    break;
                case "active":
                    position = checkElementOrder("active", 16, position, false);
                    builder.active(parseBoolean("active", reader, -1));
                    break;
                case "link":
                    position = checkElementOrder("link", 17, position, true);
                    builder.link(parsePersonLink("link", reader, linkElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Person.Link parsePersonLink(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Person.Link.Builder builder = Person.Link.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "target":
                    position = checkElementOrder("target", 2, position, false);
                    builder.target(parseReference("target", reader, -1));
                    break;
                case "assurance":
                    position = checkElementOrder("assurance", 3, position, false);
                    builder.assurance((IdentityAssuranceLevel) parseString(IdentityAssuranceLevel.builder(), "assurance", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private PlanDefinition parsePlanDefinition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        PlanDefinition.Builder builder = PlanDefinition.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, contactElementIndex = 0, useContextElementIndex = 0, jurisdictionElementIndex = 0, topicElementIndex = 0, authorElementIndex = 0, editorElementIndex = 0, reviewerElementIndex = 0, endorserElementIndex = 0, relatedArtifactElementIndex = 0, libraryElementIndex = 0, goalElementIndex = 0, actionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 10, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 11, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 12, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "subtitle":
                    position = checkElementOrder("subtitle", 13, position, false);
                    builder.subtitle(parseString("subtitle", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 14, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 15, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 16, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "subjectCodeableConcept":
                    position = checkElementOrder("subject[x]", 17, position, false);
                    builder.subject(parseCodeableConcept("subjectCodeableConcept", reader, -1));
                    break;
                case "subjectReference":
                    position = checkElementOrder("subject[x]", 17, position, false);
                    builder.subject(parseReference("subjectReference", reader, -1));
                    break;
                case "subjectCanonical":
                    position = checkElementOrder("subject[x]", 17, position, false);
                    builder.subject((Canonical) parseUri(Canonical.builder(), "subjectCanonical", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 18, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 19, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 20, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 21, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 22, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 23, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 24, position, false);
                    builder.purpose((Markdown) parseString(Markdown.builder(), "purpose", reader, -1));
                    break;
                case "usage":
                    position = checkElementOrder("usage", 25, position, false);
                    builder.usage(parseString("usage", reader, -1));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 26, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                case "approvalDate":
                    position = checkElementOrder("approvalDate", 27, position, false);
                    builder.approvalDate(parseDate("approvalDate", reader, -1));
                    break;
                case "lastReviewDate":
                    position = checkElementOrder("lastReviewDate", 28, position, false);
                    builder.lastReviewDate(parseDate("lastReviewDate", reader, -1));
                    break;
                case "effectivePeriod":
                    position = checkElementOrder("effectivePeriod", 29, position, false);
                    builder.effectivePeriod(parsePeriod("effectivePeriod", reader, -1));
                    break;
                case "topic":
                    position = checkElementOrder("topic", 30, position, true);
                    builder.topic(parseCodeableConcept("topic", reader, topicElementIndex++));
                    break;
                case "author":
                    position = checkElementOrder("author", 31, position, true);
                    builder.author(parseContactDetail("author", reader, authorElementIndex++));
                    break;
                case "editor":
                    position = checkElementOrder("editor", 32, position, true);
                    builder.editor(parseContactDetail("editor", reader, editorElementIndex++));
                    break;
                case "reviewer":
                    position = checkElementOrder("reviewer", 33, position, true);
                    builder.reviewer(parseContactDetail("reviewer", reader, reviewerElementIndex++));
                    break;
                case "endorser":
                    position = checkElementOrder("endorser", 34, position, true);
                    builder.endorser(parseContactDetail("endorser", reader, endorserElementIndex++));
                    break;
                case "relatedArtifact":
                    position = checkElementOrder("relatedArtifact", 35, position, true);
                    builder.relatedArtifact(parseRelatedArtifact("relatedArtifact", reader, relatedArtifactElementIndex++));
                    break;
                case "library":
                    position = checkElementOrder("library", 36, position, true);
                    builder.library((Canonical) parseUri(Canonical.builder(), "library", reader, libraryElementIndex++));
                    break;
                case "goal":
                    position = checkElementOrder("goal", 37, position, true);
                    builder.goal(parsePlanDefinitionGoal("goal", reader, goalElementIndex++));
                    break;
                case "action":
                    position = checkElementOrder("action", 38, position, true);
                    builder.action(parsePlanDefinitionAction("action", reader, actionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private PlanDefinition.Action parsePlanDefinitionAction(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        PlanDefinition.Action.Builder builder = PlanDefinition.Action.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, codeElementIndex = 0, reasonElementIndex = 0, documentationElementIndex = 0, goalIdElementIndex = 0, triggerElementIndex = 0, conditionElementIndex = 0, inputElementIndex = 0, outputElementIndex = 0, relatedActionElementIndex = 0, participantElementIndex = 0, dynamicValueElementIndex = 0, actionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "prefix":
                    position = checkElementOrder("prefix", 2, position, false);
                    builder.prefix(parseString("prefix", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 3, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 4, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "textEquivalent":
                    position = checkElementOrder("textEquivalent", 5, position, false);
                    builder.textEquivalent(parseString("textEquivalent", reader, -1));
                    break;
                case "priority":
                    position = checkElementOrder("priority", 6, position, false);
                    builder.priority((RequestPriority) parseString(RequestPriority.builder(), "priority", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 7, position, true);
                    builder.code(parseCodeableConcept("code", reader, codeElementIndex++));
                    break;
                case "reason":
                    position = checkElementOrder("reason", 8, position, true);
                    builder.reason(parseCodeableConcept("reason", reader, reasonElementIndex++));
                    break;
                case "documentation":
                    position = checkElementOrder("documentation", 9, position, true);
                    builder.documentation(parseRelatedArtifact("documentation", reader, documentationElementIndex++));
                    break;
                case "goalId":
                    position = checkElementOrder("goalId", 10, position, true);
                    builder.goalId((Id) parseString(Id.builder(), "goalId", reader, goalIdElementIndex++));
                    break;
                case "subjectCodeableConcept":
                    position = checkElementOrder("subject[x]", 11, position, false);
                    builder.subject(parseCodeableConcept("subjectCodeableConcept", reader, -1));
                    break;
                case "subjectReference":
                    position = checkElementOrder("subject[x]", 11, position, false);
                    builder.subject(parseReference("subjectReference", reader, -1));
                    break;
                case "subjectCanonical":
                    position = checkElementOrder("subject[x]", 11, position, false);
                    builder.subject((Canonical) parseUri(Canonical.builder(), "subjectCanonical", reader, -1));
                    break;
                case "trigger":
                    position = checkElementOrder("trigger", 12, position, true);
                    builder.trigger(parseTriggerDefinition("trigger", reader, triggerElementIndex++));
                    break;
                case "condition":
                    position = checkElementOrder("condition", 13, position, true);
                    builder.condition(parsePlanDefinitionActionCondition("condition", reader, conditionElementIndex++));
                    break;
                case "input":
                    position = checkElementOrder("input", 14, position, true);
                    builder.input(parseDataRequirement("input", reader, inputElementIndex++));
                    break;
                case "output":
                    position = checkElementOrder("output", 15, position, true);
                    builder.output(parseDataRequirement("output", reader, outputElementIndex++));
                    break;
                case "relatedAction":
                    position = checkElementOrder("relatedAction", 16, position, true);
                    builder.relatedAction(parsePlanDefinitionActionRelatedAction("relatedAction", reader, relatedActionElementIndex++));
                    break;
                case "timingDateTime":
                    position = checkElementOrder("timing[x]", 17, position, false);
                    builder.timing(parseDateTime("timingDateTime", reader, -1));
                    break;
                case "timingAge":
                    position = checkElementOrder("timing[x]", 17, position, false);
                    builder.timing((Age) parseQuantity(Age.builder(), "timingAge", reader, -1));
                    break;
                case "timingPeriod":
                    position = checkElementOrder("timing[x]", 17, position, false);
                    builder.timing(parsePeriod("timingPeriod", reader, -1));
                    break;
                case "timingDuration":
                    position = checkElementOrder("timing[x]", 17, position, false);
                    builder.timing((Duration) parseQuantity(Duration.builder(), "timingDuration", reader, -1));
                    break;
                case "timingRange":
                    position = checkElementOrder("timing[x]", 17, position, false);
                    builder.timing(parseRange("timingRange", reader, -1));
                    break;
                case "timingTiming":
                    position = checkElementOrder("timing[x]", 17, position, false);
                    builder.timing(parseTiming("timingTiming", reader, -1));
                    break;
                case "participant":
                    position = checkElementOrder("participant", 18, position, true);
                    builder.participant(parsePlanDefinitionActionParticipant("participant", reader, participantElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 19, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "groupingBehavior":
                    position = checkElementOrder("groupingBehavior", 20, position, false);
                    builder.groupingBehavior((ActionGroupingBehavior) parseString(ActionGroupingBehavior.builder(), "groupingBehavior", reader, -1));
                    break;
                case "selectionBehavior":
                    position = checkElementOrder("selectionBehavior", 21, position, false);
                    builder.selectionBehavior((ActionSelectionBehavior) parseString(ActionSelectionBehavior.builder(), "selectionBehavior", reader, -1));
                    break;
                case "requiredBehavior":
                    position = checkElementOrder("requiredBehavior", 22, position, false);
                    builder.requiredBehavior((ActionRequiredBehavior) parseString(ActionRequiredBehavior.builder(), "requiredBehavior", reader, -1));
                    break;
                case "precheckBehavior":
                    position = checkElementOrder("precheckBehavior", 23, position, false);
                    builder.precheckBehavior((ActionPrecheckBehavior) parseString(ActionPrecheckBehavior.builder(), "precheckBehavior", reader, -1));
                    break;
                case "cardinalityBehavior":
                    position = checkElementOrder("cardinalityBehavior", 24, position, false);
                    builder.cardinalityBehavior((ActionCardinalityBehavior) parseString(ActionCardinalityBehavior.builder(), "cardinalityBehavior", reader, -1));
                    break;
                case "definitionCanonical":
                    position = checkElementOrder("definition[x]", 25, position, false);
                    builder.definition((Canonical) parseUri(Canonical.builder(), "definitionCanonical", reader, -1));
                    break;
                case "definitionUri":
                    position = checkElementOrder("definition[x]", 25, position, false);
                    builder.definition(parseUri("definitionUri", reader, -1));
                    break;
                case "transform":
                    position = checkElementOrder("transform", 26, position, false);
                    builder.transform((Canonical) parseUri(Canonical.builder(), "transform", reader, -1));
                    break;
                case "dynamicValue":
                    position = checkElementOrder("dynamicValue", 27, position, true);
                    builder.dynamicValue(parsePlanDefinitionActionDynamicValue("dynamicValue", reader, dynamicValueElementIndex++));
                    break;
                case "action":
                    position = checkElementOrder("action", 28, position, true);
                    builder.action(parsePlanDefinitionAction("action", reader, actionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private PlanDefinition.Action.Condition parsePlanDefinitionActionCondition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        PlanDefinition.Action.Condition.Builder builder = PlanDefinition.Action.Condition.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "kind":
                    position = checkElementOrder("kind", 2, position, false);
                    builder.kind((ActionConditionKind) parseString(ActionConditionKind.builder(), "kind", reader, -1));
                    break;
                case "expression":
                    position = checkElementOrder("expression", 3, position, false);
                    builder.expression(parseExpression("expression", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private PlanDefinition.Action.DynamicValue parsePlanDefinitionActionDynamicValue(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        PlanDefinition.Action.DynamicValue.Builder builder = PlanDefinition.Action.DynamicValue.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "path":
                    position = checkElementOrder("path", 2, position, false);
                    builder.path(parseString("path", reader, -1));
                    break;
                case "expression":
                    position = checkElementOrder("expression", 3, position, false);
                    builder.expression(parseExpression("expression", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private PlanDefinition.Action.Participant parsePlanDefinitionActionParticipant(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        PlanDefinition.Action.Participant.Builder builder = PlanDefinition.Action.Participant.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type((ActionParticipantType) parseString(ActionParticipantType.builder(), "type", reader, -1));
                    break;
                case "role":
                    position = checkElementOrder("role", 3, position, false);
                    builder.role(parseCodeableConcept("role", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private PlanDefinition.Action.RelatedAction parsePlanDefinitionActionRelatedAction(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        PlanDefinition.Action.RelatedAction.Builder builder = PlanDefinition.Action.RelatedAction.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "actionId":
                    position = checkElementOrder("actionId", 2, position, false);
                    builder.actionId((Id) parseString(Id.builder(), "actionId", reader, -1));
                    break;
                case "relationship":
                    position = checkElementOrder("relationship", 3, position, false);
                    builder.relationship((ActionRelationshipType) parseString(ActionRelationshipType.builder(), "relationship", reader, -1));
                    break;
                case "offsetDuration":
                    position = checkElementOrder("offset[x]", 4, position, false);
                    builder.offset((Duration) parseQuantity(Duration.builder(), "offsetDuration", reader, -1));
                    break;
                case "offsetRange":
                    position = checkElementOrder("offset[x]", 4, position, false);
                    builder.offset(parseRange("offsetRange", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private PlanDefinition.Goal parsePlanDefinitionGoal(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        PlanDefinition.Goal.Builder builder = PlanDefinition.Goal.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, addressesElementIndex = 0, documentationElementIndex = 0, targetElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "category":
                    position = checkElementOrder("category", 2, position, false);
                    builder.category(parseCodeableConcept("category", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 3, position, false);
                    builder.description(parseCodeableConcept("description", reader, -1));
                    break;
                case "priority":
                    position = checkElementOrder("priority", 4, position, false);
                    builder.priority(parseCodeableConcept("priority", reader, -1));
                    break;
                case "start":
                    position = checkElementOrder("start", 5, position, false);
                    builder.start(parseCodeableConcept("start", reader, -1));
                    break;
                case "addresses":
                    position = checkElementOrder("addresses", 6, position, true);
                    builder.addresses(parseCodeableConcept("addresses", reader, addressesElementIndex++));
                    break;
                case "documentation":
                    position = checkElementOrder("documentation", 7, position, true);
                    builder.documentation(parseRelatedArtifact("documentation", reader, documentationElementIndex++));
                    break;
                case "target":
                    position = checkElementOrder("target", 8, position, true);
                    builder.target(parsePlanDefinitionGoalTarget("target", reader, targetElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private PlanDefinition.Goal.Target parsePlanDefinitionGoalTarget(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        PlanDefinition.Goal.Target.Builder builder = PlanDefinition.Goal.Target.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "measure":
                    position = checkElementOrder("measure", 2, position, false);
                    builder.measure(parseCodeableConcept("measure", reader, -1));
                    break;
                case "detailQuantity":
                    position = checkElementOrder("detail[x]", 3, position, false);
                    builder.detail(parseQuantity("detailQuantity", reader, -1));
                    break;
                case "detailRange":
                    position = checkElementOrder("detail[x]", 3, position, false);
                    builder.detail(parseRange("detailRange", reader, -1));
                    break;
                case "detailCodeableConcept":
                    position = checkElementOrder("detail[x]", 3, position, false);
                    builder.detail(parseCodeableConcept("detailCodeableConcept", reader, -1));
                    break;
                case "due":
                    position = checkElementOrder("due", 4, position, false);
                    builder.due((Duration) parseQuantity(Duration.builder(), "due", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Population parsePopulation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Population.Builder builder = Population.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "ageRange":
                    position = checkElementOrder("age[x]", 2, position, false);
                    builder.age(parseRange("ageRange", reader, -1));
                    break;
                case "ageCodeableConcept":
                    position = checkElementOrder("age[x]", 2, position, false);
                    builder.age(parseCodeableConcept("ageCodeableConcept", reader, -1));
                    break;
                case "gender":
                    position = checkElementOrder("gender", 3, position, false);
                    builder.gender(parseCodeableConcept("gender", reader, -1));
                    break;
                case "race":
                    position = checkElementOrder("race", 4, position, false);
                    builder.race(parseCodeableConcept("race", reader, -1));
                    break;
                case "physiologicalCondition":
                    position = checkElementOrder("physiologicalCondition", 5, position, false);
                    builder.physiologicalCondition(parseCodeableConcept("physiologicalCondition", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Practitioner parsePractitioner(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Practitioner.Builder builder = Practitioner.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, nameElementIndex = 0, telecomElementIndex = 0, addressElementIndex = 0, photoElementIndex = 0, qualificationElementIndex = 0, communicationElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "active":
                    position = checkElementOrder("active", 9, position, false);
                    builder.active(parseBoolean("active", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 10, position, true);
                    builder.name(parseHumanName("name", reader, nameElementIndex++));
                    break;
                case "telecom":
                    position = checkElementOrder("telecom", 11, position, true);
                    builder.telecom(parseContactPoint("telecom", reader, telecomElementIndex++));
                    break;
                case "address":
                    position = checkElementOrder("address", 12, position, true);
                    builder.address(parseAddress("address", reader, addressElementIndex++));
                    break;
                case "gender":
                    position = checkElementOrder("gender", 13, position, false);
                    builder.gender((AdministrativeGender) parseString(AdministrativeGender.builder(), "gender", reader, -1));
                    break;
                case "birthDate":
                    position = checkElementOrder("birthDate", 14, position, false);
                    builder.birthDate(parseDate("birthDate", reader, -1));
                    break;
                case "photo":
                    position = checkElementOrder("photo", 15, position, true);
                    builder.photo(parseAttachment("photo", reader, photoElementIndex++));
                    break;
                case "qualification":
                    position = checkElementOrder("qualification", 16, position, true);
                    builder.qualification(parsePractitionerQualification("qualification", reader, qualificationElementIndex++));
                    break;
                case "communication":
                    position = checkElementOrder("communication", 17, position, true);
                    builder.communication(parseCodeableConcept("communication", reader, communicationElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Practitioner.Qualification parsePractitionerQualification(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Practitioner.Qualification.Builder builder = Practitioner.Qualification.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 2, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 3, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 4, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                case "issuer":
                    position = checkElementOrder("issuer", 5, position, false);
                    builder.issuer(parseReference("issuer", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private PractitionerRole parsePractitionerRole(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        PractitionerRole.Builder builder = PractitionerRole.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, codeElementIndex = 0, specialtyElementIndex = 0, locationElementIndex = 0, healthcareServiceElementIndex = 0, telecomElementIndex = 0, availableTimeElementIndex = 0, notAvailableElementIndex = 0, endpointElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "active":
                    position = checkElementOrder("active", 9, position, false);
                    builder.active(parseBoolean("active", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 10, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                case "practitioner":
                    position = checkElementOrder("practitioner", 11, position, false);
                    builder.practitioner(parseReference("practitioner", reader, -1));
                    break;
                case "organization":
                    position = checkElementOrder("organization", 12, position, false);
                    builder.organization(parseReference("organization", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 13, position, true);
                    builder.code(parseCodeableConcept("code", reader, codeElementIndex++));
                    break;
                case "specialty":
                    position = checkElementOrder("specialty", 14, position, true);
                    builder.specialty(parseCodeableConcept("specialty", reader, specialtyElementIndex++));
                    break;
                case "location":
                    position = checkElementOrder("location", 15, position, true);
                    builder.location(parseReference("location", reader, locationElementIndex++));
                    break;
                case "healthcareService":
                    position = checkElementOrder("healthcareService", 16, position, true);
                    builder.healthcareService(parseReference("healthcareService", reader, healthcareServiceElementIndex++));
                    break;
                case "telecom":
                    position = checkElementOrder("telecom", 17, position, true);
                    builder.telecom(parseContactPoint("telecom", reader, telecomElementIndex++));
                    break;
                case "availableTime":
                    position = checkElementOrder("availableTime", 18, position, true);
                    builder.availableTime(parsePractitionerRoleAvailableTime("availableTime", reader, availableTimeElementIndex++));
                    break;
                case "notAvailable":
                    position = checkElementOrder("notAvailable", 19, position, true);
                    builder.notAvailable(parsePractitionerRoleNotAvailable("notAvailable", reader, notAvailableElementIndex++));
                    break;
                case "availabilityExceptions":
                    position = checkElementOrder("availabilityExceptions", 20, position, false);
                    builder.availabilityExceptions(parseString("availabilityExceptions", reader, -1));
                    break;
                case "endpoint":
                    position = checkElementOrder("endpoint", 21, position, true);
                    builder.endpoint(parseReference("endpoint", reader, endpointElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private PractitionerRole.AvailableTime parsePractitionerRoleAvailableTime(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        PractitionerRole.AvailableTime.Builder builder = PractitionerRole.AvailableTime.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, daysOfWeekElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "daysOfWeek":
                    position = checkElementOrder("daysOfWeek", 2, position, true);
                    builder.daysOfWeek((DaysOfWeek) parseString(DaysOfWeek.builder(), "daysOfWeek", reader, daysOfWeekElementIndex++));
                    break;
                case "allDay":
                    position = checkElementOrder("allDay", 3, position, false);
                    builder.allDay(parseBoolean("allDay", reader, -1));
                    break;
                case "availableStartTime":
                    position = checkElementOrder("availableStartTime", 4, position, false);
                    builder.availableStartTime(parseTime("availableStartTime", reader, -1));
                    break;
                case "availableEndTime":
                    position = checkElementOrder("availableEndTime", 5, position, false);
                    builder.availableEndTime(parseTime("availableEndTime", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private PractitionerRole.NotAvailable parsePractitionerRoleNotAvailable(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        PractitionerRole.NotAvailable.Builder builder = PractitionerRole.NotAvailable.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 2, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "during":
                    position = checkElementOrder("during", 3, position, false);
                    builder.during(parsePeriod("during", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Procedure parseProcedure(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Procedure.Builder builder = Procedure.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, instantiatesCanonicalElementIndex = 0, instantiatesUriElementIndex = 0, basedOnElementIndex = 0, partOfElementIndex = 0, performerElementIndex = 0, reasonCodeElementIndex = 0, reasonReferenceElementIndex = 0, bodySiteElementIndex = 0, reportElementIndex = 0, complicationElementIndex = 0, complicationDetailElementIndex = 0, followUpElementIndex = 0, noteElementIndex = 0, focalDeviceElementIndex = 0, usedReferenceElementIndex = 0, usedCodeElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "instantiatesCanonical":
                    position = checkElementOrder("instantiatesCanonical", 9, position, true);
                    builder.instantiatesCanonical((Canonical) parseUri(Canonical.builder(), "instantiatesCanonical", reader, instantiatesCanonicalElementIndex++));
                    break;
                case "instantiatesUri":
                    position = checkElementOrder("instantiatesUri", 10, position, true);
                    builder.instantiatesUri(parseUri("instantiatesUri", reader, instantiatesUriElementIndex++));
                    break;
                case "basedOn":
                    position = checkElementOrder("basedOn", 11, position, true);
                    builder.basedOn(parseReference("basedOn", reader, basedOnElementIndex++));
                    break;
                case "partOf":
                    position = checkElementOrder("partOf", 12, position, true);
                    builder.partOf(parseReference("partOf", reader, partOfElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 13, position, false);
                    builder.status((ProcedureStatus) parseString(ProcedureStatus.builder(), "status", reader, -1));
                    break;
                case "statusReason":
                    position = checkElementOrder("statusReason", 14, position, false);
                    builder.statusReason(parseCodeableConcept("statusReason", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 15, position, false);
                    builder.category(parseCodeableConcept("category", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 16, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 17, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 18, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "performedDateTime":
                    position = checkElementOrder("performed[x]", 19, position, false);
                    builder.performed(parseDateTime("performedDateTime", reader, -1));
                    break;
                case "performedPeriod":
                    position = checkElementOrder("performed[x]", 19, position, false);
                    builder.performed(parsePeriod("performedPeriod", reader, -1));
                    break;
                case "performedString":
                    position = checkElementOrder("performed[x]", 19, position, false);
                    builder.performed(parseString("performedString", reader, -1));
                    break;
                case "performedAge":
                    position = checkElementOrder("performed[x]", 19, position, false);
                    builder.performed((Age) parseQuantity(Age.builder(), "performedAge", reader, -1));
                    break;
                case "performedRange":
                    position = checkElementOrder("performed[x]", 19, position, false);
                    builder.performed(parseRange("performedRange", reader, -1));
                    break;
                case "recorder":
                    position = checkElementOrder("recorder", 20, position, false);
                    builder.recorder(parseReference("recorder", reader, -1));
                    break;
                case "asserter":
                    position = checkElementOrder("asserter", 21, position, false);
                    builder.asserter(parseReference("asserter", reader, -1));
                    break;
                case "performer":
                    position = checkElementOrder("performer", 22, position, true);
                    builder.performer(parseProcedurePerformer("performer", reader, performerElementIndex++));
                    break;
                case "location":
                    position = checkElementOrder("location", 23, position, false);
                    builder.location(parseReference("location", reader, -1));
                    break;
                case "reasonCode":
                    position = checkElementOrder("reasonCode", 24, position, true);
                    builder.reasonCode(parseCodeableConcept("reasonCode", reader, reasonCodeElementIndex++));
                    break;
                case "reasonReference":
                    position = checkElementOrder("reasonReference", 25, position, true);
                    builder.reasonReference(parseReference("reasonReference", reader, reasonReferenceElementIndex++));
                    break;
                case "bodySite":
                    position = checkElementOrder("bodySite", 26, position, true);
                    builder.bodySite(parseCodeableConcept("bodySite", reader, bodySiteElementIndex++));
                    break;
                case "outcome":
                    position = checkElementOrder("outcome", 27, position, false);
                    builder.outcome(parseCodeableConcept("outcome", reader, -1));
                    break;
                case "report":
                    position = checkElementOrder("report", 28, position, true);
                    builder.report(parseReference("report", reader, reportElementIndex++));
                    break;
                case "complication":
                    position = checkElementOrder("complication", 29, position, true);
                    builder.complication(parseCodeableConcept("complication", reader, complicationElementIndex++));
                    break;
                case "complicationDetail":
                    position = checkElementOrder("complicationDetail", 30, position, true);
                    builder.complicationDetail(parseReference("complicationDetail", reader, complicationDetailElementIndex++));
                    break;
                case "followUp":
                    position = checkElementOrder("followUp", 31, position, true);
                    builder.followUp(parseCodeableConcept("followUp", reader, followUpElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 32, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "focalDevice":
                    position = checkElementOrder("focalDevice", 33, position, true);
                    builder.focalDevice(parseProcedureFocalDevice("focalDevice", reader, focalDeviceElementIndex++));
                    break;
                case "usedReference":
                    position = checkElementOrder("usedReference", 34, position, true);
                    builder.usedReference(parseReference("usedReference", reader, usedReferenceElementIndex++));
                    break;
                case "usedCode":
                    position = checkElementOrder("usedCode", 35, position, true);
                    builder.usedCode(parseCodeableConcept("usedCode", reader, usedCodeElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Procedure.FocalDevice parseProcedureFocalDevice(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Procedure.FocalDevice.Builder builder = Procedure.FocalDevice.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "action":
                    position = checkElementOrder("action", 2, position, false);
                    builder.action(parseCodeableConcept("action", reader, -1));
                    break;
                case "manipulated":
                    position = checkElementOrder("manipulated", 3, position, false);
                    builder.manipulated(parseReference("manipulated", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Procedure.Performer parseProcedurePerformer(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Procedure.Performer.Builder builder = Procedure.Performer.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "function":
                    position = checkElementOrder("function", 2, position, false);
                    builder.function(parseCodeableConcept("function", reader, -1));
                    break;
                case "actor":
                    position = checkElementOrder("actor", 3, position, false);
                    builder.actor(parseReference("actor", reader, -1));
                    break;
                case "onBehalfOf":
                    position = checkElementOrder("onBehalfOf", 4, position, false);
                    builder.onBehalfOf(parseReference("onBehalfOf", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ProdCharacteristic parseProdCharacteristic(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ProdCharacteristic.Builder builder = ProdCharacteristic.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, colorElementIndex = 0, imprintElementIndex = 0, imageElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "height":
                    position = checkElementOrder("height", 2, position, false);
                    builder.height(parseQuantity("height", reader, -1));
                    break;
                case "width":
                    position = checkElementOrder("width", 3, position, false);
                    builder.width(parseQuantity("width", reader, -1));
                    break;
                case "depth":
                    position = checkElementOrder("depth", 4, position, false);
                    builder.depth(parseQuantity("depth", reader, -1));
                    break;
                case "weight":
                    position = checkElementOrder("weight", 5, position, false);
                    builder.weight(parseQuantity("weight", reader, -1));
                    break;
                case "nominalVolume":
                    position = checkElementOrder("nominalVolume", 6, position, false);
                    builder.nominalVolume(parseQuantity("nominalVolume", reader, -1));
                    break;
                case "externalDiameter":
                    position = checkElementOrder("externalDiameter", 7, position, false);
                    builder.externalDiameter(parseQuantity("externalDiameter", reader, -1));
                    break;
                case "shape":
                    position = checkElementOrder("shape", 8, position, false);
                    builder.shape(parseString("shape", reader, -1));
                    break;
                case "color":
                    position = checkElementOrder("color", 9, position, true);
                    builder.color(parseString("color", reader, colorElementIndex++));
                    break;
                case "imprint":
                    position = checkElementOrder("imprint", 10, position, true);
                    builder.imprint(parseString("imprint", reader, imprintElementIndex++));
                    break;
                case "image":
                    position = checkElementOrder("image", 11, position, true);
                    builder.image(parseAttachment("image", reader, imageElementIndex++));
                    break;
                case "scoring":
                    position = checkElementOrder("scoring", 12, position, false);
                    builder.scoring(parseCodeableConcept("scoring", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ProductShelfLife parseProductShelfLife(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ProductShelfLife.Builder builder = ProductShelfLife.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, specialPrecautionsForStorageElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "periodDuration":
                    position = checkElementOrder("period[x]", 3, position, false);
                    builder.period((Duration) parseQuantity(Duration.builder(), "periodDuration", reader, -1));
                    break;
                case "periodString":
                    position = checkElementOrder("period[x]", 3, position, false);
                    builder.period(parseString("periodString", reader, -1));
                    break;
                case "specialPrecautionsForStorage":
                    position = checkElementOrder("specialPrecautionsForStorage", 4, position, true);
                    builder.specialPrecautionsForStorage(parseCodeableConcept("specialPrecautionsForStorage", reader, specialPrecautionsForStorageElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Provenance parseProvenance(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Provenance.Builder builder = Provenance.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, targetElementIndex = 0, policyElementIndex = 0, reasonElementIndex = 0, agentElementIndex = 0, entityElementIndex = 0, signatureElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "target":
                    position = checkElementOrder("target", 8, position, true);
                    builder.target(parseReference("target", reader, targetElementIndex++));
                    break;
                case "occurredPeriod":
                    position = checkElementOrder("occurred[x]", 9, position, false);
                    builder.occurred(parsePeriod("occurredPeriod", reader, -1));
                    break;
                case "occurredDateTime":
                    position = checkElementOrder("occurred[x]", 9, position, false);
                    builder.occurred(parseDateTime("occurredDateTime", reader, -1));
                    break;
                case "recorded":
                    position = checkElementOrder("recorded", 10, position, false);
                    builder.recorded(parseInstant("recorded", reader, -1));
                    break;
                case "policy":
                    position = checkElementOrder("policy", 11, position, true);
                    builder.policy(parseUri("policy", reader, policyElementIndex++));
                    break;
                case "location":
                    position = checkElementOrder("location", 12, position, false);
                    builder.location(parseReference("location", reader, -1));
                    break;
                case "reason":
                    position = checkElementOrder("reason", 13, position, true);
                    builder.reason(parseCodeableConcept("reason", reader, reasonElementIndex++));
                    break;
                case "activity":
                    position = checkElementOrder("activity", 14, position, false);
                    builder.activity(parseCodeableConcept("activity", reader, -1));
                    break;
                case "agent":
                    position = checkElementOrder("agent", 15, position, true);
                    builder.agent(parseProvenanceAgent("agent", reader, agentElementIndex++));
                    break;
                case "entity":
                    position = checkElementOrder("entity", 16, position, true);
                    builder.entity(parseProvenanceEntity("entity", reader, entityElementIndex++));
                    break;
                case "signature":
                    position = checkElementOrder("signature", 17, position, true);
                    builder.signature(parseSignature("signature", reader, signatureElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Provenance.Agent parseProvenanceAgent(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Provenance.Agent.Builder builder = Provenance.Agent.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, roleElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "role":
                    position = checkElementOrder("role", 3, position, true);
                    builder.role(parseCodeableConcept("role", reader, roleElementIndex++));
                    break;
                case "who":
                    position = checkElementOrder("who", 4, position, false);
                    builder.who(parseReference("who", reader, -1));
                    break;
                case "onBehalfOf":
                    position = checkElementOrder("onBehalfOf", 5, position, false);
                    builder.onBehalfOf(parseReference("onBehalfOf", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Provenance.Entity parseProvenanceEntity(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Provenance.Entity.Builder builder = Provenance.Entity.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, agentElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "role":
                    position = checkElementOrder("role", 2, position, false);
                    builder.role((ProvenanceEntityRole) parseString(ProvenanceEntityRole.builder(), "role", reader, -1));
                    break;
                case "what":
                    position = checkElementOrder("what", 3, position, false);
                    builder.what(parseReference("what", reader, -1));
                    break;
                case "agent":
                    position = checkElementOrder("agent", 4, position, true);
                    builder.agent(parseProvenanceAgent("agent", reader, agentElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Quantity parseQuantity(Quantity.Builder builder, java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "value":
                    position = checkElementOrder("value", 1, position, false);
                    builder.value(parseDecimal("value", reader, -1));
                    break;
                case "comparator":
                    position = checkElementOrder("comparator", 2, position, false);
                    builder.comparator((QuantityComparator) parseString(QuantityComparator.builder(), "comparator", reader, -1));
                    break;
                case "unit":
                    position = checkElementOrder("unit", 3, position, false);
                    builder.unit(parseString("unit", reader, -1));
                    break;
                case "system":
                    position = checkElementOrder("system", 4, position, false);
                    builder.system(parseUri("system", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 5, position, false);
                    builder.code((Code) parseString(Code.builder(), "code", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Quantity parseQuantity(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        return parseQuantity(Quantity.builder(), elementName, reader, elementIndex);
    }

    private Questionnaire parseQuestionnaire(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Questionnaire.Builder builder = Questionnaire.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, derivedFromElementIndex = 0, subjectTypeElementIndex = 0, contactElementIndex = 0, useContextElementIndex = 0, jurisdictionElementIndex = 0, codeElementIndex = 0, itemElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 10, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 11, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 12, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "derivedFrom":
                    position = checkElementOrder("derivedFrom", 13, position, true);
                    builder.derivedFrom((Canonical) parseUri(Canonical.builder(), "derivedFrom", reader, derivedFromElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 14, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 15, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "subjectType":
                    position = checkElementOrder("subjectType", 16, position, true);
                    builder.subjectType((ResourceTypeCode) parseString(ResourceTypeCode.builder(), "subjectType", reader, subjectTypeElementIndex++));
                    break;
                case "date":
                    position = checkElementOrder("date", 17, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 18, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 19, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 20, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 21, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 22, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 23, position, false);
                    builder.purpose((Markdown) parseString(Markdown.builder(), "purpose", reader, -1));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 24, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                case "approvalDate":
                    position = checkElementOrder("approvalDate", 25, position, false);
                    builder.approvalDate(parseDate("approvalDate", reader, -1));
                    break;
                case "lastReviewDate":
                    position = checkElementOrder("lastReviewDate", 26, position, false);
                    builder.lastReviewDate(parseDate("lastReviewDate", reader, -1));
                    break;
                case "effectivePeriod":
                    position = checkElementOrder("effectivePeriod", 27, position, false);
                    builder.effectivePeriod(parsePeriod("effectivePeriod", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 28, position, true);
                    builder.code(parseCoding("code", reader, codeElementIndex++));
                    break;
                case "item":
                    position = checkElementOrder("item", 29, position, true);
                    builder.item(parseQuestionnaireItem("item", reader, itemElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Questionnaire.Item parseQuestionnaireItem(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Questionnaire.Item.Builder builder = Questionnaire.Item.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, codeElementIndex = 0, enableWhenElementIndex = 0, answerOptionElementIndex = 0, initialElementIndex = 0, itemElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "linkId":
                    position = checkElementOrder("linkId", 2, position, false);
                    builder.linkId(parseString("linkId", reader, -1));
                    break;
                case "definition":
                    position = checkElementOrder("definition", 3, position, false);
                    builder.definition(parseUri("definition", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 4, position, true);
                    builder.code(parseCoding("code", reader, codeElementIndex++));
                    break;
                case "prefix":
                    position = checkElementOrder("prefix", 5, position, false);
                    builder.prefix(parseString("prefix", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 6, position, false);
                    builder.text(parseString("text", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 7, position, false);
                    builder.type((QuestionnaireItemType) parseString(QuestionnaireItemType.builder(), "type", reader, -1));
                    break;
                case "enableWhen":
                    position = checkElementOrder("enableWhen", 8, position, true);
                    builder.enableWhen(parseQuestionnaireItemEnableWhen("enableWhen", reader, enableWhenElementIndex++));
                    break;
                case "enableBehavior":
                    position = checkElementOrder("enableBehavior", 9, position, false);
                    builder.enableBehavior((EnableWhenBehavior) parseString(EnableWhenBehavior.builder(), "enableBehavior", reader, -1));
                    break;
                case "required":
                    position = checkElementOrder("required", 10, position, false);
                    builder.required(parseBoolean("required", reader, -1));
                    break;
                case "repeats":
                    position = checkElementOrder("repeats", 11, position, false);
                    builder.repeats(parseBoolean("repeats", reader, -1));
                    break;
                case "readOnly":
                    position = checkElementOrder("readOnly", 12, position, false);
                    builder.readOnly(parseBoolean("readOnly", reader, -1));
                    break;
                case "maxLength":
                    position = checkElementOrder("maxLength", 13, position, false);
                    builder.maxLength(parseInteger("maxLength", reader, -1));
                    break;
                case "answerValueSet":
                    position = checkElementOrder("answerValueSet", 14, position, false);
                    builder.answerValueSet((Canonical) parseUri(Canonical.builder(), "answerValueSet", reader, -1));
                    break;
                case "answerOption":
                    position = checkElementOrder("answerOption", 15, position, true);
                    builder.answerOption(parseQuestionnaireItemAnswerOption("answerOption", reader, answerOptionElementIndex++));
                    break;
                case "initial":
                    position = checkElementOrder("initial", 16, position, true);
                    builder.initial(parseQuestionnaireItemInitial("initial", reader, initialElementIndex++));
                    break;
                case "item":
                    position = checkElementOrder("item", 17, position, true);
                    builder.item(parseQuestionnaireItem("item", reader, itemElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Questionnaire.Item.AnswerOption parseQuestionnaireItemAnswerOption(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Questionnaire.Item.AnswerOption.Builder builder = Questionnaire.Item.AnswerOption.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "valueInteger":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseInteger("valueInteger", reader, -1));
                    break;
                case "valueDate":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseDate("valueDate", reader, -1));
                    break;
                case "valueTime":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseTime("valueTime", reader, -1));
                    break;
                case "valueString":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseString("valueString", reader, -1));
                    break;
                case "valueCoding":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseCoding("valueCoding", reader, -1));
                    break;
                case "valueReference":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseReference("valueReference", reader, -1));
                    break;
                case "initialSelected":
                    position = checkElementOrder("initialSelected", 3, position, false);
                    builder.initialSelected(parseBoolean("initialSelected", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Questionnaire.Item.EnableWhen parseQuestionnaireItemEnableWhen(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Questionnaire.Item.EnableWhen.Builder builder = Questionnaire.Item.EnableWhen.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "question":
                    position = checkElementOrder("question", 2, position, false);
                    builder.question(parseString("question", reader, -1));
                    break;
                case "operator":
                    position = checkElementOrder("operator", 3, position, false);
                    builder.operator((QuestionnaireItemOperator) parseString(QuestionnaireItemOperator.builder(), "operator", reader, -1));
                    break;
                case "answerBoolean":
                    position = checkElementOrder("answer[x]", 4, position, false);
                    builder.answer(parseBoolean("answerBoolean", reader, -1));
                    break;
                case "answerDecimal":
                    position = checkElementOrder("answer[x]", 4, position, false);
                    builder.answer(parseDecimal("answerDecimal", reader, -1));
                    break;
                case "answerInteger":
                    position = checkElementOrder("answer[x]", 4, position, false);
                    builder.answer(parseInteger("answerInteger", reader, -1));
                    break;
                case "answerDate":
                    position = checkElementOrder("answer[x]", 4, position, false);
                    builder.answer(parseDate("answerDate", reader, -1));
                    break;
                case "answerDateTime":
                    position = checkElementOrder("answer[x]", 4, position, false);
                    builder.answer(parseDateTime("answerDateTime", reader, -1));
                    break;
                case "answerTime":
                    position = checkElementOrder("answer[x]", 4, position, false);
                    builder.answer(parseTime("answerTime", reader, -1));
                    break;
                case "answerString":
                    position = checkElementOrder("answer[x]", 4, position, false);
                    builder.answer(parseString("answerString", reader, -1));
                    break;
                case "answerCoding":
                    position = checkElementOrder("answer[x]", 4, position, false);
                    builder.answer(parseCoding("answerCoding", reader, -1));
                    break;
                case "answerQuantity":
                    position = checkElementOrder("answer[x]", 4, position, false);
                    builder.answer(parseQuantity("answerQuantity", reader, -1));
                    break;
                case "answerReference":
                    position = checkElementOrder("answer[x]", 4, position, false);
                    builder.answer(parseReference("answerReference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Questionnaire.Item.Initial parseQuestionnaireItemInitial(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Questionnaire.Item.Initial.Builder builder = Questionnaire.Item.Initial.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueDecimal":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseDecimal("valueDecimal", reader, -1));
                    break;
                case "valueInteger":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseInteger("valueInteger", reader, -1));
                    break;
                case "valueDate":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseDate("valueDate", reader, -1));
                    break;
                case "valueDateTime":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseDateTime("valueDateTime", reader, -1));
                    break;
                case "valueTime":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseTime("valueTime", reader, -1));
                    break;
                case "valueString":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseString("valueString", reader, -1));
                    break;
                case "valueUri":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseUri("valueUri", reader, -1));
                    break;
                case "valueAttachment":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseAttachment("valueAttachment", reader, -1));
                    break;
                case "valueCoding":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseCoding("valueCoding", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueReference":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseReference("valueReference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private QuestionnaireResponse parseQuestionnaireResponse(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        QuestionnaireResponse.Builder builder = QuestionnaireResponse.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, basedOnElementIndex = 0, partOfElementIndex = 0, itemElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, false);
                    builder.identifier(parseIdentifier("identifier", reader, -1));
                    break;
                case "basedOn":
                    position = checkElementOrder("basedOn", 9, position, true);
                    builder.basedOn(parseReference("basedOn", reader, basedOnElementIndex++));
                    break;
                case "partOf":
                    position = checkElementOrder("partOf", 10, position, true);
                    builder.partOf(parseReference("partOf", reader, partOfElementIndex++));
                    break;
                case "questionnaire":
                    position = checkElementOrder("questionnaire", 11, position, false);
                    builder.questionnaire((Canonical) parseUri(Canonical.builder(), "questionnaire", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 12, position, false);
                    builder.status((QuestionnaireResponseStatus) parseString(QuestionnaireResponseStatus.builder(), "status", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 13, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 14, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "authored":
                    position = checkElementOrder("authored", 15, position, false);
                    builder.authored(parseDateTime("authored", reader, -1));
                    break;
                case "author":
                    position = checkElementOrder("author", 16, position, false);
                    builder.author(parseReference("author", reader, -1));
                    break;
                case "source":
                    position = checkElementOrder("source", 17, position, false);
                    builder.source(parseReference("source", reader, -1));
                    break;
                case "item":
                    position = checkElementOrder("item", 18, position, true);
                    builder.item(parseQuestionnaireResponseItem("item", reader, itemElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private QuestionnaireResponse.Item parseQuestionnaireResponseItem(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        QuestionnaireResponse.Item.Builder builder = QuestionnaireResponse.Item.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, answerElementIndex = 0, itemElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "linkId":
                    position = checkElementOrder("linkId", 2, position, false);
                    builder.linkId(parseString("linkId", reader, -1));
                    break;
                case "definition":
                    position = checkElementOrder("definition", 3, position, false);
                    builder.definition(parseUri("definition", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseString("text", reader, -1));
                    break;
                case "answer":
                    position = checkElementOrder("answer", 5, position, true);
                    builder.answer(parseQuestionnaireResponseItemAnswer("answer", reader, answerElementIndex++));
                    break;
                case "item":
                    position = checkElementOrder("item", 6, position, true);
                    builder.item(parseQuestionnaireResponseItem("item", reader, itemElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private QuestionnaireResponse.Item.Answer parseQuestionnaireResponseItemAnswer(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        QuestionnaireResponse.Item.Answer.Builder builder = QuestionnaireResponse.Item.Answer.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, itemElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueDecimal":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseDecimal("valueDecimal", reader, -1));
                    break;
                case "valueInteger":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseInteger("valueInteger", reader, -1));
                    break;
                case "valueDate":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseDate("valueDate", reader, -1));
                    break;
                case "valueDateTime":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseDateTime("valueDateTime", reader, -1));
                    break;
                case "valueTime":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseTime("valueTime", reader, -1));
                    break;
                case "valueString":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseString("valueString", reader, -1));
                    break;
                case "valueUri":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseUri("valueUri", reader, -1));
                    break;
                case "valueAttachment":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseAttachment("valueAttachment", reader, -1));
                    break;
                case "valueCoding":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseCoding("valueCoding", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueReference":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseReference("valueReference", reader, -1));
                    break;
                case "item":
                    position = checkElementOrder("item", 3, position, true);
                    builder.item(parseQuestionnaireResponseItem("item", reader, itemElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Range parseRange(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Range.Builder builder = Range.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "low":
                    position = checkElementOrder("low", 1, position, false);
                    builder.low((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "low", reader, -1));
                    break;
                case "high":
                    position = checkElementOrder("high", 2, position, false);
                    builder.high((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "high", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Ratio parseRatio(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Ratio.Builder builder = Ratio.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "numerator":
                    position = checkElementOrder("numerator", 1, position, false);
                    builder.numerator(parseQuantity("numerator", reader, -1));
                    break;
                case "denominator":
                    position = checkElementOrder("denominator", 2, position, false);
                    builder.denominator(parseQuantity("denominator", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private RatioRange parseRatioRange(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        RatioRange.Builder builder = RatioRange.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "lowNumerator":
                    position = checkElementOrder("lowNumerator", 1, position, false);
                    builder.lowNumerator((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "lowNumerator", reader, -1));
                    break;
                case "highNumerator":
                    position = checkElementOrder("highNumerator", 2, position, false);
                    builder.highNumerator((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "highNumerator", reader, -1));
                    break;
                case "denominator":
                    position = checkElementOrder("denominator", 3, position, false);
                    builder.denominator((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "denominator", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Reference parseReference(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Reference.Builder builder = Reference.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "reference":
                    position = checkElementOrder("reference", 1, position, false);
                    builder.reference(parseString("reference", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseUri("type", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 3, position, false);
                    builder.identifier(parseIdentifier("identifier", reader, -1));
                    break;
                case "display":
                    position = checkElementOrder("display", 4, position, false);
                    builder.display(parseString("display", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private RegulatedAuthorization parseRegulatedAuthorization(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        RegulatedAuthorization.Builder builder = RegulatedAuthorization.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, subjectElementIndex = 0, regionElementIndex = 0, basisElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 9, position, true);
                    builder.subject(parseReference("subject", reader, subjectElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 10, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 11, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "region":
                    position = checkElementOrder("region", 12, position, true);
                    builder.region(parseCodeableConcept("region", reader, regionElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 13, position, false);
                    builder.status(parseCodeableConcept("status", reader, -1));
                    break;
                case "statusDate":
                    position = checkElementOrder("statusDate", 14, position, false);
                    builder.statusDate(parseDateTime("statusDate", reader, -1));
                    break;
                case "validityPeriod":
                    position = checkElementOrder("validityPeriod", 15, position, false);
                    builder.validityPeriod(parsePeriod("validityPeriod", reader, -1));
                    break;
                case "indication":
                    position = checkElementOrder("indication", 16, position, false);
                    builder.indication(parseCodeableReference("indication", reader, -1));
                    break;
                case "intendedUse":
                    position = checkElementOrder("intendedUse", 17, position, false);
                    builder.intendedUse(parseCodeableConcept("intendedUse", reader, -1));
                    break;
                case "basis":
                    position = checkElementOrder("basis", 18, position, true);
                    builder.basis(parseCodeableConcept("basis", reader, basisElementIndex++));
                    break;
                case "holder":
                    position = checkElementOrder("holder", 19, position, false);
                    builder.holder(parseReference("holder", reader, -1));
                    break;
                case "regulator":
                    position = checkElementOrder("regulator", 20, position, false);
                    builder.regulator(parseReference("regulator", reader, -1));
                    break;
                case "case":
                    position = checkElementOrder("case", 21, position, false);
                    builder._case(parseRegulatedAuthorizationCase("case", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private RegulatedAuthorization.Case parseRegulatedAuthorizationCase(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        RegulatedAuthorization.Case.Builder builder = RegulatedAuthorization.Case.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, applicationElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 2, position, false);
                    builder.identifier(parseIdentifier("identifier", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 4, position, false);
                    builder.status(parseCodeableConcept("status", reader, -1));
                    break;
                case "datePeriod":
                    position = checkElementOrder("date[x]", 5, position, false);
                    builder.date(parsePeriod("datePeriod", reader, -1));
                    break;
                case "dateDateTime":
                    position = checkElementOrder("date[x]", 5, position, false);
                    builder.date(parseDateTime("dateDateTime", reader, -1));
                    break;
                case "application":
                    position = checkElementOrder("application", 6, position, true);
                    builder.application(parseRegulatedAuthorizationCase("application", reader, applicationElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private RelatedArtifact parseRelatedArtifact(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        RelatedArtifact.Builder builder = RelatedArtifact.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 1, position, false);
                    builder.type((RelatedArtifactType) parseString(RelatedArtifactType.builder(), "type", reader, -1));
                    break;
                case "label":
                    position = checkElementOrder("label", 2, position, false);
                    builder.label(parseString("label", reader, -1));
                    break;
                case "display":
                    position = checkElementOrder("display", 3, position, false);
                    builder.display(parseString("display", reader, -1));
                    break;
                case "citation":
                    position = checkElementOrder("citation", 4, position, false);
                    builder.citation((Markdown) parseString(Markdown.builder(), "citation", reader, -1));
                    break;
                case "url":
                    position = checkElementOrder("url", 5, position, false);
                    builder.url((Url) parseUri(Url.builder(), "url", reader, -1));
                    break;
                case "document":
                    position = checkElementOrder("document", 6, position, false);
                    builder.document(parseAttachment("document", reader, -1));
                    break;
                case "resource":
                    position = checkElementOrder("resource", 7, position, false);
                    builder.resource((Canonical) parseUri(Canonical.builder(), "resource", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private RelatedPerson parseRelatedPerson(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        RelatedPerson.Builder builder = RelatedPerson.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, relationshipElementIndex = 0, nameElementIndex = 0, telecomElementIndex = 0, addressElementIndex = 0, photoElementIndex = 0, communicationElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "active":
                    position = checkElementOrder("active", 9, position, false);
                    builder.active(parseBoolean("active", reader, -1));
                    break;
                case "patient":
                    position = checkElementOrder("patient", 10, position, false);
                    builder.patient(parseReference("patient", reader, -1));
                    break;
                case "relationship":
                    position = checkElementOrder("relationship", 11, position, true);
                    builder.relationship(parseCodeableConcept("relationship", reader, relationshipElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 12, position, true);
                    builder.name(parseHumanName("name", reader, nameElementIndex++));
                    break;
                case "telecom":
                    position = checkElementOrder("telecom", 13, position, true);
                    builder.telecom(parseContactPoint("telecom", reader, telecomElementIndex++));
                    break;
                case "gender":
                    position = checkElementOrder("gender", 14, position, false);
                    builder.gender((AdministrativeGender) parseString(AdministrativeGender.builder(), "gender", reader, -1));
                    break;
                case "birthDate":
                    position = checkElementOrder("birthDate", 15, position, false);
                    builder.birthDate(parseDate("birthDate", reader, -1));
                    break;
                case "address":
                    position = checkElementOrder("address", 16, position, true);
                    builder.address(parseAddress("address", reader, addressElementIndex++));
                    break;
                case "photo":
                    position = checkElementOrder("photo", 17, position, true);
                    builder.photo(parseAttachment("photo", reader, photoElementIndex++));
                    break;
                case "period":
                    position = checkElementOrder("period", 18, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                case "communication":
                    position = checkElementOrder("communication", 19, position, true);
                    builder.communication(parseRelatedPersonCommunication("communication", reader, communicationElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private RelatedPerson.Communication parseRelatedPersonCommunication(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        RelatedPerson.Communication.Builder builder = RelatedPerson.Communication.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "language":
                    position = checkElementOrder("language", 2, position, false);
                    builder.language(parseCodeableConcept("language", reader, -1));
                    break;
                case "preferred":
                    position = checkElementOrder("preferred", 3, position, false);
                    builder.preferred(parseBoolean("preferred", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private RequestGroup parseRequestGroup(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        RequestGroup.Builder builder = RequestGroup.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, instantiatesCanonicalElementIndex = 0, instantiatesUriElementIndex = 0, basedOnElementIndex = 0, replacesElementIndex = 0, reasonCodeElementIndex = 0, reasonReferenceElementIndex = 0, noteElementIndex = 0, actionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "instantiatesCanonical":
                    position = checkElementOrder("instantiatesCanonical", 9, position, true);
                    builder.instantiatesCanonical((Canonical) parseUri(Canonical.builder(), "instantiatesCanonical", reader, instantiatesCanonicalElementIndex++));
                    break;
                case "instantiatesUri":
                    position = checkElementOrder("instantiatesUri", 10, position, true);
                    builder.instantiatesUri(parseUri("instantiatesUri", reader, instantiatesUriElementIndex++));
                    break;
                case "basedOn":
                    position = checkElementOrder("basedOn", 11, position, true);
                    builder.basedOn(parseReference("basedOn", reader, basedOnElementIndex++));
                    break;
                case "replaces":
                    position = checkElementOrder("replaces", 12, position, true);
                    builder.replaces(parseReference("replaces", reader, replacesElementIndex++));
                    break;
                case "groupIdentifier":
                    position = checkElementOrder("groupIdentifier", 13, position, false);
                    builder.groupIdentifier(parseIdentifier("groupIdentifier", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 14, position, false);
                    builder.status((RequestStatus) parseString(RequestStatus.builder(), "status", reader, -1));
                    break;
                case "intent":
                    position = checkElementOrder("intent", 15, position, false);
                    builder.intent((RequestIntent) parseString(RequestIntent.builder(), "intent", reader, -1));
                    break;
                case "priority":
                    position = checkElementOrder("priority", 16, position, false);
                    builder.priority((RequestPriority) parseString(RequestPriority.builder(), "priority", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 17, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 18, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 19, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "authoredOn":
                    position = checkElementOrder("authoredOn", 20, position, false);
                    builder.authoredOn(parseDateTime("authoredOn", reader, -1));
                    break;
                case "author":
                    position = checkElementOrder("author", 21, position, false);
                    builder.author(parseReference("author", reader, -1));
                    break;
                case "reasonCode":
                    position = checkElementOrder("reasonCode", 22, position, true);
                    builder.reasonCode(parseCodeableConcept("reasonCode", reader, reasonCodeElementIndex++));
                    break;
                case "reasonReference":
                    position = checkElementOrder("reasonReference", 23, position, true);
                    builder.reasonReference(parseReference("reasonReference", reader, reasonReferenceElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 24, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "action":
                    position = checkElementOrder("action", 25, position, true);
                    builder.action(parseRequestGroupAction("action", reader, actionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private RequestGroup.Action parseRequestGroupAction(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        RequestGroup.Action.Builder builder = RequestGroup.Action.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, codeElementIndex = 0, documentationElementIndex = 0, conditionElementIndex = 0, relatedActionElementIndex = 0, participantElementIndex = 0, actionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "prefix":
                    position = checkElementOrder("prefix", 2, position, false);
                    builder.prefix(parseString("prefix", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 3, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 4, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "textEquivalent":
                    position = checkElementOrder("textEquivalent", 5, position, false);
                    builder.textEquivalent(parseString("textEquivalent", reader, -1));
                    break;
                case "priority":
                    position = checkElementOrder("priority", 6, position, false);
                    builder.priority((RequestPriority) parseString(RequestPriority.builder(), "priority", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 7, position, true);
                    builder.code(parseCodeableConcept("code", reader, codeElementIndex++));
                    break;
                case "documentation":
                    position = checkElementOrder("documentation", 8, position, true);
                    builder.documentation(parseRelatedArtifact("documentation", reader, documentationElementIndex++));
                    break;
                case "condition":
                    position = checkElementOrder("condition", 9, position, true);
                    builder.condition(parseRequestGroupActionCondition("condition", reader, conditionElementIndex++));
                    break;
                case "relatedAction":
                    position = checkElementOrder("relatedAction", 10, position, true);
                    builder.relatedAction(parseRequestGroupActionRelatedAction("relatedAction", reader, relatedActionElementIndex++));
                    break;
                case "timingDateTime":
                    position = checkElementOrder("timing[x]", 11, position, false);
                    builder.timing(parseDateTime("timingDateTime", reader, -1));
                    break;
                case "timingAge":
                    position = checkElementOrder("timing[x]", 11, position, false);
                    builder.timing((Age) parseQuantity(Age.builder(), "timingAge", reader, -1));
                    break;
                case "timingPeriod":
                    position = checkElementOrder("timing[x]", 11, position, false);
                    builder.timing(parsePeriod("timingPeriod", reader, -1));
                    break;
                case "timingDuration":
                    position = checkElementOrder("timing[x]", 11, position, false);
                    builder.timing((Duration) parseQuantity(Duration.builder(), "timingDuration", reader, -1));
                    break;
                case "timingRange":
                    position = checkElementOrder("timing[x]", 11, position, false);
                    builder.timing(parseRange("timingRange", reader, -1));
                    break;
                case "timingTiming":
                    position = checkElementOrder("timing[x]", 11, position, false);
                    builder.timing(parseTiming("timingTiming", reader, -1));
                    break;
                case "participant":
                    position = checkElementOrder("participant", 12, position, true);
                    builder.participant(parseReference("participant", reader, participantElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 13, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "groupingBehavior":
                    position = checkElementOrder("groupingBehavior", 14, position, false);
                    builder.groupingBehavior((ActionGroupingBehavior) parseString(ActionGroupingBehavior.builder(), "groupingBehavior", reader, -1));
                    break;
                case "selectionBehavior":
                    position = checkElementOrder("selectionBehavior", 15, position, false);
                    builder.selectionBehavior((ActionSelectionBehavior) parseString(ActionSelectionBehavior.builder(), "selectionBehavior", reader, -1));
                    break;
                case "requiredBehavior":
                    position = checkElementOrder("requiredBehavior", 16, position, false);
                    builder.requiredBehavior((ActionRequiredBehavior) parseString(ActionRequiredBehavior.builder(), "requiredBehavior", reader, -1));
                    break;
                case "precheckBehavior":
                    position = checkElementOrder("precheckBehavior", 17, position, false);
                    builder.precheckBehavior((ActionPrecheckBehavior) parseString(ActionPrecheckBehavior.builder(), "precheckBehavior", reader, -1));
                    break;
                case "cardinalityBehavior":
                    position = checkElementOrder("cardinalityBehavior", 18, position, false);
                    builder.cardinalityBehavior((ActionCardinalityBehavior) parseString(ActionCardinalityBehavior.builder(), "cardinalityBehavior", reader, -1));
                    break;
                case "resource":
                    position = checkElementOrder("resource", 19, position, false);
                    builder.resource(parseReference("resource", reader, -1));
                    break;
                case "action":
                    position = checkElementOrder("action", 20, position, true);
                    builder.action(parseRequestGroupAction("action", reader, actionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private RequestGroup.Action.Condition parseRequestGroupActionCondition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        RequestGroup.Action.Condition.Builder builder = RequestGroup.Action.Condition.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "kind":
                    position = checkElementOrder("kind", 2, position, false);
                    builder.kind((ActionConditionKind) parseString(ActionConditionKind.builder(), "kind", reader, -1));
                    break;
                case "expression":
                    position = checkElementOrder("expression", 3, position, false);
                    builder.expression(parseExpression("expression", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private RequestGroup.Action.RelatedAction parseRequestGroupActionRelatedAction(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        RequestGroup.Action.RelatedAction.Builder builder = RequestGroup.Action.RelatedAction.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "actionId":
                    position = checkElementOrder("actionId", 2, position, false);
                    builder.actionId((Id) parseString(Id.builder(), "actionId", reader, -1));
                    break;
                case "relationship":
                    position = checkElementOrder("relationship", 3, position, false);
                    builder.relationship((ActionRelationshipType) parseString(ActionRelationshipType.builder(), "relationship", reader, -1));
                    break;
                case "offsetDuration":
                    position = checkElementOrder("offset[x]", 4, position, false);
                    builder.offset((Duration) parseQuantity(Duration.builder(), "offsetDuration", reader, -1));
                    break;
                case "offsetRange":
                    position = checkElementOrder("offset[x]", 4, position, false);
                    builder.offset(parseRange("offsetRange", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ResearchDefinition parseResearchDefinition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ResearchDefinition.Builder builder = ResearchDefinition.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, contactElementIndex = 0, commentElementIndex = 0, useContextElementIndex = 0, jurisdictionElementIndex = 0, topicElementIndex = 0, authorElementIndex = 0, editorElementIndex = 0, reviewerElementIndex = 0, endorserElementIndex = 0, relatedArtifactElementIndex = 0, libraryElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 10, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 11, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 12, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "shortTitle":
                    position = checkElementOrder("shortTitle", 13, position, false);
                    builder.shortTitle(parseString("shortTitle", reader, -1));
                    break;
                case "subtitle":
                    position = checkElementOrder("subtitle", 14, position, false);
                    builder.subtitle(parseString("subtitle", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 15, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 16, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "subjectCodeableConcept":
                    position = checkElementOrder("subject[x]", 17, position, false);
                    builder.subject(parseCodeableConcept("subjectCodeableConcept", reader, -1));
                    break;
                case "subjectReference":
                    position = checkElementOrder("subject[x]", 17, position, false);
                    builder.subject(parseReference("subjectReference", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 18, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 19, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 20, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 21, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "comment":
                    position = checkElementOrder("comment", 22, position, true);
                    builder.comment(parseString("comment", reader, commentElementIndex++));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 23, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 24, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 25, position, false);
                    builder.purpose((Markdown) parseString(Markdown.builder(), "purpose", reader, -1));
                    break;
                case "usage":
                    position = checkElementOrder("usage", 26, position, false);
                    builder.usage(parseString("usage", reader, -1));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 27, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                case "approvalDate":
                    position = checkElementOrder("approvalDate", 28, position, false);
                    builder.approvalDate(parseDate("approvalDate", reader, -1));
                    break;
                case "lastReviewDate":
                    position = checkElementOrder("lastReviewDate", 29, position, false);
                    builder.lastReviewDate(parseDate("lastReviewDate", reader, -1));
                    break;
                case "effectivePeriod":
                    position = checkElementOrder("effectivePeriod", 30, position, false);
                    builder.effectivePeriod(parsePeriod("effectivePeriod", reader, -1));
                    break;
                case "topic":
                    position = checkElementOrder("topic", 31, position, true);
                    builder.topic(parseCodeableConcept("topic", reader, topicElementIndex++));
                    break;
                case "author":
                    position = checkElementOrder("author", 32, position, true);
                    builder.author(parseContactDetail("author", reader, authorElementIndex++));
                    break;
                case "editor":
                    position = checkElementOrder("editor", 33, position, true);
                    builder.editor(parseContactDetail("editor", reader, editorElementIndex++));
                    break;
                case "reviewer":
                    position = checkElementOrder("reviewer", 34, position, true);
                    builder.reviewer(parseContactDetail("reviewer", reader, reviewerElementIndex++));
                    break;
                case "endorser":
                    position = checkElementOrder("endorser", 35, position, true);
                    builder.endorser(parseContactDetail("endorser", reader, endorserElementIndex++));
                    break;
                case "relatedArtifact":
                    position = checkElementOrder("relatedArtifact", 36, position, true);
                    builder.relatedArtifact(parseRelatedArtifact("relatedArtifact", reader, relatedArtifactElementIndex++));
                    break;
                case "library":
                    position = checkElementOrder("library", 37, position, true);
                    builder.library((Canonical) parseUri(Canonical.builder(), "library", reader, libraryElementIndex++));
                    break;
                case "population":
                    position = checkElementOrder("population", 38, position, false);
                    builder.population(parseReference("population", reader, -1));
                    break;
                case "exposure":
                    position = checkElementOrder("exposure", 39, position, false);
                    builder.exposure(parseReference("exposure", reader, -1));
                    break;
                case "exposureAlternative":
                    position = checkElementOrder("exposureAlternative", 40, position, false);
                    builder.exposureAlternative(parseReference("exposureAlternative", reader, -1));
                    break;
                case "outcome":
                    position = checkElementOrder("outcome", 41, position, false);
                    builder.outcome(parseReference("outcome", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ResearchElementDefinition parseResearchElementDefinition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ResearchElementDefinition.Builder builder = ResearchElementDefinition.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, contactElementIndex = 0, commentElementIndex = 0, useContextElementIndex = 0, jurisdictionElementIndex = 0, topicElementIndex = 0, authorElementIndex = 0, editorElementIndex = 0, reviewerElementIndex = 0, endorserElementIndex = 0, relatedArtifactElementIndex = 0, libraryElementIndex = 0, characteristicElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 10, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 11, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 12, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "shortTitle":
                    position = checkElementOrder("shortTitle", 13, position, false);
                    builder.shortTitle(parseString("shortTitle", reader, -1));
                    break;
                case "subtitle":
                    position = checkElementOrder("subtitle", 14, position, false);
                    builder.subtitle(parseString("subtitle", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 15, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 16, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "subjectCodeableConcept":
                    position = checkElementOrder("subject[x]", 17, position, false);
                    builder.subject(parseCodeableConcept("subjectCodeableConcept", reader, -1));
                    break;
                case "subjectReference":
                    position = checkElementOrder("subject[x]", 17, position, false);
                    builder.subject(parseReference("subjectReference", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 18, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 19, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 20, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 21, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "comment":
                    position = checkElementOrder("comment", 22, position, true);
                    builder.comment(parseString("comment", reader, commentElementIndex++));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 23, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 24, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 25, position, false);
                    builder.purpose((Markdown) parseString(Markdown.builder(), "purpose", reader, -1));
                    break;
                case "usage":
                    position = checkElementOrder("usage", 26, position, false);
                    builder.usage(parseString("usage", reader, -1));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 27, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                case "approvalDate":
                    position = checkElementOrder("approvalDate", 28, position, false);
                    builder.approvalDate(parseDate("approvalDate", reader, -1));
                    break;
                case "lastReviewDate":
                    position = checkElementOrder("lastReviewDate", 29, position, false);
                    builder.lastReviewDate(parseDate("lastReviewDate", reader, -1));
                    break;
                case "effectivePeriod":
                    position = checkElementOrder("effectivePeriod", 30, position, false);
                    builder.effectivePeriod(parsePeriod("effectivePeriod", reader, -1));
                    break;
                case "topic":
                    position = checkElementOrder("topic", 31, position, true);
                    builder.topic(parseCodeableConcept("topic", reader, topicElementIndex++));
                    break;
                case "author":
                    position = checkElementOrder("author", 32, position, true);
                    builder.author(parseContactDetail("author", reader, authorElementIndex++));
                    break;
                case "editor":
                    position = checkElementOrder("editor", 33, position, true);
                    builder.editor(parseContactDetail("editor", reader, editorElementIndex++));
                    break;
                case "reviewer":
                    position = checkElementOrder("reviewer", 34, position, true);
                    builder.reviewer(parseContactDetail("reviewer", reader, reviewerElementIndex++));
                    break;
                case "endorser":
                    position = checkElementOrder("endorser", 35, position, true);
                    builder.endorser(parseContactDetail("endorser", reader, endorserElementIndex++));
                    break;
                case "relatedArtifact":
                    position = checkElementOrder("relatedArtifact", 36, position, true);
                    builder.relatedArtifact(parseRelatedArtifact("relatedArtifact", reader, relatedArtifactElementIndex++));
                    break;
                case "library":
                    position = checkElementOrder("library", 37, position, true);
                    builder.library((Canonical) parseUri(Canonical.builder(), "library", reader, libraryElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 38, position, false);
                    builder.type((ResearchElementType) parseString(ResearchElementType.builder(), "type", reader, -1));
                    break;
                case "variableType":
                    position = checkElementOrder("variableType", 39, position, false);
                    builder.variableType((VariableType) parseString(VariableType.builder(), "variableType", reader, -1));
                    break;
                case "characteristic":
                    position = checkElementOrder("characteristic", 40, position, true);
                    builder.characteristic(parseResearchElementDefinitionCharacteristic("characteristic", reader, characteristicElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ResearchElementDefinition.Characteristic parseResearchElementDefinitionCharacteristic(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ResearchElementDefinition.Characteristic.Builder builder = ResearchElementDefinition.Characteristic.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, usageContextElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "definitionCodeableConcept":
                    position = checkElementOrder("definition[x]", 2, position, false);
                    builder.definition(parseCodeableConcept("definitionCodeableConcept", reader, -1));
                    break;
                case "definitionCanonical":
                    position = checkElementOrder("definition[x]", 2, position, false);
                    builder.definition((Canonical) parseUri(Canonical.builder(), "definitionCanonical", reader, -1));
                    break;
                case "definitionExpression":
                    position = checkElementOrder("definition[x]", 2, position, false);
                    builder.definition(parseExpression("definitionExpression", reader, -1));
                    break;
                case "definitionDataRequirement":
                    position = checkElementOrder("definition[x]", 2, position, false);
                    builder.definition(parseDataRequirement("definitionDataRequirement", reader, -1));
                    break;
                case "usageContext":
                    position = checkElementOrder("usageContext", 3, position, true);
                    builder.usageContext(parseUsageContext("usageContext", reader, usageContextElementIndex++));
                    break;
                case "exclude":
                    position = checkElementOrder("exclude", 4, position, false);
                    builder.exclude(parseBoolean("exclude", reader, -1));
                    break;
                case "unitOfMeasure":
                    position = checkElementOrder("unitOfMeasure", 5, position, false);
                    builder.unitOfMeasure(parseCodeableConcept("unitOfMeasure", reader, -1));
                    break;
                case "studyEffectiveDescription":
                    position = checkElementOrder("studyEffectiveDescription", 6, position, false);
                    builder.studyEffectiveDescription(parseString("studyEffectiveDescription", reader, -1));
                    break;
                case "studyEffectiveDateTime":
                    position = checkElementOrder("studyEffective[x]", 7, position, false);
                    builder.studyEffective(parseDateTime("studyEffectiveDateTime", reader, -1));
                    break;
                case "studyEffectivePeriod":
                    position = checkElementOrder("studyEffective[x]", 7, position, false);
                    builder.studyEffective(parsePeriod("studyEffectivePeriod", reader, -1));
                    break;
                case "studyEffectiveDuration":
                    position = checkElementOrder("studyEffective[x]", 7, position, false);
                    builder.studyEffective((Duration) parseQuantity(Duration.builder(), "studyEffectiveDuration", reader, -1));
                    break;
                case "studyEffectiveTiming":
                    position = checkElementOrder("studyEffective[x]", 7, position, false);
                    builder.studyEffective(parseTiming("studyEffectiveTiming", reader, -1));
                    break;
                case "studyEffectiveTimeFromStart":
                    position = checkElementOrder("studyEffectiveTimeFromStart", 8, position, false);
                    builder.studyEffectiveTimeFromStart((Duration) parseQuantity(Duration.builder(), "studyEffectiveTimeFromStart", reader, -1));
                    break;
                case "studyEffectiveGroupMeasure":
                    position = checkElementOrder("studyEffectiveGroupMeasure", 9, position, false);
                    builder.studyEffectiveGroupMeasure((GroupMeasure) parseString(GroupMeasure.builder(), "studyEffectiveGroupMeasure", reader, -1));
                    break;
                case "participantEffectiveDescription":
                    position = checkElementOrder("participantEffectiveDescription", 10, position, false);
                    builder.participantEffectiveDescription(parseString("participantEffectiveDescription", reader, -1));
                    break;
                case "participantEffectiveDateTime":
                    position = checkElementOrder("participantEffective[x]", 11, position, false);
                    builder.participantEffective(parseDateTime("participantEffectiveDateTime", reader, -1));
                    break;
                case "participantEffectivePeriod":
                    position = checkElementOrder("participantEffective[x]", 11, position, false);
                    builder.participantEffective(parsePeriod("participantEffectivePeriod", reader, -1));
                    break;
                case "participantEffectiveDuration":
                    position = checkElementOrder("participantEffective[x]", 11, position, false);
                    builder.participantEffective((Duration) parseQuantity(Duration.builder(), "participantEffectiveDuration", reader, -1));
                    break;
                case "participantEffectiveTiming":
                    position = checkElementOrder("participantEffective[x]", 11, position, false);
                    builder.participantEffective(parseTiming("participantEffectiveTiming", reader, -1));
                    break;
                case "participantEffectiveTimeFromStart":
                    position = checkElementOrder("participantEffectiveTimeFromStart", 12, position, false);
                    builder.participantEffectiveTimeFromStart((Duration) parseQuantity(Duration.builder(), "participantEffectiveTimeFromStart", reader, -1));
                    break;
                case "participantEffectiveGroupMeasure":
                    position = checkElementOrder("participantEffectiveGroupMeasure", 13, position, false);
                    builder.participantEffectiveGroupMeasure((GroupMeasure) parseString(GroupMeasure.builder(), "participantEffectiveGroupMeasure", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ResearchStudy parseResearchStudy(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ResearchStudy.Builder builder = ResearchStudy.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, protocolElementIndex = 0, partOfElementIndex = 0, categoryElementIndex = 0, focusElementIndex = 0, conditionElementIndex = 0, contactElementIndex = 0, relatedArtifactElementIndex = 0, keywordElementIndex = 0, locationElementIndex = 0, enrollmentElementIndex = 0, siteElementIndex = 0, noteElementIndex = 0, armElementIndex = 0, objectiveElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "title":
                    position = checkElementOrder("title", 9, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "protocol":
                    position = checkElementOrder("protocol", 10, position, true);
                    builder.protocol(parseReference("protocol", reader, protocolElementIndex++));
                    break;
                case "partOf":
                    position = checkElementOrder("partOf", 11, position, true);
                    builder.partOf(parseReference("partOf", reader, partOfElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 12, position, false);
                    builder.status((ResearchStudyStatus) parseString(ResearchStudyStatus.builder(), "status", reader, -1));
                    break;
                case "primaryPurposeType":
                    position = checkElementOrder("primaryPurposeType", 13, position, false);
                    builder.primaryPurposeType(parseCodeableConcept("primaryPurposeType", reader, -1));
                    break;
                case "phase":
                    position = checkElementOrder("phase", 14, position, false);
                    builder.phase(parseCodeableConcept("phase", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 15, position, true);
                    builder.category(parseCodeableConcept("category", reader, categoryElementIndex++));
                    break;
                case "focus":
                    position = checkElementOrder("focus", 16, position, true);
                    builder.focus(parseCodeableConcept("focus", reader, focusElementIndex++));
                    break;
                case "condition":
                    position = checkElementOrder("condition", 17, position, true);
                    builder.condition(parseCodeableConcept("condition", reader, conditionElementIndex++));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 18, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "relatedArtifact":
                    position = checkElementOrder("relatedArtifact", 19, position, true);
                    builder.relatedArtifact(parseRelatedArtifact("relatedArtifact", reader, relatedArtifactElementIndex++));
                    break;
                case "keyword":
                    position = checkElementOrder("keyword", 20, position, true);
                    builder.keyword(parseCodeableConcept("keyword", reader, keywordElementIndex++));
                    break;
                case "location":
                    position = checkElementOrder("location", 21, position, true);
                    builder.location(parseCodeableConcept("location", reader, locationElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 22, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "enrollment":
                    position = checkElementOrder("enrollment", 23, position, true);
                    builder.enrollment(parseReference("enrollment", reader, enrollmentElementIndex++));
                    break;
                case "period":
                    position = checkElementOrder("period", 24, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                case "sponsor":
                    position = checkElementOrder("sponsor", 25, position, false);
                    builder.sponsor(parseReference("sponsor", reader, -1));
                    break;
                case "principalInvestigator":
                    position = checkElementOrder("principalInvestigator", 26, position, false);
                    builder.principalInvestigator(parseReference("principalInvestigator", reader, -1));
                    break;
                case "site":
                    position = checkElementOrder("site", 27, position, true);
                    builder.site(parseReference("site", reader, siteElementIndex++));
                    break;
                case "reasonStopped":
                    position = checkElementOrder("reasonStopped", 28, position, false);
                    builder.reasonStopped(parseCodeableConcept("reasonStopped", reader, -1));
                    break;
                case "note":
                    position = checkElementOrder("note", 29, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "arm":
                    position = checkElementOrder("arm", 30, position, true);
                    builder.arm(parseResearchStudyArm("arm", reader, armElementIndex++));
                    break;
                case "objective":
                    position = checkElementOrder("objective", 31, position, true);
                    builder.objective(parseResearchStudyObjective("objective", reader, objectiveElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ResearchStudy.Arm parseResearchStudyArm(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ResearchStudy.Arm.Builder builder = ResearchStudy.Arm.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 4, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ResearchStudy.Objective parseResearchStudyObjective(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ResearchStudy.Objective.Builder builder = ResearchStudy.Objective.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ResearchSubject parseResearchSubject(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ResearchSubject.Builder builder = ResearchSubject.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((ResearchSubjectStatus) parseString(ResearchSubjectStatus.builder(), "status", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 10, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                case "study":
                    position = checkElementOrder("study", 11, position, false);
                    builder.study(parseReference("study", reader, -1));
                    break;
                case "individual":
                    position = checkElementOrder("individual", 12, position, false);
                    builder.individual(parseReference("individual", reader, -1));
                    break;
                case "assignedArm":
                    position = checkElementOrder("assignedArm", 13, position, false);
                    builder.assignedArm(parseString("assignedArm", reader, -1));
                    break;
                case "actualArm":
                    position = checkElementOrder("actualArm", 14, position, false);
                    builder.actualArm(parseString("actualArm", reader, -1));
                    break;
                case "consent":
                    position = checkElementOrder("consent", 15, position, false);
                    builder.consent(parseReference("consent", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private RiskAssessment parseRiskAssessment(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        RiskAssessment.Builder builder = RiskAssessment.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, reasonCodeElementIndex = 0, reasonReferenceElementIndex = 0, basisElementIndex = 0, predictionElementIndex = 0, noteElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "basedOn":
                    position = checkElementOrder("basedOn", 9, position, false);
                    builder.basedOn(parseReference("basedOn", reader, -1));
                    break;
                case "parent":
                    position = checkElementOrder("parent", 10, position, false);
                    builder.parent(parseReference("parent", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 11, position, false);
                    builder.status((RiskAssessmentStatus) parseString(RiskAssessmentStatus.builder(), "status", reader, -1));
                    break;
                case "method":
                    position = checkElementOrder("method", 12, position, false);
                    builder.method(parseCodeableConcept("method", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 13, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 14, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 15, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "occurrenceDateTime":
                    position = checkElementOrder("occurrence[x]", 16, position, false);
                    builder.occurrence(parseDateTime("occurrenceDateTime", reader, -1));
                    break;
                case "occurrencePeriod":
                    position = checkElementOrder("occurrence[x]", 16, position, false);
                    builder.occurrence(parsePeriod("occurrencePeriod", reader, -1));
                    break;
                case "condition":
                    position = checkElementOrder("condition", 17, position, false);
                    builder.condition(parseReference("condition", reader, -1));
                    break;
                case "performer":
                    position = checkElementOrder("performer", 18, position, false);
                    builder.performer(parseReference("performer", reader, -1));
                    break;
                case "reasonCode":
                    position = checkElementOrder("reasonCode", 19, position, true);
                    builder.reasonCode(parseCodeableConcept("reasonCode", reader, reasonCodeElementIndex++));
                    break;
                case "reasonReference":
                    position = checkElementOrder("reasonReference", 20, position, true);
                    builder.reasonReference(parseReference("reasonReference", reader, reasonReferenceElementIndex++));
                    break;
                case "basis":
                    position = checkElementOrder("basis", 21, position, true);
                    builder.basis(parseReference("basis", reader, basisElementIndex++));
                    break;
                case "prediction":
                    position = checkElementOrder("prediction", 22, position, true);
                    builder.prediction(parseRiskAssessmentPrediction("prediction", reader, predictionElementIndex++));
                    break;
                case "mitigation":
                    position = checkElementOrder("mitigation", 23, position, false);
                    builder.mitigation(parseString("mitigation", reader, -1));
                    break;
                case "note":
                    position = checkElementOrder("note", 24, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private RiskAssessment.Prediction parseRiskAssessmentPrediction(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        RiskAssessment.Prediction.Builder builder = RiskAssessment.Prediction.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "outcome":
                    position = checkElementOrder("outcome", 2, position, false);
                    builder.outcome(parseCodeableConcept("outcome", reader, -1));
                    break;
                case "probabilityDecimal":
                    position = checkElementOrder("probability[x]", 3, position, false);
                    builder.probability(parseDecimal("probabilityDecimal", reader, -1));
                    break;
                case "probabilityRange":
                    position = checkElementOrder("probability[x]", 3, position, false);
                    builder.probability(parseRange("probabilityRange", reader, -1));
                    break;
                case "qualitativeRisk":
                    position = checkElementOrder("qualitativeRisk", 4, position, false);
                    builder.qualitativeRisk(parseCodeableConcept("qualitativeRisk", reader, -1));
                    break;
                case "relativeRisk":
                    position = checkElementOrder("relativeRisk", 5, position, false);
                    builder.relativeRisk(parseDecimal("relativeRisk", reader, -1));
                    break;
                case "whenPeriod":
                    position = checkElementOrder("when[x]", 6, position, false);
                    builder.when(parsePeriod("whenPeriod", reader, -1));
                    break;
                case "whenRange":
                    position = checkElementOrder("when[x]", 6, position, false);
                    builder.when(parseRange("whenRange", reader, -1));
                    break;
                case "rationale":
                    position = checkElementOrder("rationale", 7, position, false);
                    builder.rationale(parseString("rationale", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SampledData parseSampledData(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SampledData.Builder builder = SampledData.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "origin":
                    position = checkElementOrder("origin", 1, position, false);
                    builder.origin((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "origin", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 2, position, false);
                    builder.period(parseDecimal("period", reader, -1));
                    break;
                case "factor":
                    position = checkElementOrder("factor", 3, position, false);
                    builder.factor(parseDecimal("factor", reader, -1));
                    break;
                case "lowerLimit":
                    position = checkElementOrder("lowerLimit", 4, position, false);
                    builder.lowerLimit(parseDecimal("lowerLimit", reader, -1));
                    break;
                case "upperLimit":
                    position = checkElementOrder("upperLimit", 5, position, false);
                    builder.upperLimit(parseDecimal("upperLimit", reader, -1));
                    break;
                case "dimensions":
                    position = checkElementOrder("dimensions", 6, position, false);
                    builder.dimensions((PositiveInt) parseInteger(PositiveInt.builder(), "dimensions", reader, -1));
                    break;
                case "data":
                    position = checkElementOrder("data", 7, position, false);
                    builder.data(parseString("data", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Schedule parseSchedule(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Schedule.Builder builder = Schedule.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, serviceCategoryElementIndex = 0, serviceTypeElementIndex = 0, specialtyElementIndex = 0, actorElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "active":
                    position = checkElementOrder("active", 9, position, false);
                    builder.active(parseBoolean("active", reader, -1));
                    break;
                case "serviceCategory":
                    position = checkElementOrder("serviceCategory", 10, position, true);
                    builder.serviceCategory(parseCodeableConcept("serviceCategory", reader, serviceCategoryElementIndex++));
                    break;
                case "serviceType":
                    position = checkElementOrder("serviceType", 11, position, true);
                    builder.serviceType(parseCodeableConcept("serviceType", reader, serviceTypeElementIndex++));
                    break;
                case "specialty":
                    position = checkElementOrder("specialty", 12, position, true);
                    builder.specialty(parseCodeableConcept("specialty", reader, specialtyElementIndex++));
                    break;
                case "actor":
                    position = checkElementOrder("actor", 13, position, true);
                    builder.actor(parseReference("actor", reader, actorElementIndex++));
                    break;
                case "planningHorizon":
                    position = checkElementOrder("planningHorizon", 14, position, false);
                    builder.planningHorizon(parsePeriod("planningHorizon", reader, -1));
                    break;
                case "comment":
                    position = checkElementOrder("comment", 15, position, false);
                    builder.comment(parseString("comment", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SearchParameter parseSearchParameter(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SearchParameter.Builder builder = SearchParameter.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, contactElementIndex = 0, useContextElementIndex = 0, jurisdictionElementIndex = 0, baseElementIndex = 0, targetElementIndex = 0, comparatorElementIndex = 0, modifierElementIndex = 0, chainElementIndex = 0, componentElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "version":
                    position = checkElementOrder("version", 9, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 10, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "derivedFrom":
                    position = checkElementOrder("derivedFrom", 11, position, false);
                    builder.derivedFrom((Canonical) parseUri(Canonical.builder(), "derivedFrom", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 12, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 13, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 14, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 15, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 16, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 17, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 18, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 19, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 20, position, false);
                    builder.purpose((Markdown) parseString(Markdown.builder(), "purpose", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 21, position, false);
                    builder.code((Code) parseString(Code.builder(), "code", reader, -1));
                    break;
                case "base":
                    position = checkElementOrder("base", 22, position, true);
                    builder.base((ResourceTypeCode) parseString(ResourceTypeCode.builder(), "base", reader, baseElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 23, position, false);
                    builder.type((SearchParamType) parseString(SearchParamType.builder(), "type", reader, -1));
                    break;
                case "expression":
                    position = checkElementOrder("expression", 24, position, false);
                    builder.expression(parseString("expression", reader, -1));
                    break;
                case "xpath":
                    position = checkElementOrder("xpath", 25, position, false);
                    builder.xpath(parseString("xpath", reader, -1));
                    break;
                case "xpathUsage":
                    position = checkElementOrder("xpathUsage", 26, position, false);
                    builder.xpathUsage((XPathUsageType) parseString(XPathUsageType.builder(), "xpathUsage", reader, -1));
                    break;
                case "target":
                    position = checkElementOrder("target", 27, position, true);
                    builder.target((ResourceTypeCode) parseString(ResourceTypeCode.builder(), "target", reader, targetElementIndex++));
                    break;
                case "multipleOr":
                    position = checkElementOrder("multipleOr", 28, position, false);
                    builder.multipleOr(parseBoolean("multipleOr", reader, -1));
                    break;
                case "multipleAnd":
                    position = checkElementOrder("multipleAnd", 29, position, false);
                    builder.multipleAnd(parseBoolean("multipleAnd", reader, -1));
                    break;
                case "comparator":
                    position = checkElementOrder("comparator", 30, position, true);
                    builder.comparator((SearchComparator) parseString(SearchComparator.builder(), "comparator", reader, comparatorElementIndex++));
                    break;
                case "modifier":
                    position = checkElementOrder("modifier", 31, position, true);
                    builder.modifier((SearchModifierCode) parseString(SearchModifierCode.builder(), "modifier", reader, modifierElementIndex++));
                    break;
                case "chain":
                    position = checkElementOrder("chain", 32, position, true);
                    builder.chain(parseString("chain", reader, chainElementIndex++));
                    break;
                case "component":
                    position = checkElementOrder("component", 33, position, true);
                    builder.component(parseSearchParameterComponent("component", reader, componentElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SearchParameter.Component parseSearchParameterComponent(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SearchParameter.Component.Builder builder = SearchParameter.Component.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "definition":
                    position = checkElementOrder("definition", 2, position, false);
                    builder.definition((Canonical) parseUri(Canonical.builder(), "definition", reader, -1));
                    break;
                case "expression":
                    position = checkElementOrder("expression", 3, position, false);
                    builder.expression(parseString("expression", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ServiceRequest parseServiceRequest(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ServiceRequest.Builder builder = ServiceRequest.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, instantiatesCanonicalElementIndex = 0, instantiatesUriElementIndex = 0, basedOnElementIndex = 0, replacesElementIndex = 0, categoryElementIndex = 0, orderDetailElementIndex = 0, performerElementIndex = 0, locationCodeElementIndex = 0, locationReferenceElementIndex = 0, reasonCodeElementIndex = 0, reasonReferenceElementIndex = 0, insuranceElementIndex = 0, supportingInfoElementIndex = 0, specimenElementIndex = 0, bodySiteElementIndex = 0, noteElementIndex = 0, relevantHistoryElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "instantiatesCanonical":
                    position = checkElementOrder("instantiatesCanonical", 9, position, true);
                    builder.instantiatesCanonical((Canonical) parseUri(Canonical.builder(), "instantiatesCanonical", reader, instantiatesCanonicalElementIndex++));
                    break;
                case "instantiatesUri":
                    position = checkElementOrder("instantiatesUri", 10, position, true);
                    builder.instantiatesUri(parseUri("instantiatesUri", reader, instantiatesUriElementIndex++));
                    break;
                case "basedOn":
                    position = checkElementOrder("basedOn", 11, position, true);
                    builder.basedOn(parseReference("basedOn", reader, basedOnElementIndex++));
                    break;
                case "replaces":
                    position = checkElementOrder("replaces", 12, position, true);
                    builder.replaces(parseReference("replaces", reader, replacesElementIndex++));
                    break;
                case "requisition":
                    position = checkElementOrder("requisition", 13, position, false);
                    builder.requisition(parseIdentifier("requisition", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 14, position, false);
                    builder.status((ServiceRequestStatus) parseString(ServiceRequestStatus.builder(), "status", reader, -1));
                    break;
                case "intent":
                    position = checkElementOrder("intent", 15, position, false);
                    builder.intent((ServiceRequestIntent) parseString(ServiceRequestIntent.builder(), "intent", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 16, position, true);
                    builder.category(parseCodeableConcept("category", reader, categoryElementIndex++));
                    break;
                case "priority":
                    position = checkElementOrder("priority", 17, position, false);
                    builder.priority((ServiceRequestPriority) parseString(ServiceRequestPriority.builder(), "priority", reader, -1));
                    break;
                case "doNotPerform":
                    position = checkElementOrder("doNotPerform", 18, position, false);
                    builder.doNotPerform(parseBoolean("doNotPerform", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 19, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "orderDetail":
                    position = checkElementOrder("orderDetail", 20, position, true);
                    builder.orderDetail(parseCodeableConcept("orderDetail", reader, orderDetailElementIndex++));
                    break;
                case "quantityQuantity":
                    position = checkElementOrder("quantity[x]", 21, position, false);
                    builder.quantity(parseQuantity("quantityQuantity", reader, -1));
                    break;
                case "quantityRatio":
                    position = checkElementOrder("quantity[x]", 21, position, false);
                    builder.quantity(parseRatio("quantityRatio", reader, -1));
                    break;
                case "quantityRange":
                    position = checkElementOrder("quantity[x]", 21, position, false);
                    builder.quantity(parseRange("quantityRange", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 22, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 23, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "occurrenceDateTime":
                    position = checkElementOrder("occurrence[x]", 24, position, false);
                    builder.occurrence(parseDateTime("occurrenceDateTime", reader, -1));
                    break;
                case "occurrencePeriod":
                    position = checkElementOrder("occurrence[x]", 24, position, false);
                    builder.occurrence(parsePeriod("occurrencePeriod", reader, -1));
                    break;
                case "occurrenceTiming":
                    position = checkElementOrder("occurrence[x]", 24, position, false);
                    builder.occurrence(parseTiming("occurrenceTiming", reader, -1));
                    break;
                case "asNeededBoolean":
                    position = checkElementOrder("asNeeded[x]", 25, position, false);
                    builder.asNeeded(parseBoolean("asNeededBoolean", reader, -1));
                    break;
                case "asNeededCodeableConcept":
                    position = checkElementOrder("asNeeded[x]", 25, position, false);
                    builder.asNeeded(parseCodeableConcept("asNeededCodeableConcept", reader, -1));
                    break;
                case "authoredOn":
                    position = checkElementOrder("authoredOn", 26, position, false);
                    builder.authoredOn(parseDateTime("authoredOn", reader, -1));
                    break;
                case "requester":
                    position = checkElementOrder("requester", 27, position, false);
                    builder.requester(parseReference("requester", reader, -1));
                    break;
                case "performerType":
                    position = checkElementOrder("performerType", 28, position, false);
                    builder.performerType(parseCodeableConcept("performerType", reader, -1));
                    break;
                case "performer":
                    position = checkElementOrder("performer", 29, position, true);
                    builder.performer(parseReference("performer", reader, performerElementIndex++));
                    break;
                case "locationCode":
                    position = checkElementOrder("locationCode", 30, position, true);
                    builder.locationCode(parseCodeableConcept("locationCode", reader, locationCodeElementIndex++));
                    break;
                case "locationReference":
                    position = checkElementOrder("locationReference", 31, position, true);
                    builder.locationReference(parseReference("locationReference", reader, locationReferenceElementIndex++));
                    break;
                case "reasonCode":
                    position = checkElementOrder("reasonCode", 32, position, true);
                    builder.reasonCode(parseCodeableConcept("reasonCode", reader, reasonCodeElementIndex++));
                    break;
                case "reasonReference":
                    position = checkElementOrder("reasonReference", 33, position, true);
                    builder.reasonReference(parseReference("reasonReference", reader, reasonReferenceElementIndex++));
                    break;
                case "insurance":
                    position = checkElementOrder("insurance", 34, position, true);
                    builder.insurance(parseReference("insurance", reader, insuranceElementIndex++));
                    break;
                case "supportingInfo":
                    position = checkElementOrder("supportingInfo", 35, position, true);
                    builder.supportingInfo(parseReference("supportingInfo", reader, supportingInfoElementIndex++));
                    break;
                case "specimen":
                    position = checkElementOrder("specimen", 36, position, true);
                    builder.specimen(parseReference("specimen", reader, specimenElementIndex++));
                    break;
                case "bodySite":
                    position = checkElementOrder("bodySite", 37, position, true);
                    builder.bodySite(parseCodeableConcept("bodySite", reader, bodySiteElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 38, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "patientInstruction":
                    position = checkElementOrder("patientInstruction", 39, position, false);
                    builder.patientInstruction(parseString("patientInstruction", reader, -1));
                    break;
                case "relevantHistory":
                    position = checkElementOrder("relevantHistory", 40, position, true);
                    builder.relevantHistory(parseReference("relevantHistory", reader, relevantHistoryElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Signature parseSignature(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Signature.Builder builder = Signature.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, typeElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 1, position, true);
                    builder.type(parseCoding("type", reader, typeElementIndex++));
                    break;
                case "when":
                    position = checkElementOrder("when", 2, position, false);
                    builder.when(parseInstant("when", reader, -1));
                    break;
                case "who":
                    position = checkElementOrder("who", 3, position, false);
                    builder.who(parseReference("who", reader, -1));
                    break;
                case "onBehalfOf":
                    position = checkElementOrder("onBehalfOf", 4, position, false);
                    builder.onBehalfOf(parseReference("onBehalfOf", reader, -1));
                    break;
                case "targetFormat":
                    position = checkElementOrder("targetFormat", 5, position, false);
                    builder.targetFormat((Code) parseString(Code.builder(), "targetFormat", reader, -1));
                    break;
                case "sigFormat":
                    position = checkElementOrder("sigFormat", 6, position, false);
                    builder.sigFormat((Code) parseString(Code.builder(), "sigFormat", reader, -1));
                    break;
                case "data":
                    position = checkElementOrder("data", 7, position, false);
                    builder.data(parseBase64Binary("data", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Slot parseSlot(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Slot.Builder builder = Slot.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, serviceCategoryElementIndex = 0, serviceTypeElementIndex = 0, specialtyElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "serviceCategory":
                    position = checkElementOrder("serviceCategory", 9, position, true);
                    builder.serviceCategory(parseCodeableConcept("serviceCategory", reader, serviceCategoryElementIndex++));
                    break;
                case "serviceType":
                    position = checkElementOrder("serviceType", 10, position, true);
                    builder.serviceType(parseCodeableConcept("serviceType", reader, serviceTypeElementIndex++));
                    break;
                case "specialty":
                    position = checkElementOrder("specialty", 11, position, true);
                    builder.specialty(parseCodeableConcept("specialty", reader, specialtyElementIndex++));
                    break;
                case "appointmentType":
                    position = checkElementOrder("appointmentType", 12, position, false);
                    builder.appointmentType(parseCodeableConcept("appointmentType", reader, -1));
                    break;
                case "schedule":
                    position = checkElementOrder("schedule", 13, position, false);
                    builder.schedule(parseReference("schedule", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 14, position, false);
                    builder.status((SlotStatus) parseString(SlotStatus.builder(), "status", reader, -1));
                    break;
                case "start":
                    position = checkElementOrder("start", 15, position, false);
                    builder.start(parseInstant("start", reader, -1));
                    break;
                case "end":
                    position = checkElementOrder("end", 16, position, false);
                    builder.end(parseInstant("end", reader, -1));
                    break;
                case "overbooked":
                    position = checkElementOrder("overbooked", 17, position, false);
                    builder.overbooked(parseBoolean("overbooked", reader, -1));
                    break;
                case "comment":
                    position = checkElementOrder("comment", 18, position, false);
                    builder.comment(parseString("comment", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Specimen parseSpecimen(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Specimen.Builder builder = Specimen.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, parentElementIndex = 0, requestElementIndex = 0, processingElementIndex = 0, containerElementIndex = 0, conditionElementIndex = 0, noteElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "accessionIdentifier":
                    position = checkElementOrder("accessionIdentifier", 9, position, false);
                    builder.accessionIdentifier(parseIdentifier("accessionIdentifier", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 10, position, false);
                    builder.status((SpecimenStatus) parseString(SpecimenStatus.builder(), "status", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 11, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "subject":
                    position = checkElementOrder("subject", 12, position, false);
                    builder.subject(parseReference("subject", reader, -1));
                    break;
                case "receivedTime":
                    position = checkElementOrder("receivedTime", 13, position, false);
                    builder.receivedTime(parseDateTime("receivedTime", reader, -1));
                    break;
                case "parent":
                    position = checkElementOrder("parent", 14, position, true);
                    builder.parent(parseReference("parent", reader, parentElementIndex++));
                    break;
                case "request":
                    position = checkElementOrder("request", 15, position, true);
                    builder.request(parseReference("request", reader, requestElementIndex++));
                    break;
                case "collection":
                    position = checkElementOrder("collection", 16, position, false);
                    builder.collection(parseSpecimenCollection("collection", reader, -1));
                    break;
                case "processing":
                    position = checkElementOrder("processing", 17, position, true);
                    builder.processing(parseSpecimenProcessing("processing", reader, processingElementIndex++));
                    break;
                case "container":
                    position = checkElementOrder("container", 18, position, true);
                    builder.container(parseSpecimenContainer("container", reader, containerElementIndex++));
                    break;
                case "condition":
                    position = checkElementOrder("condition", 19, position, true);
                    builder.condition(parseCodeableConcept("condition", reader, conditionElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 20, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Specimen.Collection parseSpecimenCollection(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Specimen.Collection.Builder builder = Specimen.Collection.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "collector":
                    position = checkElementOrder("collector", 2, position, false);
                    builder.collector(parseReference("collector", reader, -1));
                    break;
                case "collectedDateTime":
                    position = checkElementOrder("collected[x]", 3, position, false);
                    builder.collected(parseDateTime("collectedDateTime", reader, -1));
                    break;
                case "collectedPeriod":
                    position = checkElementOrder("collected[x]", 3, position, false);
                    builder.collected(parsePeriod("collectedPeriod", reader, -1));
                    break;
                case "duration":
                    position = checkElementOrder("duration", 4, position, false);
                    builder.duration((Duration) parseQuantity(Duration.builder(), "duration", reader, -1));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 5, position, false);
                    builder.quantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "quantity", reader, -1));
                    break;
                case "method":
                    position = checkElementOrder("method", 6, position, false);
                    builder.method(parseCodeableConcept("method", reader, -1));
                    break;
                case "bodySite":
                    position = checkElementOrder("bodySite", 7, position, false);
                    builder.bodySite(parseCodeableConcept("bodySite", reader, -1));
                    break;
                case "fastingStatusCodeableConcept":
                    position = checkElementOrder("fastingStatus[x]", 8, position, false);
                    builder.fastingStatus(parseCodeableConcept("fastingStatusCodeableConcept", reader, -1));
                    break;
                case "fastingStatusDuration":
                    position = checkElementOrder("fastingStatus[x]", 8, position, false);
                    builder.fastingStatus((Duration) parseQuantity(Duration.builder(), "fastingStatusDuration", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Specimen.Container parseSpecimenContainer(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Specimen.Container.Builder builder = Specimen.Container.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 2, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 3, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 4, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "capacity":
                    position = checkElementOrder("capacity", 5, position, false);
                    builder.capacity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "capacity", reader, -1));
                    break;
                case "specimenQuantity":
                    position = checkElementOrder("specimenQuantity", 6, position, false);
                    builder.specimenQuantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "specimenQuantity", reader, -1));
                    break;
                case "additiveCodeableConcept":
                    position = checkElementOrder("additive[x]", 7, position, false);
                    builder.additive(parseCodeableConcept("additiveCodeableConcept", reader, -1));
                    break;
                case "additiveReference":
                    position = checkElementOrder("additive[x]", 7, position, false);
                    builder.additive(parseReference("additiveReference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Specimen.Processing parseSpecimenProcessing(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Specimen.Processing.Builder builder = Specimen.Processing.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, additiveElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 2, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "procedure":
                    position = checkElementOrder("procedure", 3, position, false);
                    builder.procedure(parseCodeableConcept("procedure", reader, -1));
                    break;
                case "additive":
                    position = checkElementOrder("additive", 4, position, true);
                    builder.additive(parseReference("additive", reader, additiveElementIndex++));
                    break;
                case "timeDateTime":
                    position = checkElementOrder("time[x]", 5, position, false);
                    builder.time(parseDateTime("timeDateTime", reader, -1));
                    break;
                case "timePeriod":
                    position = checkElementOrder("time[x]", 5, position, false);
                    builder.time(parsePeriod("timePeriod", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SpecimenDefinition parseSpecimenDefinition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SpecimenDefinition.Builder builder = SpecimenDefinition.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, patientPreparationElementIndex = 0, collectionElementIndex = 0, typeTestedElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, false);
                    builder.identifier(parseIdentifier("identifier", reader, -1));
                    break;
                case "typeCollected":
                    position = checkElementOrder("typeCollected", 9, position, false);
                    builder.typeCollected(parseCodeableConcept("typeCollected", reader, -1));
                    break;
                case "patientPreparation":
                    position = checkElementOrder("patientPreparation", 10, position, true);
                    builder.patientPreparation(parseCodeableConcept("patientPreparation", reader, patientPreparationElementIndex++));
                    break;
                case "timeAspect":
                    position = checkElementOrder("timeAspect", 11, position, false);
                    builder.timeAspect(parseString("timeAspect", reader, -1));
                    break;
                case "collection":
                    position = checkElementOrder("collection", 12, position, true);
                    builder.collection(parseCodeableConcept("collection", reader, collectionElementIndex++));
                    break;
                case "typeTested":
                    position = checkElementOrder("typeTested", 13, position, true);
                    builder.typeTested(parseSpecimenDefinitionTypeTested("typeTested", reader, typeTestedElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SpecimenDefinition.TypeTested parseSpecimenDefinitionTypeTested(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SpecimenDefinition.TypeTested.Builder builder = SpecimenDefinition.TypeTested.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, rejectionCriterionElementIndex = 0, handlingElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "isDerived":
                    position = checkElementOrder("isDerived", 2, position, false);
                    builder.isDerived(parseBoolean("isDerived", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "preference":
                    position = checkElementOrder("preference", 4, position, false);
                    builder.preference((SpecimenContainedPreference) parseString(SpecimenContainedPreference.builder(), "preference", reader, -1));
                    break;
                case "container":
                    position = checkElementOrder("container", 5, position, false);
                    builder.container(parseSpecimenDefinitionTypeTestedContainer("container", reader, -1));
                    break;
                case "requirement":
                    position = checkElementOrder("requirement", 6, position, false);
                    builder.requirement(parseString("requirement", reader, -1));
                    break;
                case "retentionTime":
                    position = checkElementOrder("retentionTime", 7, position, false);
                    builder.retentionTime((Duration) parseQuantity(Duration.builder(), "retentionTime", reader, -1));
                    break;
                case "rejectionCriterion":
                    position = checkElementOrder("rejectionCriterion", 8, position, true);
                    builder.rejectionCriterion(parseCodeableConcept("rejectionCriterion", reader, rejectionCriterionElementIndex++));
                    break;
                case "handling":
                    position = checkElementOrder("handling", 9, position, true);
                    builder.handling(parseSpecimenDefinitionTypeTestedHandling("handling", reader, handlingElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SpecimenDefinition.TypeTested.Container parseSpecimenDefinitionTypeTestedContainer(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SpecimenDefinition.TypeTested.Container.Builder builder = SpecimenDefinition.TypeTested.Container.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, additiveElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "material":
                    position = checkElementOrder("material", 2, position, false);
                    builder.material(parseCodeableConcept("material", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "cap":
                    position = checkElementOrder("cap", 4, position, false);
                    builder.cap(parseCodeableConcept("cap", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 5, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "capacity":
                    position = checkElementOrder("capacity", 6, position, false);
                    builder.capacity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "capacity", reader, -1));
                    break;
                case "minimumVolumeQuantity":
                    position = checkElementOrder("minimumVolume[x]", 7, position, false);
                    builder.minimumVolume((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "minimumVolumeQuantity", reader, -1));
                    break;
                case "minimumVolumeString":
                    position = checkElementOrder("minimumVolume[x]", 7, position, false);
                    builder.minimumVolume(parseString("minimumVolumeString", reader, -1));
                    break;
                case "additive":
                    position = checkElementOrder("additive", 8, position, true);
                    builder.additive(parseSpecimenDefinitionTypeTestedContainerAdditive("additive", reader, additiveElementIndex++));
                    break;
                case "preparation":
                    position = checkElementOrder("preparation", 9, position, false);
                    builder.preparation(parseString("preparation", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SpecimenDefinition.TypeTested.Container.Additive parseSpecimenDefinitionTypeTestedContainerAdditive(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SpecimenDefinition.TypeTested.Container.Additive.Builder builder = SpecimenDefinition.TypeTested.Container.Additive.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "additiveCodeableConcept":
                    position = checkElementOrder("additive[x]", 2, position, false);
                    builder.additive(parseCodeableConcept("additiveCodeableConcept", reader, -1));
                    break;
                case "additiveReference":
                    position = checkElementOrder("additive[x]", 2, position, false);
                    builder.additive(parseReference("additiveReference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SpecimenDefinition.TypeTested.Handling parseSpecimenDefinitionTypeTestedHandling(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SpecimenDefinition.TypeTested.Handling.Builder builder = SpecimenDefinition.TypeTested.Handling.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "temperatureQualifier":
                    position = checkElementOrder("temperatureQualifier", 2, position, false);
                    builder.temperatureQualifier(parseCodeableConcept("temperatureQualifier", reader, -1));
                    break;
                case "temperatureRange":
                    position = checkElementOrder("temperatureRange", 3, position, false);
                    builder.temperatureRange(parseRange("temperatureRange", reader, -1));
                    break;
                case "maxDuration":
                    position = checkElementOrder("maxDuration", 4, position, false);
                    builder.maxDuration((Duration) parseQuantity(Duration.builder(), "maxDuration", reader, -1));
                    break;
                case "instruction":
                    position = checkElementOrder("instruction", 5, position, false);
                    builder.instruction(parseString("instruction", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private String parseString(String.Builder builder, java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        java.lang.String value = reader.getAttributeValue(null, "value");
        if (value != null) {
            builder.value(value);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private String parseString(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        return parseString(String.builder(), elementName, reader, elementIndex);
    }

    private StructureDefinition parseStructureDefinition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        StructureDefinition.Builder builder = StructureDefinition.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, contactElementIndex = 0, useContextElementIndex = 0, jurisdictionElementIndex = 0, keywordElementIndex = 0, mappingElementIndex = 0, contextElementIndex = 0, contextInvariantElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 10, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 11, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 12, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 13, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 14, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 15, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 16, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 17, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 18, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 19, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 20, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 21, position, false);
                    builder.purpose((Markdown) parseString(Markdown.builder(), "purpose", reader, -1));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 22, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                case "keyword":
                    position = checkElementOrder("keyword", 23, position, true);
                    builder.keyword(parseCoding("keyword", reader, keywordElementIndex++));
                    break;
                case "fhirVersion":
                    position = checkElementOrder("fhirVersion", 24, position, false);
                    builder.fhirVersion((FHIRVersion) parseString(FHIRVersion.builder(), "fhirVersion", reader, -1));
                    break;
                case "mapping":
                    position = checkElementOrder("mapping", 25, position, true);
                    builder.mapping(parseStructureDefinitionMapping("mapping", reader, mappingElementIndex++));
                    break;
                case "kind":
                    position = checkElementOrder("kind", 26, position, false);
                    builder.kind((StructureDefinitionKind) parseString(StructureDefinitionKind.builder(), "kind", reader, -1));
                    break;
                case "abstract":
                    position = checkElementOrder("abstract", 27, position, false);
                    builder._abstract(parseBoolean("abstract", reader, -1));
                    break;
                case "context":
                    position = checkElementOrder("context", 28, position, true);
                    builder.context(parseStructureDefinitionContext("context", reader, contextElementIndex++));
                    break;
                case "contextInvariant":
                    position = checkElementOrder("contextInvariant", 29, position, true);
                    builder.contextInvariant(parseString("contextInvariant", reader, contextInvariantElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 30, position, false);
                    builder.type(parseUri("type", reader, -1));
                    break;
                case "baseDefinition":
                    position = checkElementOrder("baseDefinition", 31, position, false);
                    builder.baseDefinition((Canonical) parseUri(Canonical.builder(), "baseDefinition", reader, -1));
                    break;
                case "derivation":
                    position = checkElementOrder("derivation", 32, position, false);
                    builder.derivation((TypeDerivationRule) parseString(TypeDerivationRule.builder(), "derivation", reader, -1));
                    break;
                case "snapshot":
                    position = checkElementOrder("snapshot", 33, position, false);
                    builder.snapshot(parseStructureDefinitionSnapshot("snapshot", reader, -1));
                    break;
                case "differential":
                    position = checkElementOrder("differential", 34, position, false);
                    builder.differential(parseStructureDefinitionDifferential("differential", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private StructureDefinition.Context parseStructureDefinitionContext(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        StructureDefinition.Context.Builder builder = StructureDefinition.Context.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type((ExtensionContextType) parseString(ExtensionContextType.builder(), "type", reader, -1));
                    break;
                case "expression":
                    position = checkElementOrder("expression", 3, position, false);
                    builder.expression(parseString("expression", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private StructureDefinition.Differential parseStructureDefinitionDifferential(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        StructureDefinition.Differential.Builder builder = StructureDefinition.Differential.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, elementElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "element":
                    position = checkElementOrder("element", 2, position, true);
                    builder.element(parseElementDefinition("element", reader, elementElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private StructureDefinition.Mapping parseStructureDefinitionMapping(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        StructureDefinition.Mapping.Builder builder = StructureDefinition.Mapping.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identity":
                    position = checkElementOrder("identity", 2, position, false);
                    builder.identity((Id) parseString(Id.builder(), "identity", reader, -1));
                    break;
                case "uri":
                    position = checkElementOrder("uri", 3, position, false);
                    builder.uri(parseUri("uri", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 4, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "comment":
                    position = checkElementOrder("comment", 5, position, false);
                    builder.comment(parseString("comment", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private StructureDefinition.Snapshot parseStructureDefinitionSnapshot(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        StructureDefinition.Snapshot.Builder builder = StructureDefinition.Snapshot.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, elementElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "element":
                    position = checkElementOrder("element", 2, position, true);
                    builder.element(parseElementDefinition("element", reader, elementElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private StructureMap parseStructureMap(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        StructureMap.Builder builder = StructureMap.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, contactElementIndex = 0, useContextElementIndex = 0, jurisdictionElementIndex = 0, structureElementIndex = 0, importElementIndex = 0, groupElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 10, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 11, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 12, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 13, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 14, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 15, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 16, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 17, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 18, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 19, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 20, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 21, position, false);
                    builder.purpose((Markdown) parseString(Markdown.builder(), "purpose", reader, -1));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 22, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                case "structure":
                    position = checkElementOrder("structure", 23, position, true);
                    builder.structure(parseStructureMapStructure("structure", reader, structureElementIndex++));
                    break;
                case "import":
                    position = checkElementOrder("import", 24, position, true);
                    builder._import((Canonical) parseUri(Canonical.builder(), "import", reader, importElementIndex++));
                    break;
                case "group":
                    position = checkElementOrder("group", 25, position, true);
                    builder.group(parseStructureMapGroup("group", reader, groupElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private StructureMap.Group parseStructureMapGroup(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        StructureMap.Group.Builder builder = StructureMap.Group.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, inputElementIndex = 0, ruleElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name((Id) parseString(Id.builder(), "name", reader, -1));
                    break;
                case "extends":
                    position = checkElementOrder("extends", 3, position, false);
                    builder._extends((Id) parseString(Id.builder(), "extends", reader, -1));
                    break;
                case "typeMode":
                    position = checkElementOrder("typeMode", 4, position, false);
                    builder.typeMode((StructureMapGroupTypeMode) parseString(StructureMapGroupTypeMode.builder(), "typeMode", reader, -1));
                    break;
                case "documentation":
                    position = checkElementOrder("documentation", 5, position, false);
                    builder.documentation(parseString("documentation", reader, -1));
                    break;
                case "input":
                    position = checkElementOrder("input", 6, position, true);
                    builder.input(parseStructureMapGroupInput("input", reader, inputElementIndex++));
                    break;
                case "rule":
                    position = checkElementOrder("rule", 7, position, true);
                    builder.rule(parseStructureMapGroupRule("rule", reader, ruleElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private StructureMap.Group.Input parseStructureMapGroupInput(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        StructureMap.Group.Input.Builder builder = StructureMap.Group.Input.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name((Id) parseString(Id.builder(), "name", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type(parseString("type", reader, -1));
                    break;
                case "mode":
                    position = checkElementOrder("mode", 4, position, false);
                    builder.mode((StructureMapInputMode) parseString(StructureMapInputMode.builder(), "mode", reader, -1));
                    break;
                case "documentation":
                    position = checkElementOrder("documentation", 5, position, false);
                    builder.documentation(parseString("documentation", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private StructureMap.Group.Rule parseStructureMapGroupRule(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        StructureMap.Group.Rule.Builder builder = StructureMap.Group.Rule.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, sourceElementIndex = 0, targetElementIndex = 0, ruleElementIndex = 0, dependentElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name((Id) parseString(Id.builder(), "name", reader, -1));
                    break;
                case "source":
                    position = checkElementOrder("source", 3, position, true);
                    builder.source(parseStructureMapGroupRuleSource("source", reader, sourceElementIndex++));
                    break;
                case "target":
                    position = checkElementOrder("target", 4, position, true);
                    builder.target(parseStructureMapGroupRuleTarget("target", reader, targetElementIndex++));
                    break;
                case "rule":
                    position = checkElementOrder("rule", 5, position, true);
                    builder.rule(parseStructureMapGroupRule("rule", reader, ruleElementIndex++));
                    break;
                case "dependent":
                    position = checkElementOrder("dependent", 6, position, true);
                    builder.dependent(parseStructureMapGroupRuleDependent("dependent", reader, dependentElementIndex++));
                    break;
                case "documentation":
                    position = checkElementOrder("documentation", 7, position, false);
                    builder.documentation(parseString("documentation", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private StructureMap.Group.Rule.Dependent parseStructureMapGroupRuleDependent(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        StructureMap.Group.Rule.Dependent.Builder builder = StructureMap.Group.Rule.Dependent.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, variableElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name((Id) parseString(Id.builder(), "name", reader, -1));
                    break;
                case "variable":
                    position = checkElementOrder("variable", 3, position, true);
                    builder.variable(parseString("variable", reader, variableElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private StructureMap.Group.Rule.Source parseStructureMapGroupRuleSource(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        StructureMap.Group.Rule.Source.Builder builder = StructureMap.Group.Rule.Source.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "context":
                    position = checkElementOrder("context", 2, position, false);
                    builder.context((Id) parseString(Id.builder(), "context", reader, -1));
                    break;
                case "min":
                    position = checkElementOrder("min", 3, position, false);
                    builder.min(parseInteger("min", reader, -1));
                    break;
                case "max":
                    position = checkElementOrder("max", 4, position, false);
                    builder.max(parseString("max", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 5, position, false);
                    builder.type(parseString("type", reader, -1));
                    break;
                case "defaultValueBase64Binary":
                    position = checkElementOrder("defaultValue[x]", 6, position, false);
                    builder.defaultValue(parseBase64Binary("defaultValueBase64Binary", reader, -1));
                    break;
                case "defaultValueBoolean":
                    position = checkElementOrder("defaultValue[x]", 6, position, false);
                    builder.defaultValue(parseBoolean("defaultValueBoolean", reader, -1));
                    break;
                case "defaultValueCanonical":
                    position = checkElementOrder("defaultValue[x]", 6, position, false);
                    builder.defaultValue((Canonical) parseUri(Canonical.builder(), "defaultValueCanonical", reader, -1));
                    break;
                case "defaultValueCode":
                    position = checkElementOrder("defaultValue[x]", 6, position, false);
                    builder.defaultValue((Code) parseString(Code.builder(), "defaultValueCode", reader, -1));
                    break;
                case "defaultValueDate":
                    position = checkElementOrder("defaultValue[x]", 6, position, false);
                    builder.defaultValue(parseDate("defaultValueDate", reader, -1));
                    break;
                case "defaultValueDateTime":
                    position = checkElementOrder("defaultValue[x]", 6, position, false);
                    builder.defaultValue(parseDateTime("defaultValueDateTime", reader, -1));
                    break;
                case "defaultValueDecimal":
                    position = checkElementOrder("defaultValue[x]", 6, position, false);
                    builder.defaultValue(parseDecimal("defaultValueDecimal", reader, -1));
                    break;
                case "defaultValueId":
                    position = checkElementOrder("defaultValue[x]", 6, position, false);
                    builder.defaultValue((Id) parseString(Id.builder(), "defaultValueId", reader, -1));
                    break;
                case "defaultValueInstant":
                    position = checkElementOrder("defaultValue[x]", 6, position, false);
                    builder.defaultValue(parseInstant("defaultValueInstant", reader, -1));
                    break;
                case "defaultValueInteger":
                    position = checkElementOrder("defaultValue[x]", 6, position, false);
                    builder.defaultValue(parseInteger("defaultValueInteger", reader, -1));
                    break;
                case "defaultValueMarkdown":
                    position = checkElementOrder("defaultValue[x]", 6, position, false);
                    builder.defaultValue((Markdown) parseString(Markdown.builder(), "defaultValueMarkdown", reader, -1));
                    break;
                case "defaultValueOid":
                    position = checkElementOrder("defaultValue[x]", 6, position, false);
                    builder.defaultValue((Oid) parseUri(Oid.builder(), "defaultValueOid", reader, -1));
                    break;
                case "defaultValuePositiveInt":
                    position = checkElementOrder("defaultValue[x]", 6, position, false);
                    builder.defaultValue((PositiveInt) parseInteger(PositiveInt.builder(), "defaultValuePositiveInt", reader, -1));
                    break;
                case "defaultValueString":
                    position = checkElementOrder("defaultValue[x]", 6, position, false);
                    builder.defaultValue(parseString("defaultValueString", reader, -1));
                    break;
                case "defaultValueTime":
                    position = checkElementOrder("defaultValue[x]", 6, position, false);
                    builder.defaultValue(parseTime("defaultValueTime", reader, -1));
                    break;
                case "defaultValueUnsignedInt":
                    position = checkElementOrder("defaultValue[x]", 6, position, false);
                    builder.defaultValue((UnsignedInt) parseInteger(UnsignedInt.builder(), "defaultValueUnsignedInt", reader, -1));
                    break;
                case "defaultValueUri":
                    position = checkElementOrder("defaultValue[x]", 6, position, false);
                    builder.defaultValue(parseUri("defaultValueUri", reader, -1));
                    break;
                case "defaultValueUrl":
                    position = checkElementOrder("defaultValue[x]", 6, position, false);
                    builder.defaultValue((Url) parseUri(Url.builder(), "defaultValueUrl", reader, -1));
                    break;
                case "defaultValueUuid":
                    position = checkElementOrder("defaultValue[x]", 6, position, false);
                    builder.defaultValue((Uuid) parseUri(Uuid.builder(), "defaultValueUuid", reader, -1));
                    break;
                case "defaultValueAddress":
                    position = checkElementOrder("defaultValue[x]", 6, position, false);
                    builder.defaultValue(parseAddress("defaultValueAddress", reader, -1));
                    break;
                case "defaultValueAge":
                    position = checkElementOrder("defaultValue[x]", 6, position, false);
                    builder.defaultValue((Age) parseQuantity(Age.builder(), "defaultValueAge", reader, -1));
                    break;
                case "defaultValueAnnotation":
                    position = checkElementOrder("defaultValue[x]", 6, position, false);
                    builder.defaultValue(parseAnnotation("defaultValueAnnotation", reader, -1));
                    break;
                case "defaultValueAttachment":
                    position = checkElementOrder("defaultValue[x]", 6, position, false);
                    builder.defaultValue(parseAttachment("defaultValueAttachment", reader, -1));
                    break;
                case "defaultValueCodeableConcept":
                    position = checkElementOrder("defaultValue[x]", 6, position, false);
                    builder.defaultValue(parseCodeableConcept("defaultValueCodeableConcept", reader, -1));
                    break;
                case "defaultValueCoding":
                    position = checkElementOrder("defaultValue[x]", 6, position, false);
                    builder.defaultValue(parseCoding("defaultValueCoding", reader, -1));
                    break;
                case "defaultValueContactPoint":
                    position = checkElementOrder("defaultValue[x]", 6, position, false);
                    builder.defaultValue(parseContactPoint("defaultValueContactPoint", reader, -1));
                    break;
                case "defaultValueCount":
                    position = checkElementOrder("defaultValue[x]", 6, position, false);
                    builder.defaultValue((Count) parseQuantity(Count.builder(), "defaultValueCount", reader, -1));
                    break;
                case "defaultValueDistance":
                    position = checkElementOrder("defaultValue[x]", 6, position, false);
                    builder.defaultValue((Distance) parseQuantity(Distance.builder(), "defaultValueDistance", reader, -1));
                    break;
                case "defaultValueDuration":
                    position = checkElementOrder("defaultValue[x]", 6, position, false);
                    builder.defaultValue((Duration) parseQuantity(Duration.builder(), "defaultValueDuration", reader, -1));
                    break;
                case "defaultValueHumanName":
                    position = checkElementOrder("defaultValue[x]", 6, position, false);
                    builder.defaultValue(parseHumanName("defaultValueHumanName", reader, -1));
                    break;
                case "defaultValueIdentifier":
                    position = checkElementOrder("defaultValue[x]", 6, position, false);
                    builder.defaultValue(parseIdentifier("defaultValueIdentifier", reader, -1));
                    break;
                case "defaultValueMoney":
                    position = checkElementOrder("defaultValue[x]", 6, position, false);
                    builder.defaultValue(parseMoney("defaultValueMoney", reader, -1));
                    break;
                case "defaultValuePeriod":
                    position = checkElementOrder("defaultValue[x]", 6, position, false);
                    builder.defaultValue(parsePeriod("defaultValuePeriod", reader, -1));
                    break;
                case "defaultValueQuantity":
                    position = checkElementOrder("defaultValue[x]", 6, position, false);
                    builder.defaultValue(parseQuantity("defaultValueQuantity", reader, -1));
                    break;
                case "defaultValueRange":
                    position = checkElementOrder("defaultValue[x]", 6, position, false);
                    builder.defaultValue(parseRange("defaultValueRange", reader, -1));
                    break;
                case "defaultValueRatio":
                    position = checkElementOrder("defaultValue[x]", 6, position, false);
                    builder.defaultValue(parseRatio("defaultValueRatio", reader, -1));
                    break;
                case "defaultValueReference":
                    position = checkElementOrder("defaultValue[x]", 6, position, false);
                    builder.defaultValue(parseReference("defaultValueReference", reader, -1));
                    break;
                case "defaultValueSampledData":
                    position = checkElementOrder("defaultValue[x]", 6, position, false);
                    builder.defaultValue(parseSampledData("defaultValueSampledData", reader, -1));
                    break;
                case "defaultValueSignature":
                    position = checkElementOrder("defaultValue[x]", 6, position, false);
                    builder.defaultValue(parseSignature("defaultValueSignature", reader, -1));
                    break;
                case "defaultValueTiming":
                    position = checkElementOrder("defaultValue[x]", 6, position, false);
                    builder.defaultValue(parseTiming("defaultValueTiming", reader, -1));
                    break;
                case "defaultValueContactDetail":
                    position = checkElementOrder("defaultValue[x]", 6, position, false);
                    builder.defaultValue(parseContactDetail("defaultValueContactDetail", reader, -1));
                    break;
                case "defaultValueContributor":
                    position = checkElementOrder("defaultValue[x]", 6, position, false);
                    builder.defaultValue(parseContributor("defaultValueContributor", reader, -1));
                    break;
                case "defaultValueDataRequirement":
                    position = checkElementOrder("defaultValue[x]", 6, position, false);
                    builder.defaultValue(parseDataRequirement("defaultValueDataRequirement", reader, -1));
                    break;
                case "defaultValueExpression":
                    position = checkElementOrder("defaultValue[x]", 6, position, false);
                    builder.defaultValue(parseExpression("defaultValueExpression", reader, -1));
                    break;
                case "defaultValueParameterDefinition":
                    position = checkElementOrder("defaultValue[x]", 6, position, false);
                    builder.defaultValue(parseParameterDefinition("defaultValueParameterDefinition", reader, -1));
                    break;
                case "defaultValueRelatedArtifact":
                    position = checkElementOrder("defaultValue[x]", 6, position, false);
                    builder.defaultValue(parseRelatedArtifact("defaultValueRelatedArtifact", reader, -1));
                    break;
                case "defaultValueTriggerDefinition":
                    position = checkElementOrder("defaultValue[x]", 6, position, false);
                    builder.defaultValue(parseTriggerDefinition("defaultValueTriggerDefinition", reader, -1));
                    break;
                case "defaultValueUsageContext":
                    position = checkElementOrder("defaultValue[x]", 6, position, false);
                    builder.defaultValue(parseUsageContext("defaultValueUsageContext", reader, -1));
                    break;
                case "defaultValueDosage":
                    position = checkElementOrder("defaultValue[x]", 6, position, false);
                    builder.defaultValue(parseDosage("defaultValueDosage", reader, -1));
                    break;
                case "defaultValueMeta":
                    position = checkElementOrder("defaultValue[x]", 6, position, false);
                    builder.defaultValue(parseMeta("defaultValueMeta", reader, -1));
                    break;
                case "element":
                    position = checkElementOrder("element", 7, position, false);
                    builder.element(parseString("element", reader, -1));
                    break;
                case "listMode":
                    position = checkElementOrder("listMode", 8, position, false);
                    builder.listMode((StructureMapSourceListMode) parseString(StructureMapSourceListMode.builder(), "listMode", reader, -1));
                    break;
                case "variable":
                    position = checkElementOrder("variable", 9, position, false);
                    builder.variable((Id) parseString(Id.builder(), "variable", reader, -1));
                    break;
                case "condition":
                    position = checkElementOrder("condition", 10, position, false);
                    builder.condition(parseString("condition", reader, -1));
                    break;
                case "check":
                    position = checkElementOrder("check", 11, position, false);
                    builder.check(parseString("check", reader, -1));
                    break;
                case "logMessage":
                    position = checkElementOrder("logMessage", 12, position, false);
                    builder.logMessage(parseString("logMessage", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private StructureMap.Group.Rule.Target parseStructureMapGroupRuleTarget(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        StructureMap.Group.Rule.Target.Builder builder = StructureMap.Group.Rule.Target.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, listModeElementIndex = 0, parameterElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "context":
                    position = checkElementOrder("context", 2, position, false);
                    builder.context((Id) parseString(Id.builder(), "context", reader, -1));
                    break;
                case "contextType":
                    position = checkElementOrder("contextType", 3, position, false);
                    builder.contextType((StructureMapContextType) parseString(StructureMapContextType.builder(), "contextType", reader, -1));
                    break;
                case "element":
                    position = checkElementOrder("element", 4, position, false);
                    builder.element(parseString("element", reader, -1));
                    break;
                case "variable":
                    position = checkElementOrder("variable", 5, position, false);
                    builder.variable((Id) parseString(Id.builder(), "variable", reader, -1));
                    break;
                case "listMode":
                    position = checkElementOrder("listMode", 6, position, true);
                    builder.listMode((StructureMapTargetListMode) parseString(StructureMapTargetListMode.builder(), "listMode", reader, listModeElementIndex++));
                    break;
                case "listRuleId":
                    position = checkElementOrder("listRuleId", 7, position, false);
                    builder.listRuleId((Id) parseString(Id.builder(), "listRuleId", reader, -1));
                    break;
                case "transform":
                    position = checkElementOrder("transform", 8, position, false);
                    builder.transform((StructureMapTransform) parseString(StructureMapTransform.builder(), "transform", reader, -1));
                    break;
                case "parameter":
                    position = checkElementOrder("parameter", 9, position, true);
                    builder.parameter(parseStructureMapGroupRuleTargetParameter("parameter", reader, parameterElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private StructureMap.Group.Rule.Target.Parameter parseStructureMapGroupRuleTargetParameter(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        StructureMap.Group.Rule.Target.Parameter.Builder builder = StructureMap.Group.Rule.Target.Parameter.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "valueId":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value((Id) parseString(Id.builder(), "valueId", reader, -1));
                    break;
                case "valueString":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseString("valueString", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueInteger":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseInteger("valueInteger", reader, -1));
                    break;
                case "valueDecimal":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseDecimal("valueDecimal", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private StructureMap.Structure parseStructureMapStructure(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        StructureMap.Structure.Builder builder = StructureMap.Structure.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 2, position, false);
                    builder.url((Canonical) parseUri(Canonical.builder(), "url", reader, -1));
                    break;
                case "mode":
                    position = checkElementOrder("mode", 3, position, false);
                    builder.mode((StructureMapModelMode) parseString(StructureMapModelMode.builder(), "mode", reader, -1));
                    break;
                case "alias":
                    position = checkElementOrder("alias", 4, position, false);
                    builder.alias(parseString("alias", reader, -1));
                    break;
                case "documentation":
                    position = checkElementOrder("documentation", 5, position, false);
                    builder.documentation(parseString("documentation", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Subscription parseSubscription(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Subscription.Builder builder = Subscription.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, contactElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 8, position, false);
                    builder.status((SubscriptionStatusCode) parseString(SubscriptionStatusCode.builder(), "status", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 9, position, true);
                    builder.contact(parseContactPoint("contact", reader, contactElementIndex++));
                    break;
                case "end":
                    position = checkElementOrder("end", 10, position, false);
                    builder.end(parseInstant("end", reader, -1));
                    break;
                case "reason":
                    position = checkElementOrder("reason", 11, position, false);
                    builder.reason(parseString("reason", reader, -1));
                    break;
                case "criteria":
                    position = checkElementOrder("criteria", 12, position, false);
                    builder.criteria(parseString("criteria", reader, -1));
                    break;
                case "error":
                    position = checkElementOrder("error", 13, position, false);
                    builder.error(parseString("error", reader, -1));
                    break;
                case "channel":
                    position = checkElementOrder("channel", 14, position, false);
                    builder.channel(parseSubscriptionChannel("channel", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Subscription.Channel parseSubscriptionChannel(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Subscription.Channel.Builder builder = Subscription.Channel.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, headerElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type((SubscriptionChannelType) parseString(SubscriptionChannelType.builder(), "type", reader, -1));
                    break;
                case "endpoint":
                    position = checkElementOrder("endpoint", 3, position, false);
                    builder.endpoint((Url) parseUri(Url.builder(), "endpoint", reader, -1));
                    break;
                case "payload":
                    position = checkElementOrder("payload", 4, position, false);
                    builder.payload((Code) parseString(Code.builder(), "payload", reader, -1));
                    break;
                case "header":
                    position = checkElementOrder("header", 5, position, true);
                    builder.header(parseString("header", reader, headerElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubscriptionStatus parseSubscriptionStatus(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubscriptionStatus.Builder builder = SubscriptionStatus.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, notificationEventElementIndex = 0, errorElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 8, position, false);
                    builder.status((SubscriptionStatusCode) parseString(SubscriptionStatusCode.builder(), "status", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 9, position, false);
                    builder.type((SubscriptionNotificationType) parseString(SubscriptionNotificationType.builder(), "type", reader, -1));
                    break;
                case "eventsSinceSubscriptionStart":
                    position = checkElementOrder("eventsSinceSubscriptionStart", 10, position, false);
                    builder.eventsSinceSubscriptionStart(parseString("eventsSinceSubscriptionStart", reader, -1));
                    break;
                case "eventsInNotification":
                    position = checkElementOrder("eventsInNotification", 11, position, false);
                    builder.eventsInNotification(parseInteger("eventsInNotification", reader, -1));
                    break;
                case "notificationEvent":
                    position = checkElementOrder("notificationEvent", 12, position, true);
                    builder.notificationEvent(parseSubscriptionStatusNotificationEvent("notificationEvent", reader, notificationEventElementIndex++));
                    break;
                case "subscription":
                    position = checkElementOrder("subscription", 13, position, false);
                    builder.subscription(parseReference("subscription", reader, -1));
                    break;
                case "topic":
                    position = checkElementOrder("topic", 14, position, false);
                    builder.topic((Canonical) parseUri(Canonical.builder(), "topic", reader, -1));
                    break;
                case "error":
                    position = checkElementOrder("error", 15, position, true);
                    builder.error(parseCodeableConcept("error", reader, errorElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubscriptionStatus.NotificationEvent parseSubscriptionStatusNotificationEvent(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubscriptionStatus.NotificationEvent.Builder builder = SubscriptionStatus.NotificationEvent.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, additionalContextElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "eventNumber":
                    position = checkElementOrder("eventNumber", 2, position, false);
                    builder.eventNumber(parseString("eventNumber", reader, -1));
                    break;
                case "timestamp":
                    position = checkElementOrder("timestamp", 3, position, false);
                    builder.timestamp(parseInstant("timestamp", reader, -1));
                    break;
                case "focus":
                    position = checkElementOrder("focus", 4, position, false);
                    builder.focus(parseReference("focus", reader, -1));
                    break;
                case "additionalContext":
                    position = checkElementOrder("additionalContext", 5, position, true);
                    builder.additionalContext(parseReference("additionalContext", reader, additionalContextElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubscriptionTopic parseSubscriptionTopic(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubscriptionTopic.Builder builder = SubscriptionTopic.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, derivedFromElementIndex = 0, contactElementIndex = 0, useContextElementIndex = 0, jurisdictionElementIndex = 0, resourceTriggerElementIndex = 0, eventTriggerElementIndex = 0, canFilterByElementIndex = 0, notificationShapeElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 10, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 11, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "derivedFrom":
                    position = checkElementOrder("derivedFrom", 12, position, true);
                    builder.derivedFrom((Canonical) parseUri(Canonical.builder(), "derivedFrom", reader, derivedFromElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 13, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 14, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 15, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 16, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 17, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 18, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 19, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 20, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 21, position, false);
                    builder.purpose((Markdown) parseString(Markdown.builder(), "purpose", reader, -1));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 22, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                case "approvalDate":
                    position = checkElementOrder("approvalDate", 23, position, false);
                    builder.approvalDate(parseDate("approvalDate", reader, -1));
                    break;
                case "lastReviewDate":
                    position = checkElementOrder("lastReviewDate", 24, position, false);
                    builder.lastReviewDate(parseDate("lastReviewDate", reader, -1));
                    break;
                case "effectivePeriod":
                    position = checkElementOrder("effectivePeriod", 25, position, false);
                    builder.effectivePeriod(parsePeriod("effectivePeriod", reader, -1));
                    break;
                case "resourceTrigger":
                    position = checkElementOrder("resourceTrigger", 26, position, true);
                    builder.resourceTrigger(parseSubscriptionTopicResourceTrigger("resourceTrigger", reader, resourceTriggerElementIndex++));
                    break;
                case "eventTrigger":
                    position = checkElementOrder("eventTrigger", 27, position, true);
                    builder.eventTrigger(parseSubscriptionTopicEventTrigger("eventTrigger", reader, eventTriggerElementIndex++));
                    break;
                case "canFilterBy":
                    position = checkElementOrder("canFilterBy", 28, position, true);
                    builder.canFilterBy(parseSubscriptionTopicCanFilterBy("canFilterBy", reader, canFilterByElementIndex++));
                    break;
                case "notificationShape":
                    position = checkElementOrder("notificationShape", 29, position, true);
                    builder.notificationShape(parseSubscriptionTopicNotificationShape("notificationShape", reader, notificationShapeElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubscriptionTopic.CanFilterBy parseSubscriptionTopicCanFilterBy(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubscriptionTopic.CanFilterBy.Builder builder = SubscriptionTopic.CanFilterBy.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, modifierElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 2, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "resource":
                    position = checkElementOrder("resource", 3, position, false);
                    builder.resource(parseUri("resource", reader, -1));
                    break;
                case "filterParameter":
                    position = checkElementOrder("filterParameter", 4, position, false);
                    builder.filterParameter(parseString("filterParameter", reader, -1));
                    break;
                case "modifier":
                    position = checkElementOrder("modifier", 5, position, true);
                    builder.modifier((SubscriptionTopicFilterBySearchModifier) parseString(SubscriptionTopicFilterBySearchModifier.builder(), "modifier", reader, modifierElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubscriptionTopic.EventTrigger parseSubscriptionTopicEventTrigger(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubscriptionTopic.EventTrigger.Builder builder = SubscriptionTopic.EventTrigger.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 2, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "event":
                    position = checkElementOrder("event", 3, position, false);
                    builder.event(parseCodeableConcept("event", reader, -1));
                    break;
                case "resource":
                    position = checkElementOrder("resource", 4, position, false);
                    builder.resource(parseUri("resource", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubscriptionTopic.NotificationShape parseSubscriptionTopicNotificationShape(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubscriptionTopic.NotificationShape.Builder builder = SubscriptionTopic.NotificationShape.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, includeElementIndex = 0, revIncludeElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "resource":
                    position = checkElementOrder("resource", 2, position, false);
                    builder.resource(parseUri("resource", reader, -1));
                    break;
                case "include":
                    position = checkElementOrder("include", 3, position, true);
                    builder.include(parseString("include", reader, includeElementIndex++));
                    break;
                case "revInclude":
                    position = checkElementOrder("revInclude", 4, position, true);
                    builder.revInclude(parseString("revInclude", reader, revIncludeElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubscriptionTopic.ResourceTrigger parseSubscriptionTopicResourceTrigger(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubscriptionTopic.ResourceTrigger.Builder builder = SubscriptionTopic.ResourceTrigger.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, supportedInteractionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 2, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "resource":
                    position = checkElementOrder("resource", 3, position, false);
                    builder.resource(parseUri("resource", reader, -1));
                    break;
                case "supportedInteraction":
                    position = checkElementOrder("supportedInteraction", 4, position, true);
                    builder.supportedInteraction((MethodCode) parseString(MethodCode.builder(), "supportedInteraction", reader, supportedInteractionElementIndex++));
                    break;
                case "queryCriteria":
                    position = checkElementOrder("queryCriteria", 5, position, false);
                    builder.queryCriteria(parseSubscriptionTopicResourceTriggerQueryCriteria("queryCriteria", reader, -1));
                    break;
                case "fhirPathCriteria":
                    position = checkElementOrder("fhirPathCriteria", 6, position, false);
                    builder.fhirPathCriteria(parseString("fhirPathCriteria", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubscriptionTopic.ResourceTrigger.QueryCriteria parseSubscriptionTopicResourceTriggerQueryCriteria(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubscriptionTopic.ResourceTrigger.QueryCriteria.Builder builder = SubscriptionTopic.ResourceTrigger.QueryCriteria.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "previous":
                    position = checkElementOrder("previous", 2, position, false);
                    builder.previous(parseString("previous", reader, -1));
                    break;
                case "resultForCreate":
                    position = checkElementOrder("resultForCreate", 3, position, false);
                    builder.resultForCreate((CriteriaNotExistsBehavior) parseString(CriteriaNotExistsBehavior.builder(), "resultForCreate", reader, -1));
                    break;
                case "current":
                    position = checkElementOrder("current", 4, position, false);
                    builder.current(parseString("current", reader, -1));
                    break;
                case "resultForDelete":
                    position = checkElementOrder("resultForDelete", 5, position, false);
                    builder.resultForDelete((CriteriaNotExistsBehavior) parseString(CriteriaNotExistsBehavior.builder(), "resultForDelete", reader, -1));
                    break;
                case "requireBoth":
                    position = checkElementOrder("requireBoth", 6, position, false);
                    builder.requireBoth(parseBoolean("requireBoth", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Substance parseSubstance(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Substance.Builder builder = Substance.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, categoryElementIndex = 0, instanceElementIndex = 0, ingredientElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((FHIRSubstanceStatus) parseString(FHIRSubstanceStatus.builder(), "status", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 10, position, true);
                    builder.category(parseCodeableConcept("category", reader, categoryElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 11, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 12, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "instance":
                    position = checkElementOrder("instance", 13, position, true);
                    builder.instance(parseSubstanceInstance("instance", reader, instanceElementIndex++));
                    break;
                case "ingredient":
                    position = checkElementOrder("ingredient", 14, position, true);
                    builder.ingredient(parseSubstanceIngredient("ingredient", reader, ingredientElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Substance.Ingredient parseSubstanceIngredient(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Substance.Ingredient.Builder builder = Substance.Ingredient.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 2, position, false);
                    builder.quantity(parseRatio("quantity", reader, -1));
                    break;
                case "substanceCodeableConcept":
                    position = checkElementOrder("substance[x]", 3, position, false);
                    builder.substance(parseCodeableConcept("substanceCodeableConcept", reader, -1));
                    break;
                case "substanceReference":
                    position = checkElementOrder("substance[x]", 3, position, false);
                    builder.substance(parseReference("substanceReference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Substance.Instance parseSubstanceInstance(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Substance.Instance.Builder builder = Substance.Instance.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 2, position, false);
                    builder.identifier(parseIdentifier("identifier", reader, -1));
                    break;
                case "expiry":
                    position = checkElementOrder("expiry", 3, position, false);
                    builder.expiry(parseDateTime("expiry", reader, -1));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 4, position, false);
                    builder.quantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "quantity", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubstanceDefinition parseSubstanceDefinition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubstanceDefinition.Builder builder = SubstanceDefinition.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, classificationElementIndex = 0, gradeElementIndex = 0, informationSourceElementIndex = 0, noteElementIndex = 0, manufacturerElementIndex = 0, supplierElementIndex = 0, moietyElementIndex = 0, propertyElementIndex = 0, molecularWeightElementIndex = 0, codeElementIndex = 0, nameElementIndex = 0, relationshipElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 9, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 10, position, false);
                    builder.status(parseCodeableConcept("status", reader, -1));
                    break;
                case "classification":
                    position = checkElementOrder("classification", 11, position, true);
                    builder.classification(parseCodeableConcept("classification", reader, classificationElementIndex++));
                    break;
                case "domain":
                    position = checkElementOrder("domain", 12, position, false);
                    builder.domain(parseCodeableConcept("domain", reader, -1));
                    break;
                case "grade":
                    position = checkElementOrder("grade", 13, position, true);
                    builder.grade(parseCodeableConcept("grade", reader, gradeElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 14, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "informationSource":
                    position = checkElementOrder("informationSource", 15, position, true);
                    builder.informationSource(parseReference("informationSource", reader, informationSourceElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 16, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "manufacturer":
                    position = checkElementOrder("manufacturer", 17, position, true);
                    builder.manufacturer(parseReference("manufacturer", reader, manufacturerElementIndex++));
                    break;
                case "supplier":
                    position = checkElementOrder("supplier", 18, position, true);
                    builder.supplier(parseReference("supplier", reader, supplierElementIndex++));
                    break;
                case "moiety":
                    position = checkElementOrder("moiety", 19, position, true);
                    builder.moiety(parseSubstanceDefinitionMoiety("moiety", reader, moietyElementIndex++));
                    break;
                case "property":
                    position = checkElementOrder("property", 20, position, true);
                    builder.property(parseSubstanceDefinitionProperty("property", reader, propertyElementIndex++));
                    break;
                case "molecularWeight":
                    position = checkElementOrder("molecularWeight", 21, position, true);
                    builder.molecularWeight(parseSubstanceDefinitionMolecularWeight("molecularWeight", reader, molecularWeightElementIndex++));
                    break;
                case "structure":
                    position = checkElementOrder("structure", 22, position, false);
                    builder.structure(parseSubstanceDefinitionStructure("structure", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 23, position, true);
                    builder.code(parseSubstanceDefinitionCode("code", reader, codeElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 24, position, true);
                    builder.name(parseSubstanceDefinitionName("name", reader, nameElementIndex++));
                    break;
                case "relationship":
                    position = checkElementOrder("relationship", 25, position, true);
                    builder.relationship(parseSubstanceDefinitionRelationship("relationship", reader, relationshipElementIndex++));
                    break;
                case "sourceMaterial":
                    position = checkElementOrder("sourceMaterial", 26, position, false);
                    builder.sourceMaterial(parseSubstanceDefinitionSourceMaterial("sourceMaterial", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubstanceDefinition.Code parseSubstanceDefinitionCode(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubstanceDefinition.Code.Builder builder = SubstanceDefinition.Code.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, noteElementIndex = 0, sourceElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 3, position, false);
                    builder.status(parseCodeableConcept("status", reader, -1));
                    break;
                case "statusDate":
                    position = checkElementOrder("statusDate", 4, position, false);
                    builder.statusDate(parseDateTime("statusDate", reader, -1));
                    break;
                case "note":
                    position = checkElementOrder("note", 5, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "source":
                    position = checkElementOrder("source", 6, position, true);
                    builder.source(parseReference("source", reader, sourceElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubstanceDefinition.Moiety parseSubstanceDefinitionMoiety(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubstanceDefinition.Moiety.Builder builder = SubstanceDefinition.Moiety.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "role":
                    position = checkElementOrder("role", 2, position, false);
                    builder.role(parseCodeableConcept("role", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 3, position, false);
                    builder.identifier(parseIdentifier("identifier", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 4, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "stereochemistry":
                    position = checkElementOrder("stereochemistry", 5, position, false);
                    builder.stereochemistry(parseCodeableConcept("stereochemistry", reader, -1));
                    break;
                case "opticalActivity":
                    position = checkElementOrder("opticalActivity", 6, position, false);
                    builder.opticalActivity(parseCodeableConcept("opticalActivity", reader, -1));
                    break;
                case "molecularFormula":
                    position = checkElementOrder("molecularFormula", 7, position, false);
                    builder.molecularFormula(parseString("molecularFormula", reader, -1));
                    break;
                case "amountQuantity":
                    position = checkElementOrder("amount[x]", 8, position, false);
                    builder.amount(parseQuantity("amountQuantity", reader, -1));
                    break;
                case "amountString":
                    position = checkElementOrder("amount[x]", 8, position, false);
                    builder.amount(parseString("amountString", reader, -1));
                    break;
                case "amountType":
                    position = checkElementOrder("amountType", 9, position, false);
                    builder.amountType(parseCodeableConcept("amountType", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubstanceDefinition.MolecularWeight parseSubstanceDefinitionMolecularWeight(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubstanceDefinition.MolecularWeight.Builder builder = SubstanceDefinition.MolecularWeight.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "method":
                    position = checkElementOrder("method", 2, position, false);
                    builder.method(parseCodeableConcept("method", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "amount":
                    position = checkElementOrder("amount", 4, position, false);
                    builder.amount(parseQuantity("amount", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubstanceDefinition.Name parseSubstanceDefinitionName(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubstanceDefinition.Name.Builder builder = SubstanceDefinition.Name.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, languageElementIndex = 0, domainElementIndex = 0, jurisdictionElementIndex = 0, synonymElementIndex = 0, translationElementIndex = 0, officialElementIndex = 0, sourceElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 4, position, false);
                    builder.status(parseCodeableConcept("status", reader, -1));
                    break;
                case "preferred":
                    position = checkElementOrder("preferred", 5, position, false);
                    builder.preferred(parseBoolean("preferred", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 6, position, true);
                    builder.language(parseCodeableConcept("language", reader, languageElementIndex++));
                    break;
                case "domain":
                    position = checkElementOrder("domain", 7, position, true);
                    builder.domain(parseCodeableConcept("domain", reader, domainElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 8, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "synonym":
                    position = checkElementOrder("synonym", 9, position, true);
                    builder.synonym(parseSubstanceDefinitionName("synonym", reader, synonymElementIndex++));
                    break;
                case "translation":
                    position = checkElementOrder("translation", 10, position, true);
                    builder.translation(parseSubstanceDefinitionName("translation", reader, translationElementIndex++));
                    break;
                case "official":
                    position = checkElementOrder("official", 11, position, true);
                    builder.official(parseSubstanceDefinitionNameOfficial("official", reader, officialElementIndex++));
                    break;
                case "source":
                    position = checkElementOrder("source", 12, position, true);
                    builder.source(parseReference("source", reader, sourceElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubstanceDefinition.Name.Official parseSubstanceDefinitionNameOfficial(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubstanceDefinition.Name.Official.Builder builder = SubstanceDefinition.Name.Official.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "authority":
                    position = checkElementOrder("authority", 2, position, false);
                    builder.authority(parseCodeableConcept("authority", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 3, position, false);
                    builder.status(parseCodeableConcept("status", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 4, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubstanceDefinition.Property parseSubstanceDefinitionProperty(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubstanceDefinition.Property.Builder builder = SubstanceDefinition.Property.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "valueCodeableConcept":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCodeableConcept("valueCodeableConcept", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueDate":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDate("valueDate", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueAttachment":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseAttachment("valueAttachment", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubstanceDefinition.Relationship parseSubstanceDefinitionRelationship(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubstanceDefinition.Relationship.Builder builder = SubstanceDefinition.Relationship.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, sourceElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "substanceDefinitionReference":
                    position = checkElementOrder("substanceDefinition[x]", 2, position, false);
                    builder.substanceDefinition(parseReference("substanceDefinitionReference", reader, -1));
                    break;
                case "substanceDefinitionCodeableConcept":
                    position = checkElementOrder("substanceDefinition[x]", 2, position, false);
                    builder.substanceDefinition(parseCodeableConcept("substanceDefinitionCodeableConcept", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "isDefining":
                    position = checkElementOrder("isDefining", 4, position, false);
                    builder.isDefining(parseBoolean("isDefining", reader, -1));
                    break;
                case "amountQuantity":
                    position = checkElementOrder("amount[x]", 5, position, false);
                    builder.amount(parseQuantity("amountQuantity", reader, -1));
                    break;
                case "amountRatio":
                    position = checkElementOrder("amount[x]", 5, position, false);
                    builder.amount(parseRatio("amountRatio", reader, -1));
                    break;
                case "amountString":
                    position = checkElementOrder("amount[x]", 5, position, false);
                    builder.amount(parseString("amountString", reader, -1));
                    break;
                case "amountRatioHighLimit":
                    position = checkElementOrder("amountRatioHighLimit", 6, position, false);
                    builder.amountRatioHighLimit(parseRatio("amountRatioHighLimit", reader, -1));
                    break;
                case "amountType":
                    position = checkElementOrder("amountType", 7, position, false);
                    builder.amountType(parseCodeableConcept("amountType", reader, -1));
                    break;
                case "source":
                    position = checkElementOrder("source", 8, position, true);
                    builder.source(parseReference("source", reader, sourceElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubstanceDefinition.SourceMaterial parseSubstanceDefinitionSourceMaterial(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubstanceDefinition.SourceMaterial.Builder builder = SubstanceDefinition.SourceMaterial.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, countryOfOriginElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "genus":
                    position = checkElementOrder("genus", 3, position, false);
                    builder.genus(parseCodeableConcept("genus", reader, -1));
                    break;
                case "species":
                    position = checkElementOrder("species", 4, position, false);
                    builder.species(parseCodeableConcept("species", reader, -1));
                    break;
                case "part":
                    position = checkElementOrder("part", 5, position, false);
                    builder.part(parseCodeableConcept("part", reader, -1));
                    break;
                case "countryOfOrigin":
                    position = checkElementOrder("countryOfOrigin", 6, position, true);
                    builder.countryOfOrigin(parseCodeableConcept("countryOfOrigin", reader, countryOfOriginElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubstanceDefinition.Structure parseSubstanceDefinitionStructure(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubstanceDefinition.Structure.Builder builder = SubstanceDefinition.Structure.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, techniqueElementIndex = 0, sourceDocumentElementIndex = 0, representationElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "stereochemistry":
                    position = checkElementOrder("stereochemistry", 2, position, false);
                    builder.stereochemistry(parseCodeableConcept("stereochemistry", reader, -1));
                    break;
                case "opticalActivity":
                    position = checkElementOrder("opticalActivity", 3, position, false);
                    builder.opticalActivity(parseCodeableConcept("opticalActivity", reader, -1));
                    break;
                case "molecularFormula":
                    position = checkElementOrder("molecularFormula", 4, position, false);
                    builder.molecularFormula(parseString("molecularFormula", reader, -1));
                    break;
                case "molecularFormulaByMoiety":
                    position = checkElementOrder("molecularFormulaByMoiety", 5, position, false);
                    builder.molecularFormulaByMoiety(parseString("molecularFormulaByMoiety", reader, -1));
                    break;
                case "molecularWeight":
                    position = checkElementOrder("molecularWeight", 6, position, false);
                    builder.molecularWeight(parseSubstanceDefinitionMolecularWeight("molecularWeight", reader, -1));
                    break;
                case "technique":
                    position = checkElementOrder("technique", 7, position, true);
                    builder.technique(parseCodeableConcept("technique", reader, techniqueElementIndex++));
                    break;
                case "sourceDocument":
                    position = checkElementOrder("sourceDocument", 8, position, true);
                    builder.sourceDocument(parseReference("sourceDocument", reader, sourceDocumentElementIndex++));
                    break;
                case "representation":
                    position = checkElementOrder("representation", 9, position, true);
                    builder.representation(parseSubstanceDefinitionStructureRepresentation("representation", reader, representationElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SubstanceDefinition.Structure.Representation parseSubstanceDefinitionStructureRepresentation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SubstanceDefinition.Structure.Representation.Builder builder = SubstanceDefinition.Structure.Representation.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "representation":
                    position = checkElementOrder("representation", 3, position, false);
                    builder.representation(parseString("representation", reader, -1));
                    break;
                case "format":
                    position = checkElementOrder("format", 4, position, false);
                    builder.format(parseCodeableConcept("format", reader, -1));
                    break;
                case "document":
                    position = checkElementOrder("document", 5, position, false);
                    builder.document(parseReference("document", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SupplyDelivery parseSupplyDelivery(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SupplyDelivery.Builder builder = SupplyDelivery.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, basedOnElementIndex = 0, partOfElementIndex = 0, receiverElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "basedOn":
                    position = checkElementOrder("basedOn", 9, position, true);
                    builder.basedOn(parseReference("basedOn", reader, basedOnElementIndex++));
                    break;
                case "partOf":
                    position = checkElementOrder("partOf", 10, position, true);
                    builder.partOf(parseReference("partOf", reader, partOfElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 11, position, false);
                    builder.status((SupplyDeliveryStatus) parseString(SupplyDeliveryStatus.builder(), "status", reader, -1));
                    break;
                case "patient":
                    position = checkElementOrder("patient", 12, position, false);
                    builder.patient(parseReference("patient", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 13, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "suppliedItem":
                    position = checkElementOrder("suppliedItem", 14, position, false);
                    builder.suppliedItem(parseSupplyDeliverySuppliedItem("suppliedItem", reader, -1));
                    break;
                case "occurrenceDateTime":
                    position = checkElementOrder("occurrence[x]", 15, position, false);
                    builder.occurrence(parseDateTime("occurrenceDateTime", reader, -1));
                    break;
                case "occurrencePeriod":
                    position = checkElementOrder("occurrence[x]", 15, position, false);
                    builder.occurrence(parsePeriod("occurrencePeriod", reader, -1));
                    break;
                case "occurrenceTiming":
                    position = checkElementOrder("occurrence[x]", 15, position, false);
                    builder.occurrence(parseTiming("occurrenceTiming", reader, -1));
                    break;
                case "supplier":
                    position = checkElementOrder("supplier", 16, position, false);
                    builder.supplier(parseReference("supplier", reader, -1));
                    break;
                case "destination":
                    position = checkElementOrder("destination", 17, position, false);
                    builder.destination(parseReference("destination", reader, -1));
                    break;
                case "receiver":
                    position = checkElementOrder("receiver", 18, position, true);
                    builder.receiver(parseReference("receiver", reader, receiverElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SupplyDelivery.SuppliedItem parseSupplyDeliverySuppliedItem(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SupplyDelivery.SuppliedItem.Builder builder = SupplyDelivery.SuppliedItem.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 2, position, false);
                    builder.quantity((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "quantity", reader, -1));
                    break;
                case "itemCodeableConcept":
                    position = checkElementOrder("item[x]", 3, position, false);
                    builder.item(parseCodeableConcept("itemCodeableConcept", reader, -1));
                    break;
                case "itemReference":
                    position = checkElementOrder("item[x]", 3, position, false);
                    builder.item(parseReference("itemReference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SupplyRequest parseSupplyRequest(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SupplyRequest.Builder builder = SupplyRequest.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, parameterElementIndex = 0, supplierElementIndex = 0, reasonCodeElementIndex = 0, reasonReferenceElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((SupplyRequestStatus) parseString(SupplyRequestStatus.builder(), "status", reader, -1));
                    break;
                case "category":
                    position = checkElementOrder("category", 10, position, false);
                    builder.category(parseCodeableConcept("category", reader, -1));
                    break;
                case "priority":
                    position = checkElementOrder("priority", 11, position, false);
                    builder.priority((RequestPriority) parseString(RequestPriority.builder(), "priority", reader, -1));
                    break;
                case "itemCodeableConcept":
                    position = checkElementOrder("item[x]", 12, position, false);
                    builder.item(parseCodeableConcept("itemCodeableConcept", reader, -1));
                    break;
                case "itemReference":
                    position = checkElementOrder("item[x]", 12, position, false);
                    builder.item(parseReference("itemReference", reader, -1));
                    break;
                case "quantity":
                    position = checkElementOrder("quantity", 13, position, false);
                    builder.quantity(parseQuantity("quantity", reader, -1));
                    break;
                case "parameter":
                    position = checkElementOrder("parameter", 14, position, true);
                    builder.parameter(parseSupplyRequestParameter("parameter", reader, parameterElementIndex++));
                    break;
                case "occurrenceDateTime":
                    position = checkElementOrder("occurrence[x]", 15, position, false);
                    builder.occurrence(parseDateTime("occurrenceDateTime", reader, -1));
                    break;
                case "occurrencePeriod":
                    position = checkElementOrder("occurrence[x]", 15, position, false);
                    builder.occurrence(parsePeriod("occurrencePeriod", reader, -1));
                    break;
                case "occurrenceTiming":
                    position = checkElementOrder("occurrence[x]", 15, position, false);
                    builder.occurrence(parseTiming("occurrenceTiming", reader, -1));
                    break;
                case "authoredOn":
                    position = checkElementOrder("authoredOn", 16, position, false);
                    builder.authoredOn(parseDateTime("authoredOn", reader, -1));
                    break;
                case "requester":
                    position = checkElementOrder("requester", 17, position, false);
                    builder.requester(parseReference("requester", reader, -1));
                    break;
                case "supplier":
                    position = checkElementOrder("supplier", 18, position, true);
                    builder.supplier(parseReference("supplier", reader, supplierElementIndex++));
                    break;
                case "reasonCode":
                    position = checkElementOrder("reasonCode", 19, position, true);
                    builder.reasonCode(parseCodeableConcept("reasonCode", reader, reasonCodeElementIndex++));
                    break;
                case "reasonReference":
                    position = checkElementOrder("reasonReference", 20, position, true);
                    builder.reasonReference(parseReference("reasonReference", reader, reasonReferenceElementIndex++));
                    break;
                case "deliverFrom":
                    position = checkElementOrder("deliverFrom", 21, position, false);
                    builder.deliverFrom(parseReference("deliverFrom", reader, -1));
                    break;
                case "deliverTo":
                    position = checkElementOrder("deliverTo", 22, position, false);
                    builder.deliverTo(parseReference("deliverTo", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private SupplyRequest.Parameter parseSupplyRequestParameter(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        SupplyRequest.Parameter.Builder builder = SupplyRequest.Parameter.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "valueCodeableConcept":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCodeableConcept("valueCodeableConcept", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueRange":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRange("valueRange", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Task parseTask(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Task.Builder builder = Task.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, basedOnElementIndex = 0, partOfElementIndex = 0, performerTypeElementIndex = 0, insuranceElementIndex = 0, noteElementIndex = 0, relevantHistoryElementIndex = 0, inputElementIndex = 0, outputElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "instantiatesCanonical":
                    position = checkElementOrder("instantiatesCanonical", 9, position, false);
                    builder.instantiatesCanonical((Canonical) parseUri(Canonical.builder(), "instantiatesCanonical", reader, -1));
                    break;
                case "instantiatesUri":
                    position = checkElementOrder("instantiatesUri", 10, position, false);
                    builder.instantiatesUri(parseUri("instantiatesUri", reader, -1));
                    break;
                case "basedOn":
                    position = checkElementOrder("basedOn", 11, position, true);
                    builder.basedOn(parseReference("basedOn", reader, basedOnElementIndex++));
                    break;
                case "groupIdentifier":
                    position = checkElementOrder("groupIdentifier", 12, position, false);
                    builder.groupIdentifier(parseIdentifier("groupIdentifier", reader, -1));
                    break;
                case "partOf":
                    position = checkElementOrder("partOf", 13, position, true);
                    builder.partOf(parseReference("partOf", reader, partOfElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 14, position, false);
                    builder.status((TaskStatus) parseString(TaskStatus.builder(), "status", reader, -1));
                    break;
                case "statusReason":
                    position = checkElementOrder("statusReason", 15, position, false);
                    builder.statusReason(parseCodeableConcept("statusReason", reader, -1));
                    break;
                case "businessStatus":
                    position = checkElementOrder("businessStatus", 16, position, false);
                    builder.businessStatus(parseCodeableConcept("businessStatus", reader, -1));
                    break;
                case "intent":
                    position = checkElementOrder("intent", 17, position, false);
                    builder.intent((TaskIntent) parseString(TaskIntent.builder(), "intent", reader, -1));
                    break;
                case "priority":
                    position = checkElementOrder("priority", 18, position, false);
                    builder.priority((TaskPriority) parseString(TaskPriority.builder(), "priority", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 19, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 20, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "focus":
                    position = checkElementOrder("focus", 21, position, false);
                    builder.focus(parseReference("focus", reader, -1));
                    break;
                case "for":
                    position = checkElementOrder("for", 22, position, false);
                    builder._for(parseReference("for", reader, -1));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 23, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "executionPeriod":
                    position = checkElementOrder("executionPeriod", 24, position, false);
                    builder.executionPeriod(parsePeriod("executionPeriod", reader, -1));
                    break;
                case "authoredOn":
                    position = checkElementOrder("authoredOn", 25, position, false);
                    builder.authoredOn(parseDateTime("authoredOn", reader, -1));
                    break;
                case "lastModified":
                    position = checkElementOrder("lastModified", 26, position, false);
                    builder.lastModified(parseDateTime("lastModified", reader, -1));
                    break;
                case "requester":
                    position = checkElementOrder("requester", 27, position, false);
                    builder.requester(parseReference("requester", reader, -1));
                    break;
                case "performerType":
                    position = checkElementOrder("performerType", 28, position, true);
                    builder.performerType(parseCodeableConcept("performerType", reader, performerTypeElementIndex++));
                    break;
                case "owner":
                    position = checkElementOrder("owner", 29, position, false);
                    builder.owner(parseReference("owner", reader, -1));
                    break;
                case "location":
                    position = checkElementOrder("location", 30, position, false);
                    builder.location(parseReference("location", reader, -1));
                    break;
                case "reasonCode":
                    position = checkElementOrder("reasonCode", 31, position, false);
                    builder.reasonCode(parseCodeableConcept("reasonCode", reader, -1));
                    break;
                case "reasonReference":
                    position = checkElementOrder("reasonReference", 32, position, false);
                    builder.reasonReference(parseReference("reasonReference", reader, -1));
                    break;
                case "insurance":
                    position = checkElementOrder("insurance", 33, position, true);
                    builder.insurance(parseReference("insurance", reader, insuranceElementIndex++));
                    break;
                case "note":
                    position = checkElementOrder("note", 34, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                case "relevantHistory":
                    position = checkElementOrder("relevantHistory", 35, position, true);
                    builder.relevantHistory(parseReference("relevantHistory", reader, relevantHistoryElementIndex++));
                    break;
                case "restriction":
                    position = checkElementOrder("restriction", 36, position, false);
                    builder.restriction(parseTaskRestriction("restriction", reader, -1));
                    break;
                case "input":
                    position = checkElementOrder("input", 37, position, true);
                    builder.input(parseTaskInput("input", reader, inputElementIndex++));
                    break;
                case "output":
                    position = checkElementOrder("output", 38, position, true);
                    builder.output(parseTaskOutput("output", reader, outputElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Task.Input parseTaskInput(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Task.Input.Builder builder = Task.Input.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "valueBase64Binary":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBase64Binary("valueBase64Binary", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueCanonical":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Canonical) parseUri(Canonical.builder(), "valueCanonical", reader, -1));
                    break;
                case "valueCode":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Code) parseString(Code.builder(), "valueCode", reader, -1));
                    break;
                case "valueDate":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDate("valueDate", reader, -1));
                    break;
                case "valueDateTime":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDateTime("valueDateTime", reader, -1));
                    break;
                case "valueDecimal":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDecimal("valueDecimal", reader, -1));
                    break;
                case "valueId":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Id) parseString(Id.builder(), "valueId", reader, -1));
                    break;
                case "valueInstant":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseInstant("valueInstant", reader, -1));
                    break;
                case "valueInteger":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseInteger("valueInteger", reader, -1));
                    break;
                case "valueMarkdown":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Markdown) parseString(Markdown.builder(), "valueMarkdown", reader, -1));
                    break;
                case "valueOid":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Oid) parseUri(Oid.builder(), "valueOid", reader, -1));
                    break;
                case "valuePositiveInt":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((PositiveInt) parseInteger(PositiveInt.builder(), "valuePositiveInt", reader, -1));
                    break;
                case "valueString":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseString("valueString", reader, -1));
                    break;
                case "valueTime":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseTime("valueTime", reader, -1));
                    break;
                case "valueUnsignedInt":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((UnsignedInt) parseInteger(UnsignedInt.builder(), "valueUnsignedInt", reader, -1));
                    break;
                case "valueUri":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseUri("valueUri", reader, -1));
                    break;
                case "valueUrl":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Url) parseUri(Url.builder(), "valueUrl", reader, -1));
                    break;
                case "valueUuid":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Uuid) parseUri(Uuid.builder(), "valueUuid", reader, -1));
                    break;
                case "valueAddress":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseAddress("valueAddress", reader, -1));
                    break;
                case "valueAge":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Age) parseQuantity(Age.builder(), "valueAge", reader, -1));
                    break;
                case "valueAnnotation":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseAnnotation("valueAnnotation", reader, -1));
                    break;
                case "valueAttachment":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseAttachment("valueAttachment", reader, -1));
                    break;
                case "valueCodeableConcept":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCodeableConcept("valueCodeableConcept", reader, -1));
                    break;
                case "valueCoding":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCoding("valueCoding", reader, -1));
                    break;
                case "valueContactPoint":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseContactPoint("valueContactPoint", reader, -1));
                    break;
                case "valueCount":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Count) parseQuantity(Count.builder(), "valueCount", reader, -1));
                    break;
                case "valueDistance":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Distance) parseQuantity(Distance.builder(), "valueDistance", reader, -1));
                    break;
                case "valueDuration":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Duration) parseQuantity(Duration.builder(), "valueDuration", reader, -1));
                    break;
                case "valueHumanName":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseHumanName("valueHumanName", reader, -1));
                    break;
                case "valueIdentifier":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseIdentifier("valueIdentifier", reader, -1));
                    break;
                case "valueMoney":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseMoney("valueMoney", reader, -1));
                    break;
                case "valuePeriod":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parsePeriod("valuePeriod", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueRange":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRange("valueRange", reader, -1));
                    break;
                case "valueRatio":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRatio("valueRatio", reader, -1));
                    break;
                case "valueReference":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseReference("valueReference", reader, -1));
                    break;
                case "valueSampledData":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseSampledData("valueSampledData", reader, -1));
                    break;
                case "valueSignature":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseSignature("valueSignature", reader, -1));
                    break;
                case "valueTiming":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseTiming("valueTiming", reader, -1));
                    break;
                case "valueContactDetail":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseContactDetail("valueContactDetail", reader, -1));
                    break;
                case "valueContributor":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseContributor("valueContributor", reader, -1));
                    break;
                case "valueDataRequirement":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDataRequirement("valueDataRequirement", reader, -1));
                    break;
                case "valueExpression":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseExpression("valueExpression", reader, -1));
                    break;
                case "valueParameterDefinition":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseParameterDefinition("valueParameterDefinition", reader, -1));
                    break;
                case "valueRelatedArtifact":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRelatedArtifact("valueRelatedArtifact", reader, -1));
                    break;
                case "valueTriggerDefinition":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseTriggerDefinition("valueTriggerDefinition", reader, -1));
                    break;
                case "valueUsageContext":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseUsageContext("valueUsageContext", reader, -1));
                    break;
                case "valueDosage":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDosage("valueDosage", reader, -1));
                    break;
                case "valueMeta":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseMeta("valueMeta", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Task.Output parseTaskOutput(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Task.Output.Builder builder = Task.Output.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCodeableConcept("type", reader, -1));
                    break;
                case "valueBase64Binary":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBase64Binary("valueBase64Binary", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueCanonical":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Canonical) parseUri(Canonical.builder(), "valueCanonical", reader, -1));
                    break;
                case "valueCode":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Code) parseString(Code.builder(), "valueCode", reader, -1));
                    break;
                case "valueDate":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDate("valueDate", reader, -1));
                    break;
                case "valueDateTime":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDateTime("valueDateTime", reader, -1));
                    break;
                case "valueDecimal":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDecimal("valueDecimal", reader, -1));
                    break;
                case "valueId":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Id) parseString(Id.builder(), "valueId", reader, -1));
                    break;
                case "valueInstant":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseInstant("valueInstant", reader, -1));
                    break;
                case "valueInteger":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseInteger("valueInteger", reader, -1));
                    break;
                case "valueMarkdown":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Markdown) parseString(Markdown.builder(), "valueMarkdown", reader, -1));
                    break;
                case "valueOid":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Oid) parseUri(Oid.builder(), "valueOid", reader, -1));
                    break;
                case "valuePositiveInt":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((PositiveInt) parseInteger(PositiveInt.builder(), "valuePositiveInt", reader, -1));
                    break;
                case "valueString":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseString("valueString", reader, -1));
                    break;
                case "valueTime":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseTime("valueTime", reader, -1));
                    break;
                case "valueUnsignedInt":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((UnsignedInt) parseInteger(UnsignedInt.builder(), "valueUnsignedInt", reader, -1));
                    break;
                case "valueUri":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseUri("valueUri", reader, -1));
                    break;
                case "valueUrl":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Url) parseUri(Url.builder(), "valueUrl", reader, -1));
                    break;
                case "valueUuid":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Uuid) parseUri(Uuid.builder(), "valueUuid", reader, -1));
                    break;
                case "valueAddress":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseAddress("valueAddress", reader, -1));
                    break;
                case "valueAge":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Age) parseQuantity(Age.builder(), "valueAge", reader, -1));
                    break;
                case "valueAnnotation":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseAnnotation("valueAnnotation", reader, -1));
                    break;
                case "valueAttachment":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseAttachment("valueAttachment", reader, -1));
                    break;
                case "valueCodeableConcept":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCodeableConcept("valueCodeableConcept", reader, -1));
                    break;
                case "valueCoding":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseCoding("valueCoding", reader, -1));
                    break;
                case "valueContactPoint":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseContactPoint("valueContactPoint", reader, -1));
                    break;
                case "valueCount":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Count) parseQuantity(Count.builder(), "valueCount", reader, -1));
                    break;
                case "valueDistance":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Distance) parseQuantity(Distance.builder(), "valueDistance", reader, -1));
                    break;
                case "valueDuration":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Duration) parseQuantity(Duration.builder(), "valueDuration", reader, -1));
                    break;
                case "valueHumanName":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseHumanName("valueHumanName", reader, -1));
                    break;
                case "valueIdentifier":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseIdentifier("valueIdentifier", reader, -1));
                    break;
                case "valueMoney":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseMoney("valueMoney", reader, -1));
                    break;
                case "valuePeriod":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parsePeriod("valuePeriod", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueRange":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRange("valueRange", reader, -1));
                    break;
                case "valueRatio":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRatio("valueRatio", reader, -1));
                    break;
                case "valueReference":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseReference("valueReference", reader, -1));
                    break;
                case "valueSampledData":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseSampledData("valueSampledData", reader, -1));
                    break;
                case "valueSignature":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseSignature("valueSignature", reader, -1));
                    break;
                case "valueTiming":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseTiming("valueTiming", reader, -1));
                    break;
                case "valueContactDetail":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseContactDetail("valueContactDetail", reader, -1));
                    break;
                case "valueContributor":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseContributor("valueContributor", reader, -1));
                    break;
                case "valueDataRequirement":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDataRequirement("valueDataRequirement", reader, -1));
                    break;
                case "valueExpression":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseExpression("valueExpression", reader, -1));
                    break;
                case "valueParameterDefinition":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseParameterDefinition("valueParameterDefinition", reader, -1));
                    break;
                case "valueRelatedArtifact":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseRelatedArtifact("valueRelatedArtifact", reader, -1));
                    break;
                case "valueTriggerDefinition":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseTriggerDefinition("valueTriggerDefinition", reader, -1));
                    break;
                case "valueUsageContext":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseUsageContext("valueUsageContext", reader, -1));
                    break;
                case "valueDosage":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDosage("valueDosage", reader, -1));
                    break;
                case "valueMeta":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseMeta("valueMeta", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Task.Restriction parseTaskRestriction(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Task.Restriction.Builder builder = Task.Restriction.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, recipientElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "repetitions":
                    position = checkElementOrder("repetitions", 2, position, false);
                    builder.repetitions((PositiveInt) parseInteger(PositiveInt.builder(), "repetitions", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 3, position, false);
                    builder.period(parsePeriod("period", reader, -1));
                    break;
                case "recipient":
                    position = checkElementOrder("recipient", 4, position, true);
                    builder.recipient(parseReference("recipient", reader, recipientElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TerminologyCapabilities parseTerminologyCapabilities(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TerminologyCapabilities.Builder builder = TerminologyCapabilities.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, contactElementIndex = 0, useContextElementIndex = 0, jurisdictionElementIndex = 0, codeSystemElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "version":
                    position = checkElementOrder("version", 9, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 10, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 11, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 12, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 13, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 14, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 15, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 16, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 17, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 18, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 19, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 20, position, false);
                    builder.purpose((Markdown) parseString(Markdown.builder(), "purpose", reader, -1));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 21, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                case "kind":
                    position = checkElementOrder("kind", 22, position, false);
                    builder.kind((CapabilityStatementKind) parseString(CapabilityStatementKind.builder(), "kind", reader, -1));
                    break;
                case "software":
                    position = checkElementOrder("software", 23, position, false);
                    builder.software(parseTerminologyCapabilitiesSoftware("software", reader, -1));
                    break;
                case "implementation":
                    position = checkElementOrder("implementation", 24, position, false);
                    builder.implementation(parseTerminologyCapabilitiesImplementation("implementation", reader, -1));
                    break;
                case "lockedDate":
                    position = checkElementOrder("lockedDate", 25, position, false);
                    builder.lockedDate(parseBoolean("lockedDate", reader, -1));
                    break;
                case "codeSystem":
                    position = checkElementOrder("codeSystem", 26, position, true);
                    builder.codeSystem(parseTerminologyCapabilitiesCodeSystem("codeSystem", reader, codeSystemElementIndex++));
                    break;
                case "expansion":
                    position = checkElementOrder("expansion", 27, position, false);
                    builder.expansion(parseTerminologyCapabilitiesExpansion("expansion", reader, -1));
                    break;
                case "codeSearch":
                    position = checkElementOrder("codeSearch", 28, position, false);
                    builder.codeSearch((CodeSearchSupport) parseString(CodeSearchSupport.builder(), "codeSearch", reader, -1));
                    break;
                case "validateCode":
                    position = checkElementOrder("validateCode", 29, position, false);
                    builder.validateCode(parseTerminologyCapabilitiesValidateCode("validateCode", reader, -1));
                    break;
                case "translation":
                    position = checkElementOrder("translation", 30, position, false);
                    builder.translation(parseTerminologyCapabilitiesTranslation("translation", reader, -1));
                    break;
                case "closure":
                    position = checkElementOrder("closure", 31, position, false);
                    builder.closure(parseTerminologyCapabilitiesClosure("closure", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TerminologyCapabilities.Closure parseTerminologyCapabilitiesClosure(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TerminologyCapabilities.Closure.Builder builder = TerminologyCapabilities.Closure.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "translation":
                    position = checkElementOrder("translation", 2, position, false);
                    builder.translation(parseBoolean("translation", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TerminologyCapabilities.CodeSystem parseTerminologyCapabilitiesCodeSystem(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TerminologyCapabilities.CodeSystem.Builder builder = TerminologyCapabilities.CodeSystem.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, versionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "uri":
                    position = checkElementOrder("uri", 2, position, false);
                    builder.uri((Canonical) parseUri(Canonical.builder(), "uri", reader, -1));
                    break;
                case "version":
                    position = checkElementOrder("version", 3, position, true);
                    builder.version(parseTerminologyCapabilitiesCodeSystemVersion("version", reader, versionElementIndex++));
                    break;
                case "subsumption":
                    position = checkElementOrder("subsumption", 4, position, false);
                    builder.subsumption(parseBoolean("subsumption", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TerminologyCapabilities.CodeSystem.Version parseTerminologyCapabilitiesCodeSystemVersion(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TerminologyCapabilities.CodeSystem.Version.Builder builder = TerminologyCapabilities.CodeSystem.Version.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, languageElementIndex = 0, filterElementIndex = 0, propertyElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code(parseString("code", reader, -1));
                    break;
                case "isDefault":
                    position = checkElementOrder("isDefault", 3, position, false);
                    builder.isDefault(parseBoolean("isDefault", reader, -1));
                    break;
                case "compositional":
                    position = checkElementOrder("compositional", 4, position, false);
                    builder.compositional(parseBoolean("compositional", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 5, position, true);
                    builder.language((Code) parseString(Code.builder(), "language", reader, languageElementIndex++));
                    break;
                case "filter":
                    position = checkElementOrder("filter", 6, position, true);
                    builder.filter(parseTerminologyCapabilitiesCodeSystemVersionFilter("filter", reader, filterElementIndex++));
                    break;
                case "property":
                    position = checkElementOrder("property", 7, position, true);
                    builder.property((Code) parseString(Code.builder(), "property", reader, propertyElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TerminologyCapabilities.CodeSystem.Version.Filter parseTerminologyCapabilitiesCodeSystemVersionFilter(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TerminologyCapabilities.CodeSystem.Version.Filter.Builder builder = TerminologyCapabilities.CodeSystem.Version.Filter.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, opElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code((Code) parseString(Code.builder(), "code", reader, -1));
                    break;
                case "op":
                    position = checkElementOrder("op", 3, position, true);
                    builder.op((Code) parseString(Code.builder(), "op", reader, opElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TerminologyCapabilities.Expansion parseTerminologyCapabilitiesExpansion(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TerminologyCapabilities.Expansion.Builder builder = TerminologyCapabilities.Expansion.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, parameterElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "hierarchical":
                    position = checkElementOrder("hierarchical", 2, position, false);
                    builder.hierarchical(parseBoolean("hierarchical", reader, -1));
                    break;
                case "paging":
                    position = checkElementOrder("paging", 3, position, false);
                    builder.paging(parseBoolean("paging", reader, -1));
                    break;
                case "incomplete":
                    position = checkElementOrder("incomplete", 4, position, false);
                    builder.incomplete(parseBoolean("incomplete", reader, -1));
                    break;
                case "parameter":
                    position = checkElementOrder("parameter", 5, position, true);
                    builder.parameter(parseTerminologyCapabilitiesExpansionParameter("parameter", reader, parameterElementIndex++));
                    break;
                case "textFilter":
                    position = checkElementOrder("textFilter", 6, position, false);
                    builder.textFilter((Markdown) parseString(Markdown.builder(), "textFilter", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TerminologyCapabilities.Expansion.Parameter parseTerminologyCapabilitiesExpansionParameter(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TerminologyCapabilities.Expansion.Parameter.Builder builder = TerminologyCapabilities.Expansion.Parameter.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name((Code) parseString(Code.builder(), "name", reader, -1));
                    break;
                case "documentation":
                    position = checkElementOrder("documentation", 3, position, false);
                    builder.documentation(parseString("documentation", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TerminologyCapabilities.Implementation parseTerminologyCapabilitiesImplementation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TerminologyCapabilities.Implementation.Builder builder = TerminologyCapabilities.Implementation.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 2, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "url":
                    position = checkElementOrder("url", 3, position, false);
                    builder.url((Url) parseUri(Url.builder(), "url", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TerminologyCapabilities.Software parseTerminologyCapabilitiesSoftware(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TerminologyCapabilities.Software.Builder builder = TerminologyCapabilities.Software.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "version":
                    position = checkElementOrder("version", 3, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TerminologyCapabilities.Translation parseTerminologyCapabilitiesTranslation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TerminologyCapabilities.Translation.Builder builder = TerminologyCapabilities.Translation.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "needsMap":
                    position = checkElementOrder("needsMap", 2, position, false);
                    builder.needsMap(parseBoolean("needsMap", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TerminologyCapabilities.ValidateCode parseTerminologyCapabilitiesValidateCode(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TerminologyCapabilities.ValidateCode.Builder builder = TerminologyCapabilities.ValidateCode.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "translations":
                    position = checkElementOrder("translations", 2, position, false);
                    builder.translations(parseBoolean("translations", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestReport parseTestReport(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestReport.Builder builder = TestReport.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, participantElementIndex = 0, testElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, false);
                    builder.identifier(parseIdentifier("identifier", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 9, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 10, position, false);
                    builder.status((TestReportStatus) parseString(TestReportStatus.builder(), "status", reader, -1));
                    break;
                case "testScript":
                    position = checkElementOrder("testScript", 11, position, false);
                    builder.testScript(parseReference("testScript", reader, -1));
                    break;
                case "result":
                    position = checkElementOrder("result", 12, position, false);
                    builder.result((TestReportResult) parseString(TestReportResult.builder(), "result", reader, -1));
                    break;
                case "score":
                    position = checkElementOrder("score", 13, position, false);
                    builder.score(parseDecimal("score", reader, -1));
                    break;
                case "tester":
                    position = checkElementOrder("tester", 14, position, false);
                    builder.tester(parseString("tester", reader, -1));
                    break;
                case "issued":
                    position = checkElementOrder("issued", 15, position, false);
                    builder.issued(parseDateTime("issued", reader, -1));
                    break;
                case "participant":
                    position = checkElementOrder("participant", 16, position, true);
                    builder.participant(parseTestReportParticipant("participant", reader, participantElementIndex++));
                    break;
                case "setup":
                    position = checkElementOrder("setup", 17, position, false);
                    builder.setup(parseTestReportSetup("setup", reader, -1));
                    break;
                case "test":
                    position = checkElementOrder("test", 18, position, true);
                    builder.test(parseTestReportTest("test", reader, testElementIndex++));
                    break;
                case "teardown":
                    position = checkElementOrder("teardown", 19, position, false);
                    builder.teardown(parseTestReportTeardown("teardown", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestReport.Participant parseTestReportParticipant(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestReport.Participant.Builder builder = TestReport.Participant.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type((TestReportParticipantType) parseString(TestReportParticipantType.builder(), "type", reader, -1));
                    break;
                case "uri":
                    position = checkElementOrder("uri", 3, position, false);
                    builder.uri(parseUri("uri", reader, -1));
                    break;
                case "display":
                    position = checkElementOrder("display", 4, position, false);
                    builder.display(parseString("display", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestReport.Setup parseTestReportSetup(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestReport.Setup.Builder builder = TestReport.Setup.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, actionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "action":
                    position = checkElementOrder("action", 2, position, true);
                    builder.action(parseTestReportSetupAction("action", reader, actionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestReport.Setup.Action parseTestReportSetupAction(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestReport.Setup.Action.Builder builder = TestReport.Setup.Action.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "operation":
                    position = checkElementOrder("operation", 2, position, false);
                    builder.operation(parseTestReportSetupActionOperation("operation", reader, -1));
                    break;
                case "assert":
                    position = checkElementOrder("assert", 3, position, false);
                    builder._assert(parseTestReportSetupActionAssert("assert", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestReport.Setup.Action.Assert parseTestReportSetupActionAssert(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestReport.Setup.Action.Assert.Builder builder = TestReport.Setup.Action.Assert.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "result":
                    position = checkElementOrder("result", 2, position, false);
                    builder.result((TestReportActionResult) parseString(TestReportActionResult.builder(), "result", reader, -1));
                    break;
                case "message":
                    position = checkElementOrder("message", 3, position, false);
                    builder.message((Markdown) parseString(Markdown.builder(), "message", reader, -1));
                    break;
                case "detail":
                    position = checkElementOrder("detail", 4, position, false);
                    builder.detail(parseString("detail", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestReport.Setup.Action.Operation parseTestReportSetupActionOperation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestReport.Setup.Action.Operation.Builder builder = TestReport.Setup.Action.Operation.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "result":
                    position = checkElementOrder("result", 2, position, false);
                    builder.result((TestReportActionResult) parseString(TestReportActionResult.builder(), "result", reader, -1));
                    break;
                case "message":
                    position = checkElementOrder("message", 3, position, false);
                    builder.message((Markdown) parseString(Markdown.builder(), "message", reader, -1));
                    break;
                case "detail":
                    position = checkElementOrder("detail", 4, position, false);
                    builder.detail(parseUri("detail", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestReport.Teardown parseTestReportTeardown(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestReport.Teardown.Builder builder = TestReport.Teardown.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, actionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "action":
                    position = checkElementOrder("action", 2, position, true);
                    builder.action(parseTestReportTeardownAction("action", reader, actionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestReport.Teardown.Action parseTestReportTeardownAction(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestReport.Teardown.Action.Builder builder = TestReport.Teardown.Action.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "operation":
                    position = checkElementOrder("operation", 2, position, false);
                    builder.operation(parseTestReportSetupActionOperation("operation", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestReport.Test parseTestReportTest(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestReport.Test.Builder builder = TestReport.Test.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, actionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 3, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "action":
                    position = checkElementOrder("action", 4, position, true);
                    builder.action(parseTestReportTestAction("action", reader, actionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestReport.Test.Action parseTestReportTestAction(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestReport.Test.Action.Builder builder = TestReport.Test.Action.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "operation":
                    position = checkElementOrder("operation", 2, position, false);
                    builder.operation(parseTestReportSetupActionOperation("operation", reader, -1));
                    break;
                case "assert":
                    position = checkElementOrder("assert", 3, position, false);
                    builder._assert(parseTestReportSetupActionAssert("assert", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestScript parseTestScript(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestScript.Builder builder = TestScript.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, contactElementIndex = 0, useContextElementIndex = 0, jurisdictionElementIndex = 0, originElementIndex = 0, destinationElementIndex = 0, fixtureElementIndex = 0, profileElementIndex = 0, variableElementIndex = 0, testElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, false);
                    builder.identifier(parseIdentifier("identifier", reader, -1));
                    break;
                case "version":
                    position = checkElementOrder("version", 10, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 11, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 12, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 13, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 14, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 15, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 16, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 17, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 18, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 19, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 20, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 21, position, false);
                    builder.purpose((Markdown) parseString(Markdown.builder(), "purpose", reader, -1));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 22, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                case "origin":
                    position = checkElementOrder("origin", 23, position, true);
                    builder.origin(parseTestScriptOrigin("origin", reader, originElementIndex++));
                    break;
                case "destination":
                    position = checkElementOrder("destination", 24, position, true);
                    builder.destination(parseTestScriptDestination("destination", reader, destinationElementIndex++));
                    break;
                case "metadata":
                    position = checkElementOrder("metadata", 25, position, false);
                    builder.metadata(parseTestScriptMetadata("metadata", reader, -1));
                    break;
                case "fixture":
                    position = checkElementOrder("fixture", 26, position, true);
                    builder.fixture(parseTestScriptFixture("fixture", reader, fixtureElementIndex++));
                    break;
                case "profile":
                    position = checkElementOrder("profile", 27, position, true);
                    builder.profile(parseReference("profile", reader, profileElementIndex++));
                    break;
                case "variable":
                    position = checkElementOrder("variable", 28, position, true);
                    builder.variable(parseTestScriptVariable("variable", reader, variableElementIndex++));
                    break;
                case "setup":
                    position = checkElementOrder("setup", 29, position, false);
                    builder.setup(parseTestScriptSetup("setup", reader, -1));
                    break;
                case "test":
                    position = checkElementOrder("test", 30, position, true);
                    builder.test(parseTestScriptTest("test", reader, testElementIndex++));
                    break;
                case "teardown":
                    position = checkElementOrder("teardown", 31, position, false);
                    builder.teardown(parseTestScriptTeardown("teardown", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestScript.Destination parseTestScriptDestination(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestScript.Destination.Builder builder = TestScript.Destination.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "index":
                    position = checkElementOrder("index", 2, position, false);
                    builder.index(parseInteger("index", reader, -1));
                    break;
                case "profile":
                    position = checkElementOrder("profile", 3, position, false);
                    builder.profile(parseCoding("profile", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestScript.Fixture parseTestScriptFixture(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestScript.Fixture.Builder builder = TestScript.Fixture.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "autocreate":
                    position = checkElementOrder("autocreate", 2, position, false);
                    builder.autocreate(parseBoolean("autocreate", reader, -1));
                    break;
                case "autodelete":
                    position = checkElementOrder("autodelete", 3, position, false);
                    builder.autodelete(parseBoolean("autodelete", reader, -1));
                    break;
                case "resource":
                    position = checkElementOrder("resource", 4, position, false);
                    builder.resource(parseReference("resource", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestScript.Metadata parseTestScriptMetadata(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestScript.Metadata.Builder builder = TestScript.Metadata.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, linkElementIndex = 0, capabilityElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "link":
                    position = checkElementOrder("link", 2, position, true);
                    builder.link(parseTestScriptMetadataLink("link", reader, linkElementIndex++));
                    break;
                case "capability":
                    position = checkElementOrder("capability", 3, position, true);
                    builder.capability(parseTestScriptMetadataCapability("capability", reader, capabilityElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestScript.Metadata.Capability parseTestScriptMetadataCapability(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestScript.Metadata.Capability.Builder builder = TestScript.Metadata.Capability.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, originElementIndex = 0, linkElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "required":
                    position = checkElementOrder("required", 2, position, false);
                    builder.required(parseBoolean("required", reader, -1));
                    break;
                case "validated":
                    position = checkElementOrder("validated", 3, position, false);
                    builder.validated(parseBoolean("validated", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 4, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "origin":
                    position = checkElementOrder("origin", 5, position, true);
                    builder.origin(parseInteger("origin", reader, originElementIndex++));
                    break;
                case "destination":
                    position = checkElementOrder("destination", 6, position, false);
                    builder.destination(parseInteger("destination", reader, -1));
                    break;
                case "link":
                    position = checkElementOrder("link", 7, position, true);
                    builder.link(parseUri("link", reader, linkElementIndex++));
                    break;
                case "capabilities":
                    position = checkElementOrder("capabilities", 8, position, false);
                    builder.capabilities((Canonical) parseUri(Canonical.builder(), "capabilities", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestScript.Metadata.Link parseTestScriptMetadataLink(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestScript.Metadata.Link.Builder builder = TestScript.Metadata.Link.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 2, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 3, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestScript.Origin parseTestScriptOrigin(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestScript.Origin.Builder builder = TestScript.Origin.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "index":
                    position = checkElementOrder("index", 2, position, false);
                    builder.index(parseInteger("index", reader, -1));
                    break;
                case "profile":
                    position = checkElementOrder("profile", 3, position, false);
                    builder.profile(parseCoding("profile", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestScript.Setup parseTestScriptSetup(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestScript.Setup.Builder builder = TestScript.Setup.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, actionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "action":
                    position = checkElementOrder("action", 2, position, true);
                    builder.action(parseTestScriptSetupAction("action", reader, actionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestScript.Setup.Action parseTestScriptSetupAction(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestScript.Setup.Action.Builder builder = TestScript.Setup.Action.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "operation":
                    position = checkElementOrder("operation", 2, position, false);
                    builder.operation(parseTestScriptSetupActionOperation("operation", reader, -1));
                    break;
                case "assert":
                    position = checkElementOrder("assert", 3, position, false);
                    builder._assert(parseTestScriptSetupActionAssert("assert", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestScript.Setup.Action.Assert parseTestScriptSetupActionAssert(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestScript.Setup.Action.Assert.Builder builder = TestScript.Setup.Action.Assert.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "label":
                    position = checkElementOrder("label", 2, position, false);
                    builder.label(parseString("label", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 3, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "direction":
                    position = checkElementOrder("direction", 4, position, false);
                    builder.direction((AssertionDirectionType) parseString(AssertionDirectionType.builder(), "direction", reader, -1));
                    break;
                case "compareToSourceId":
                    position = checkElementOrder("compareToSourceId", 5, position, false);
                    builder.compareToSourceId(parseString("compareToSourceId", reader, -1));
                    break;
                case "compareToSourceExpression":
                    position = checkElementOrder("compareToSourceExpression", 6, position, false);
                    builder.compareToSourceExpression(parseString("compareToSourceExpression", reader, -1));
                    break;
                case "compareToSourcePath":
                    position = checkElementOrder("compareToSourcePath", 7, position, false);
                    builder.compareToSourcePath(parseString("compareToSourcePath", reader, -1));
                    break;
                case "contentType":
                    position = checkElementOrder("contentType", 8, position, false);
                    builder.contentType((Code) parseString(Code.builder(), "contentType", reader, -1));
                    break;
                case "expression":
                    position = checkElementOrder("expression", 9, position, false);
                    builder.expression(parseString("expression", reader, -1));
                    break;
                case "headerField":
                    position = checkElementOrder("headerField", 10, position, false);
                    builder.headerField(parseString("headerField", reader, -1));
                    break;
                case "minimumId":
                    position = checkElementOrder("minimumId", 11, position, false);
                    builder.minimumId(parseString("minimumId", reader, -1));
                    break;
                case "navigationLinks":
                    position = checkElementOrder("navigationLinks", 12, position, false);
                    builder.navigationLinks(parseBoolean("navigationLinks", reader, -1));
                    break;
                case "operator":
                    position = checkElementOrder("operator", 13, position, false);
                    builder.operator((AssertionOperatorType) parseString(AssertionOperatorType.builder(), "operator", reader, -1));
                    break;
                case "path":
                    position = checkElementOrder("path", 14, position, false);
                    builder.path(parseString("path", reader, -1));
                    break;
                case "requestMethod":
                    position = checkElementOrder("requestMethod", 15, position, false);
                    builder.requestMethod((TestScriptRequestMethodCode) parseString(TestScriptRequestMethodCode.builder(), "requestMethod", reader, -1));
                    break;
                case "requestURL":
                    position = checkElementOrder("requestURL", 16, position, false);
                    builder.requestURL(parseString("requestURL", reader, -1));
                    break;
                case "resource":
                    position = checkElementOrder("resource", 17, position, false);
                    builder.resource((FHIRDefinedType) parseString(FHIRDefinedType.builder(), "resource", reader, -1));
                    break;
                case "response":
                    position = checkElementOrder("response", 18, position, false);
                    builder.response((AssertionResponseTypes) parseString(AssertionResponseTypes.builder(), "response", reader, -1));
                    break;
                case "responseCode":
                    position = checkElementOrder("responseCode", 19, position, false);
                    builder.responseCode(parseString("responseCode", reader, -1));
                    break;
                case "sourceId":
                    position = checkElementOrder("sourceId", 20, position, false);
                    builder.sourceId((Id) parseString(Id.builder(), "sourceId", reader, -1));
                    break;
                case "validateProfileId":
                    position = checkElementOrder("validateProfileId", 21, position, false);
                    builder.validateProfileId((Id) parseString(Id.builder(), "validateProfileId", reader, -1));
                    break;
                case "value":
                    position = checkElementOrder("value", 22, position, false);
                    builder.value(parseString("value", reader, -1));
                    break;
                case "warningOnly":
                    position = checkElementOrder("warningOnly", 23, position, false);
                    builder.warningOnly(parseBoolean("warningOnly", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestScript.Setup.Action.Operation parseTestScriptSetupActionOperation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestScript.Setup.Action.Operation.Builder builder = TestScript.Setup.Action.Operation.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, requestHeaderElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 2, position, false);
                    builder.type(parseCoding("type", reader, -1));
                    break;
                case "resource":
                    position = checkElementOrder("resource", 3, position, false);
                    builder.resource((FHIRDefinedType) parseString(FHIRDefinedType.builder(), "resource", reader, -1));
                    break;
                case "label":
                    position = checkElementOrder("label", 4, position, false);
                    builder.label(parseString("label", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 5, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "accept":
                    position = checkElementOrder("accept", 6, position, false);
                    builder.accept((Code) parseString(Code.builder(), "accept", reader, -1));
                    break;
                case "contentType":
                    position = checkElementOrder("contentType", 7, position, false);
                    builder.contentType((Code) parseString(Code.builder(), "contentType", reader, -1));
                    break;
                case "destination":
                    position = checkElementOrder("destination", 8, position, false);
                    builder.destination(parseInteger("destination", reader, -1));
                    break;
                case "encodeRequestUrl":
                    position = checkElementOrder("encodeRequestUrl", 9, position, false);
                    builder.encodeRequestUrl(parseBoolean("encodeRequestUrl", reader, -1));
                    break;
                case "method":
                    position = checkElementOrder("method", 10, position, false);
                    builder.method((TestScriptRequestMethodCode) parseString(TestScriptRequestMethodCode.builder(), "method", reader, -1));
                    break;
                case "origin":
                    position = checkElementOrder("origin", 11, position, false);
                    builder.origin(parseInteger("origin", reader, -1));
                    break;
                case "params":
                    position = checkElementOrder("params", 12, position, false);
                    builder.params(parseString("params", reader, -1));
                    break;
                case "requestHeader":
                    position = checkElementOrder("requestHeader", 13, position, true);
                    builder.requestHeader(parseTestScriptSetupActionOperationRequestHeader("requestHeader", reader, requestHeaderElementIndex++));
                    break;
                case "requestId":
                    position = checkElementOrder("requestId", 14, position, false);
                    builder.requestId((Id) parseString(Id.builder(), "requestId", reader, -1));
                    break;
                case "responseId":
                    position = checkElementOrder("responseId", 15, position, false);
                    builder.responseId((Id) parseString(Id.builder(), "responseId", reader, -1));
                    break;
                case "sourceId":
                    position = checkElementOrder("sourceId", 16, position, false);
                    builder.sourceId((Id) parseString(Id.builder(), "sourceId", reader, -1));
                    break;
                case "targetId":
                    position = checkElementOrder("targetId", 17, position, false);
                    builder.targetId((Id) parseString(Id.builder(), "targetId", reader, -1));
                    break;
                case "url":
                    position = checkElementOrder("url", 18, position, false);
                    builder.url(parseString("url", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestScript.Setup.Action.Operation.RequestHeader parseTestScriptSetupActionOperationRequestHeader(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestScript.Setup.Action.Operation.RequestHeader.Builder builder = TestScript.Setup.Action.Operation.RequestHeader.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "field":
                    position = checkElementOrder("field", 2, position, false);
                    builder.field(parseString("field", reader, -1));
                    break;
                case "value":
                    position = checkElementOrder("value", 3, position, false);
                    builder.value(parseString("value", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestScript.Teardown parseTestScriptTeardown(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestScript.Teardown.Builder builder = TestScript.Teardown.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, actionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "action":
                    position = checkElementOrder("action", 2, position, true);
                    builder.action(parseTestScriptTeardownAction("action", reader, actionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestScript.Teardown.Action parseTestScriptTeardownAction(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestScript.Teardown.Action.Builder builder = TestScript.Teardown.Action.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "operation":
                    position = checkElementOrder("operation", 2, position, false);
                    builder.operation(parseTestScriptSetupActionOperation("operation", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestScript.Test parseTestScriptTest(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestScript.Test.Builder builder = TestScript.Test.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, actionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 3, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "action":
                    position = checkElementOrder("action", 4, position, true);
                    builder.action(parseTestScriptTestAction("action", reader, actionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestScript.Test.Action parseTestScriptTestAction(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestScript.Test.Action.Builder builder = TestScript.Test.Action.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "operation":
                    position = checkElementOrder("operation", 2, position, false);
                    builder.operation(parseTestScriptSetupActionOperation("operation", reader, -1));
                    break;
                case "assert":
                    position = checkElementOrder("assert", 3, position, false);
                    builder._assert(parseTestScriptSetupActionAssert("assert", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TestScript.Variable parseTestScriptVariable(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TestScript.Variable.Builder builder = TestScript.Variable.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "defaultValue":
                    position = checkElementOrder("defaultValue", 3, position, false);
                    builder.defaultValue(parseString("defaultValue", reader, -1));
                    break;
                case "description":
                    position = checkElementOrder("description", 4, position, false);
                    builder.description(parseString("description", reader, -1));
                    break;
                case "expression":
                    position = checkElementOrder("expression", 5, position, false);
                    builder.expression(parseString("expression", reader, -1));
                    break;
                case "headerField":
                    position = checkElementOrder("headerField", 6, position, false);
                    builder.headerField(parseString("headerField", reader, -1));
                    break;
                case "hint":
                    position = checkElementOrder("hint", 7, position, false);
                    builder.hint(parseString("hint", reader, -1));
                    break;
                case "path":
                    position = checkElementOrder("path", 8, position, false);
                    builder.path(parseString("path", reader, -1));
                    break;
                case "sourceId":
                    position = checkElementOrder("sourceId", 9, position, false);
                    builder.sourceId((Id) parseString(Id.builder(), "sourceId", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Time parseTime(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Time.Builder builder = Time.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        java.lang.String value = reader.getAttributeValue(null, "value");
        if (value != null) {
            builder.value(value);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Timing parseTiming(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Timing.Builder builder = Timing.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, eventElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "event":
                    position = checkElementOrder("event", 2, position, true);
                    builder.event(parseDateTime("event", reader, eventElementIndex++));
                    break;
                case "repeat":
                    position = checkElementOrder("repeat", 3, position, false);
                    builder.repeat(parseTimingRepeat("repeat", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 4, position, false);
                    builder.code(parseCodeableConcept("code", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Timing.Repeat parseTimingRepeat(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Timing.Repeat.Builder builder = Timing.Repeat.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, dayOfWeekElementIndex = 0, timeOfDayElementIndex = 0, whenElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "boundsDuration":
                    position = checkElementOrder("bounds[x]", 2, position, false);
                    builder.bounds((Duration) parseQuantity(Duration.builder(), "boundsDuration", reader, -1));
                    break;
                case "boundsRange":
                    position = checkElementOrder("bounds[x]", 2, position, false);
                    builder.bounds(parseRange("boundsRange", reader, -1));
                    break;
                case "boundsPeriod":
                    position = checkElementOrder("bounds[x]", 2, position, false);
                    builder.bounds(parsePeriod("boundsPeriod", reader, -1));
                    break;
                case "count":
                    position = checkElementOrder("count", 3, position, false);
                    builder.count((PositiveInt) parseInteger(PositiveInt.builder(), "count", reader, -1));
                    break;
                case "countMax":
                    position = checkElementOrder("countMax", 4, position, false);
                    builder.countMax((PositiveInt) parseInteger(PositiveInt.builder(), "countMax", reader, -1));
                    break;
                case "duration":
                    position = checkElementOrder("duration", 5, position, false);
                    builder.duration(parseDecimal("duration", reader, -1));
                    break;
                case "durationMax":
                    position = checkElementOrder("durationMax", 6, position, false);
                    builder.durationMax(parseDecimal("durationMax", reader, -1));
                    break;
                case "durationUnit":
                    position = checkElementOrder("durationUnit", 7, position, false);
                    builder.durationUnit((UnitsOfTime) parseString(UnitsOfTime.builder(), "durationUnit", reader, -1));
                    break;
                case "frequency":
                    position = checkElementOrder("frequency", 8, position, false);
                    builder.frequency((PositiveInt) parseInteger(PositiveInt.builder(), "frequency", reader, -1));
                    break;
                case "frequencyMax":
                    position = checkElementOrder("frequencyMax", 9, position, false);
                    builder.frequencyMax((PositiveInt) parseInteger(PositiveInt.builder(), "frequencyMax", reader, -1));
                    break;
                case "period":
                    position = checkElementOrder("period", 10, position, false);
                    builder.period(parseDecimal("period", reader, -1));
                    break;
                case "periodMax":
                    position = checkElementOrder("periodMax", 11, position, false);
                    builder.periodMax(parseDecimal("periodMax", reader, -1));
                    break;
                case "periodUnit":
                    position = checkElementOrder("periodUnit", 12, position, false);
                    builder.periodUnit((UnitsOfTime) parseString(UnitsOfTime.builder(), "periodUnit", reader, -1));
                    break;
                case "dayOfWeek":
                    position = checkElementOrder("dayOfWeek", 13, position, true);
                    builder.dayOfWeek((DayOfWeek) parseString(DayOfWeek.builder(), "dayOfWeek", reader, dayOfWeekElementIndex++));
                    break;
                case "timeOfDay":
                    position = checkElementOrder("timeOfDay", 14, position, true);
                    builder.timeOfDay(parseTime("timeOfDay", reader, timeOfDayElementIndex++));
                    break;
                case "when":
                    position = checkElementOrder("when", 15, position, true);
                    builder.when((EventTiming) parseString(EventTiming.builder(), "when", reader, whenElementIndex++));
                    break;
                case "offset":
                    position = checkElementOrder("offset", 16, position, false);
                    builder.offset((UnsignedInt) parseInteger(UnsignedInt.builder(), "offset", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private TriggerDefinition parseTriggerDefinition(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        TriggerDefinition.Builder builder = TriggerDefinition.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, dataElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "type":
                    position = checkElementOrder("type", 1, position, false);
                    builder.type((TriggerType) parseString(TriggerType.builder(), "type", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "timingTiming":
                    position = checkElementOrder("timing[x]", 3, position, false);
                    builder.timing(parseTiming("timingTiming", reader, -1));
                    break;
                case "timingReference":
                    position = checkElementOrder("timing[x]", 3, position, false);
                    builder.timing(parseReference("timingReference", reader, -1));
                    break;
                case "timingDate":
                    position = checkElementOrder("timing[x]", 3, position, false);
                    builder.timing(parseDate("timingDate", reader, -1));
                    break;
                case "timingDateTime":
                    position = checkElementOrder("timing[x]", 3, position, false);
                    builder.timing(parseDateTime("timingDateTime", reader, -1));
                    break;
                case "data":
                    position = checkElementOrder("data", 4, position, true);
                    builder.data(parseDataRequirement("data", reader, dataElementIndex++));
                    break;
                case "condition":
                    position = checkElementOrder("condition", 5, position, false);
                    builder.condition(parseExpression("condition", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Uri parseUri(Uri.Builder builder, java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        java.lang.String value = reader.getAttributeValue(null, "value");
        if (value != null) {
            builder.value(value);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Uri parseUri(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        return parseUri(Uri.builder(), elementName, reader, elementIndex);
    }

    private UsageContext parseUsageContext(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        UsageContext.Builder builder = UsageContext.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 1, position, false);
                    builder.code(parseCoding("code", reader, -1));
                    break;
                case "valueCodeableConcept":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseCodeableConcept("valueCodeableConcept", reader, -1));
                    break;
                case "valueQuantity":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseQuantity("valueQuantity", reader, -1));
                    break;
                case "valueRange":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseRange("valueRange", reader, -1));
                    break;
                case "valueReference":
                    position = checkElementOrder("value[x]", 2, position, false);
                    builder.value(parseReference("valueReference", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ValueSet parseValueSet(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ValueSet.Builder builder = ValueSet.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, contactElementIndex = 0, useContextElementIndex = 0, jurisdictionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "url":
                    position = checkElementOrder("url", 8, position, false);
                    builder.url(parseUri("url", reader, -1));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 9, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "version":
                    position = checkElementOrder("version", 10, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "name":
                    position = checkElementOrder("name", 11, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "title":
                    position = checkElementOrder("title", 12, position, false);
                    builder.title(parseString("title", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 13, position, false);
                    builder.status((PublicationStatus) parseString(PublicationStatus.builder(), "status", reader, -1));
                    break;
                case "experimental":
                    position = checkElementOrder("experimental", 14, position, false);
                    builder.experimental(parseBoolean("experimental", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 15, position, false);
                    builder.date(parseDateTime("date", reader, -1));
                    break;
                case "publisher":
                    position = checkElementOrder("publisher", 16, position, false);
                    builder.publisher(parseString("publisher", reader, -1));
                    break;
                case "contact":
                    position = checkElementOrder("contact", 17, position, true);
                    builder.contact(parseContactDetail("contact", reader, contactElementIndex++));
                    break;
                case "description":
                    position = checkElementOrder("description", 18, position, false);
                    builder.description((Markdown) parseString(Markdown.builder(), "description", reader, -1));
                    break;
                case "useContext":
                    position = checkElementOrder("useContext", 19, position, true);
                    builder.useContext(parseUsageContext("useContext", reader, useContextElementIndex++));
                    break;
                case "jurisdiction":
                    position = checkElementOrder("jurisdiction", 20, position, true);
                    builder.jurisdiction(parseCodeableConcept("jurisdiction", reader, jurisdictionElementIndex++));
                    break;
                case "immutable":
                    position = checkElementOrder("immutable", 21, position, false);
                    builder.immutable(parseBoolean("immutable", reader, -1));
                    break;
                case "purpose":
                    position = checkElementOrder("purpose", 22, position, false);
                    builder.purpose((Markdown) parseString(Markdown.builder(), "purpose", reader, -1));
                    break;
                case "copyright":
                    position = checkElementOrder("copyright", 23, position, false);
                    builder.copyright((Markdown) parseString(Markdown.builder(), "copyright", reader, -1));
                    break;
                case "compose":
                    position = checkElementOrder("compose", 24, position, false);
                    builder.compose(parseValueSetCompose("compose", reader, -1));
                    break;
                case "expansion":
                    position = checkElementOrder("expansion", 25, position, false);
                    builder.expansion(parseValueSetExpansion("expansion", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ValueSet.Compose parseValueSetCompose(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ValueSet.Compose.Builder builder = ValueSet.Compose.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, includeElementIndex = 0, excludeElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "lockedDate":
                    position = checkElementOrder("lockedDate", 2, position, false);
                    builder.lockedDate(parseDate("lockedDate", reader, -1));
                    break;
                case "inactive":
                    position = checkElementOrder("inactive", 3, position, false);
                    builder.inactive(parseBoolean("inactive", reader, -1));
                    break;
                case "include":
                    position = checkElementOrder("include", 4, position, true);
                    builder.include(parseValueSetComposeInclude("include", reader, includeElementIndex++));
                    break;
                case "exclude":
                    position = checkElementOrder("exclude", 5, position, true);
                    builder.exclude(parseValueSetComposeInclude("exclude", reader, excludeElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ValueSet.Compose.Include parseValueSetComposeInclude(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ValueSet.Compose.Include.Builder builder = ValueSet.Compose.Include.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, conceptElementIndex = 0, filterElementIndex = 0, valueSetElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "system":
                    position = checkElementOrder("system", 2, position, false);
                    builder.system(parseUri("system", reader, -1));
                    break;
                case "version":
                    position = checkElementOrder("version", 3, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "concept":
                    position = checkElementOrder("concept", 4, position, true);
                    builder.concept(parseValueSetComposeIncludeConcept("concept", reader, conceptElementIndex++));
                    break;
                case "filter":
                    position = checkElementOrder("filter", 5, position, true);
                    builder.filter(parseValueSetComposeIncludeFilter("filter", reader, filterElementIndex++));
                    break;
                case "valueSet":
                    position = checkElementOrder("valueSet", 6, position, true);
                    builder.valueSet((Canonical) parseUri(Canonical.builder(), "valueSet", reader, valueSetElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ValueSet.Compose.Include.Concept parseValueSetComposeIncludeConcept(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ValueSet.Compose.Include.Concept.Builder builder = ValueSet.Compose.Include.Concept.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, designationElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "code":
                    position = checkElementOrder("code", 2, position, false);
                    builder.code((Code) parseString(Code.builder(), "code", reader, -1));
                    break;
                case "display":
                    position = checkElementOrder("display", 3, position, false);
                    builder.display(parseString("display", reader, -1));
                    break;
                case "designation":
                    position = checkElementOrder("designation", 4, position, true);
                    builder.designation(parseValueSetComposeIncludeConceptDesignation("designation", reader, designationElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ValueSet.Compose.Include.Concept.Designation parseValueSetComposeIncludeConceptDesignation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ValueSet.Compose.Include.Concept.Designation.Builder builder = ValueSet.Compose.Include.Concept.Designation.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "language":
                    position = checkElementOrder("language", 2, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "use":
                    position = checkElementOrder("use", 3, position, false);
                    builder.use(parseCoding("use", reader, -1));
                    break;
                case "value":
                    position = checkElementOrder("value", 4, position, false);
                    builder.value(parseString("value", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ValueSet.Compose.Include.Filter parseValueSetComposeIncludeFilter(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ValueSet.Compose.Include.Filter.Builder builder = ValueSet.Compose.Include.Filter.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "property":
                    position = checkElementOrder("property", 2, position, false);
                    builder.property((Code) parseString(Code.builder(), "property", reader, -1));
                    break;
                case "op":
                    position = checkElementOrder("op", 3, position, false);
                    builder.op((FilterOperator) parseString(FilterOperator.builder(), "op", reader, -1));
                    break;
                case "value":
                    position = checkElementOrder("value", 4, position, false);
                    builder.value(parseString("value", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ValueSet.Expansion parseValueSetExpansion(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ValueSet.Expansion.Builder builder = ValueSet.Expansion.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, parameterElementIndex = 0, containsElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 2, position, false);
                    builder.identifier(parseUri("identifier", reader, -1));
                    break;
                case "timestamp":
                    position = checkElementOrder("timestamp", 3, position, false);
                    builder.timestamp(parseDateTime("timestamp", reader, -1));
                    break;
                case "total":
                    position = checkElementOrder("total", 4, position, false);
                    builder.total(parseInteger("total", reader, -1));
                    break;
                case "offset":
                    position = checkElementOrder("offset", 5, position, false);
                    builder.offset(parseInteger("offset", reader, -1));
                    break;
                case "parameter":
                    position = checkElementOrder("parameter", 6, position, true);
                    builder.parameter(parseValueSetExpansionParameter("parameter", reader, parameterElementIndex++));
                    break;
                case "contains":
                    position = checkElementOrder("contains", 7, position, true);
                    builder.contains(parseValueSetExpansionContains("contains", reader, containsElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ValueSet.Expansion.Contains parseValueSetExpansionContains(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ValueSet.Expansion.Contains.Builder builder = ValueSet.Expansion.Contains.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, designationElementIndex = 0, containsElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "system":
                    position = checkElementOrder("system", 2, position, false);
                    builder.system(parseUri("system", reader, -1));
                    break;
                case "abstract":
                    position = checkElementOrder("abstract", 3, position, false);
                    builder._abstract(parseBoolean("abstract", reader, -1));
                    break;
                case "inactive":
                    position = checkElementOrder("inactive", 4, position, false);
                    builder.inactive(parseBoolean("inactive", reader, -1));
                    break;
                case "version":
                    position = checkElementOrder("version", 5, position, false);
                    builder.version(parseString("version", reader, -1));
                    break;
                case "code":
                    position = checkElementOrder("code", 6, position, false);
                    builder.code((Code) parseString(Code.builder(), "code", reader, -1));
                    break;
                case "display":
                    position = checkElementOrder("display", 7, position, false);
                    builder.display(parseString("display", reader, -1));
                    break;
                case "designation":
                    position = checkElementOrder("designation", 8, position, true);
                    builder.designation(parseValueSetComposeIncludeConceptDesignation("designation", reader, designationElementIndex++));
                    break;
                case "contains":
                    position = checkElementOrder("contains", 9, position, true);
                    builder.contains(parseValueSetExpansionContains("contains", reader, containsElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private ValueSet.Expansion.Parameter parseValueSetExpansionParameter(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        ValueSet.Expansion.Parameter.Builder builder = ValueSet.Expansion.Parameter.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "name":
                    position = checkElementOrder("name", 2, position, false);
                    builder.name(parseString("name", reader, -1));
                    break;
                case "valueString":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseString("valueString", reader, -1));
                    break;
                case "valueBoolean":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseBoolean("valueBoolean", reader, -1));
                    break;
                case "valueInteger":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseInteger("valueInteger", reader, -1));
                    break;
                case "valueDecimal":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDecimal("valueDecimal", reader, -1));
                    break;
                case "valueUri":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseUri("valueUri", reader, -1));
                    break;
                case "valueCode":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value((Code) parseString(Code.builder(), "valueCode", reader, -1));
                    break;
                case "valueDateTime":
                    position = checkElementOrder("value[x]", 3, position, false);
                    builder.value(parseDateTime("valueDateTime", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private VerificationResult parseVerificationResult(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        VerificationResult.Builder builder = VerificationResult.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, targetElementIndex = 0, targetLocationElementIndex = 0, validationProcessElementIndex = 0, primarySourceElementIndex = 0, validatorElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "target":
                    position = checkElementOrder("target", 8, position, true);
                    builder.target(parseReference("target", reader, targetElementIndex++));
                    break;
                case "targetLocation":
                    position = checkElementOrder("targetLocation", 9, position, true);
                    builder.targetLocation(parseString("targetLocation", reader, targetLocationElementIndex++));
                    break;
                case "need":
                    position = checkElementOrder("need", 10, position, false);
                    builder.need(parseCodeableConcept("need", reader, -1));
                    break;
                case "status":
                    position = checkElementOrder("status", 11, position, false);
                    builder.status((Status) parseString(Status.builder(), "status", reader, -1));
                    break;
                case "statusDate":
                    position = checkElementOrder("statusDate", 12, position, false);
                    builder.statusDate(parseDateTime("statusDate", reader, -1));
                    break;
                case "validationType":
                    position = checkElementOrder("validationType", 13, position, false);
                    builder.validationType(parseCodeableConcept("validationType", reader, -1));
                    break;
                case "validationProcess":
                    position = checkElementOrder("validationProcess", 14, position, true);
                    builder.validationProcess(parseCodeableConcept("validationProcess", reader, validationProcessElementIndex++));
                    break;
                case "frequency":
                    position = checkElementOrder("frequency", 15, position, false);
                    builder.frequency(parseTiming("frequency", reader, -1));
                    break;
                case "lastPerformed":
                    position = checkElementOrder("lastPerformed", 16, position, false);
                    builder.lastPerformed(parseDateTime("lastPerformed", reader, -1));
                    break;
                case "nextScheduled":
                    position = checkElementOrder("nextScheduled", 17, position, false);
                    builder.nextScheduled(parseDate("nextScheduled", reader, -1));
                    break;
                case "failureAction":
                    position = checkElementOrder("failureAction", 18, position, false);
                    builder.failureAction(parseCodeableConcept("failureAction", reader, -1));
                    break;
                case "primarySource":
                    position = checkElementOrder("primarySource", 19, position, true);
                    builder.primarySource(parseVerificationResultPrimarySource("primarySource", reader, primarySourceElementIndex++));
                    break;
                case "attestation":
                    position = checkElementOrder("attestation", 20, position, false);
                    builder.attestation(parseVerificationResultAttestation("attestation", reader, -1));
                    break;
                case "validator":
                    position = checkElementOrder("validator", 21, position, true);
                    builder.validator(parseVerificationResultValidator("validator", reader, validatorElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private VerificationResult.Attestation parseVerificationResultAttestation(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        VerificationResult.Attestation.Builder builder = VerificationResult.Attestation.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "who":
                    position = checkElementOrder("who", 2, position, false);
                    builder.who(parseReference("who", reader, -1));
                    break;
                case "onBehalfOf":
                    position = checkElementOrder("onBehalfOf", 3, position, false);
                    builder.onBehalfOf(parseReference("onBehalfOf", reader, -1));
                    break;
                case "communicationMethod":
                    position = checkElementOrder("communicationMethod", 4, position, false);
                    builder.communicationMethod(parseCodeableConcept("communicationMethod", reader, -1));
                    break;
                case "date":
                    position = checkElementOrder("date", 5, position, false);
                    builder.date(parseDate("date", reader, -1));
                    break;
                case "sourceIdentityCertificate":
                    position = checkElementOrder("sourceIdentityCertificate", 6, position, false);
                    builder.sourceIdentityCertificate(parseString("sourceIdentityCertificate", reader, -1));
                    break;
                case "proxyIdentityCertificate":
                    position = checkElementOrder("proxyIdentityCertificate", 7, position, false);
                    builder.proxyIdentityCertificate(parseString("proxyIdentityCertificate", reader, -1));
                    break;
                case "proxySignature":
                    position = checkElementOrder("proxySignature", 8, position, false);
                    builder.proxySignature(parseSignature("proxySignature", reader, -1));
                    break;
                case "sourceSignature":
                    position = checkElementOrder("sourceSignature", 9, position, false);
                    builder.sourceSignature(parseSignature("sourceSignature", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private VerificationResult.PrimarySource parseVerificationResultPrimarySource(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        VerificationResult.PrimarySource.Builder builder = VerificationResult.PrimarySource.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, typeElementIndex = 0, communicationMethodElementIndex = 0, pushTypeAvailableElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "who":
                    position = checkElementOrder("who", 2, position, false);
                    builder.who(parseReference("who", reader, -1));
                    break;
                case "type":
                    position = checkElementOrder("type", 3, position, true);
                    builder.type(parseCodeableConcept("type", reader, typeElementIndex++));
                    break;
                case "communicationMethod":
                    position = checkElementOrder("communicationMethod", 4, position, true);
                    builder.communicationMethod(parseCodeableConcept("communicationMethod", reader, communicationMethodElementIndex++));
                    break;
                case "validationStatus":
                    position = checkElementOrder("validationStatus", 5, position, false);
                    builder.validationStatus(parseCodeableConcept("validationStatus", reader, -1));
                    break;
                case "validationDate":
                    position = checkElementOrder("validationDate", 6, position, false);
                    builder.validationDate(parseDateTime("validationDate", reader, -1));
                    break;
                case "canPushUpdates":
                    position = checkElementOrder("canPushUpdates", 7, position, false);
                    builder.canPushUpdates(parseCodeableConcept("canPushUpdates", reader, -1));
                    break;
                case "pushTypeAvailable":
                    position = checkElementOrder("pushTypeAvailable", 8, position, true);
                    builder.pushTypeAvailable(parseCodeableConcept("pushTypeAvailable", reader, pushTypeAvailableElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private VerificationResult.Validator parseVerificationResultValidator(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        VerificationResult.Validator.Builder builder = VerificationResult.Validator.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "organization":
                    position = checkElementOrder("organization", 2, position, false);
                    builder.organization(parseReference("organization", reader, -1));
                    break;
                case "identityCertificate":
                    position = checkElementOrder("identityCertificate", 3, position, false);
                    builder.identityCertificate(parseString("identityCertificate", reader, -1));
                    break;
                case "attestationSignature":
                    position = checkElementOrder("attestationSignature", 4, position, false);
                    builder.attestationSignature(parseSignature("attestationSignature", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private VisionPrescription parseVisionPrescription(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        VisionPrescription.Builder builder = VisionPrescription.builder();
        builder.setValidating(validating);
        int position = -1;
        int containedElementIndex = 0, extensionElementIndex = 0, modifierExtensionElementIndex = 0, identifierElementIndex = 0, lensSpecificationElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "id":
                    position = checkElementOrder("id", 0, position, false);
                    builder.id(parseJavaString("id", reader, -1));
                    break;
                case "meta":
                    position = checkElementOrder("meta", 1, position, false);
                    builder.meta(parseMeta("meta", reader, -1));
                    break;
                case "implicitRules":
                    position = checkElementOrder("implicitRules", 2, position, false);
                    builder.implicitRules(parseUri("implicitRules", reader, -1));
                    break;
                case "language":
                    position = checkElementOrder("language", 3, position, false);
                    builder.language((Code) parseString(Code.builder(), "language", reader, -1));
                    break;
                case "text":
                    position = checkElementOrder("text", 4, position, false);
                    builder.text(parseNarrative("text", reader, -1));
                    break;
                case "contained":
                    position = checkElementOrder("contained", 5, position, true);
                    builder.contained(parseResource("contained", reader, containedElementIndex++));
                    break;
                case "extension":
                    position = checkElementOrder("extension", 6, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 7, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "identifier":
                    position = checkElementOrder("identifier", 8, position, true);
                    builder.identifier(parseIdentifier("identifier", reader, identifierElementIndex++));
                    break;
                case "status":
                    position = checkElementOrder("status", 9, position, false);
                    builder.status((VisionStatus) parseString(VisionStatus.builder(), "status", reader, -1));
                    break;
                case "created":
                    position = checkElementOrder("created", 10, position, false);
                    builder.created(parseDateTime("created", reader, -1));
                    break;
                case "patient":
                    position = checkElementOrder("patient", 11, position, false);
                    builder.patient(parseReference("patient", reader, -1));
                    break;
                case "encounter":
                    position = checkElementOrder("encounter", 12, position, false);
                    builder.encounter(parseReference("encounter", reader, -1));
                    break;
                case "dateWritten":
                    position = checkElementOrder("dateWritten", 13, position, false);
                    builder.dateWritten(parseDateTime("dateWritten", reader, -1));
                    break;
                case "prescriber":
                    position = checkElementOrder("prescriber", 14, position, false);
                    builder.prescriber(parseReference("prescriber", reader, -1));
                    break;
                case "lensSpecification":
                    position = checkElementOrder("lensSpecification", 15, position, true);
                    builder.lensSpecification(parseVisionPrescriptionLensSpecification("lensSpecification", reader, lensSpecificationElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private VisionPrescription.LensSpecification parseVisionPrescriptionLensSpecification(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        VisionPrescription.LensSpecification.Builder builder = VisionPrescription.LensSpecification.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0, prismElementIndex = 0, noteElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "product":
                    position = checkElementOrder("product", 2, position, false);
                    builder.product(parseCodeableConcept("product", reader, -1));
                    break;
                case "eye":
                    position = checkElementOrder("eye", 3, position, false);
                    builder.eye((VisionEyes) parseString(VisionEyes.builder(), "eye", reader, -1));
                    break;
                case "sphere":
                    position = checkElementOrder("sphere", 4, position, false);
                    builder.sphere(parseDecimal("sphere", reader, -1));
                    break;
                case "cylinder":
                    position = checkElementOrder("cylinder", 5, position, false);
                    builder.cylinder(parseDecimal("cylinder", reader, -1));
                    break;
                case "axis":
                    position = checkElementOrder("axis", 6, position, false);
                    builder.axis(parseInteger("axis", reader, -1));
                    break;
                case "prism":
                    position = checkElementOrder("prism", 7, position, true);
                    builder.prism(parseVisionPrescriptionLensSpecificationPrism("prism", reader, prismElementIndex++));
                    break;
                case "add":
                    position = checkElementOrder("add", 8, position, false);
                    builder.add(parseDecimal("add", reader, -1));
                    break;
                case "power":
                    position = checkElementOrder("power", 9, position, false);
                    builder.power(parseDecimal("power", reader, -1));
                    break;
                case "backCurve":
                    position = checkElementOrder("backCurve", 10, position, false);
                    builder.backCurve(parseDecimal("backCurve", reader, -1));
                    break;
                case "diameter":
                    position = checkElementOrder("diameter", 11, position, false);
                    builder.diameter(parseDecimal("diameter", reader, -1));
                    break;
                case "duration":
                    position = checkElementOrder("duration", 12, position, false);
                    builder.duration((SimpleQuantity) parseQuantity(SimpleQuantity.builder(), "duration", reader, -1));
                    break;
                case "color":
                    position = checkElementOrder("color", 13, position, false);
                    builder.color(parseString("color", reader, -1));
                    break;
                case "brand":
                    position = checkElementOrder("brand", 14, position, false);
                    builder.brand(parseString("brand", reader, -1));
                    break;
                case "note":
                    position = checkElementOrder("note", 15, position, true);
                    builder.note(parseAnnotation("note", reader, noteElementIndex++));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private VisionPrescription.LensSpecification.Prism parseVisionPrescriptionLensSpecificationPrism(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        VisionPrescription.LensSpecification.Prism.Builder builder = VisionPrescription.LensSpecification.Prism.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        int position = -1;
        int extensionElementIndex = 0, modifierExtensionElementIndex = 0;
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                requireNamespace(reader, FHIR_NS_URI);
                switch (localName) {
                case "extension":
                    position = checkElementOrder("extension", 0, position, true);
                    builder.extension(parseExtension("extension", reader, extensionElementIndex++));
                    break;
                case "modifierExtension":
                    position = checkElementOrder("modifierExtension", 1, position, true);
                    builder.modifierExtension(parseExtension("modifierExtension", reader, modifierExtensionElementIndex++));
                    break;
                case "amount":
                    position = checkElementOrder("amount", 2, position, false);
                    builder.amount(parseDecimal("amount", reader, -1));
                    break;
                case "base":
                    position = checkElementOrder("base", 3, position, false);
                    builder.base((VisionBase) parseString(VisionBase.builder(), "base", reader, -1));
                    break;
                default:
                    if (!ignoringUnrecognizedElements) {
                        throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
                    }
                    reader.nextTag();
                    break;
                }
                break;
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return builder.build();
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private Xhtml parseXhtml(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        Xhtml.Builder builder = Xhtml.builder();
        builder.setValidating(validating);
        java.lang.String id = reader.getAttributeValue(null, "id");
        if (id != null) {
            builder.id(id);
        }
        builder.value(parseDiv(reader));
        stackPop();
        return builder.build();
    }

    private void stackPush(java.lang.String elementName, int elementIndex) {
        if (elementIndex != -1) {
            stack.push(elementName + "[" + elementIndex + "]");
        } else {
            stack.push(elementName);
        }
        if (DEBUG) {
            System.out.println(getPath());
        }
    }

    private void stackPop() {
        stack.pop();
    }

    private java.lang.String getPath() {
        StringJoiner joiner = new StringJoiner(".");
        for (java.lang.String s : stack) {
            joiner.add(s);
        }
        return joiner.toString();
    }

    private java.lang.String parseJavaString(java.lang.String elementName, XMLStreamReader reader, int elementIndex) throws XMLStreamException {
        stackPush(elementName, elementIndex);
        java.lang.String javaString = reader.getAttributeValue(null, "value");
        while (reader.hasNext()) {
            int eventType = reader.next();
            switch (eventType) {
            case XMLStreamReader.START_ELEMENT:
                java.lang.String localName = reader.getLocalName();
                throw new IllegalArgumentException("Unrecognized element: '" + localName + "'");
            case XMLStreamReader.END_ELEMENT:
                if (reader.getLocalName().equals(elementName)) {
                    stackPop();
                    return javaString;
                }
                break;
            }
        }
        throw new XMLStreamException("Unexpected end of stream");
    }

    private java.lang.String getResourceType(XMLStreamReader reader) throws XMLStreamException {
        java.lang.String resourceType = reader.getLocalName();
        try {
            ResourceType.from(resourceType);
        } catch (IllegalArgumentException e) {
            throw new IllegalArgumentException("Invalid resource type: '" + resourceType + "'");
        }
        return resourceType;
    }
}
