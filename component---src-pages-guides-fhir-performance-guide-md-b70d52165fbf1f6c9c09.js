(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{iwV9:function(e,t,a){"use strict";a.r(t),a.d(t,"_frontmatter",(function(){return c})),a.d(t,"default",(function(){return b}));var n=a("k1TG"),r=a("8o2o"),i=(a("q1tI"),a("7ljp")),l=a("013z"),c=(a("qKvR"),{}),o={_frontmatter:c},s=l.a;function b(e){var t=e.components,a=Object(r.a)(e,["components"]);return Object(i.b)(s,Object(n.a)({},o,a,{components:t,mdxType:"MDXLayout"}),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#1-overview"}),"1 Overview")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#2-system-sizing"}),"2 System Sizing")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#3-fhir-server-configuration"}),"3 FHIR Server Configuration"),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#31-concurrency"}),"3.1 Concurrency")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#32-transaction-timeout"}),"3.2 Transaction Timeout")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#33-session-affinity"}),"3.3 Session Affinity")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#34-value-id-caches"}),"3.4 Valud-Id Caches")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#35-logical-id-generation"}),"3.5 Logical Id Generation")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#36-compartment-search-optimization"}),"3.6 Compartment Search Optimization")))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#4-database-tuning"}),"4 Database Tuning"),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#41-postgresql"}),"4.1 PostgreSQL")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#42-ibm-db2"}),"4.2 IBM Db2")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#43-derby"}),"4.3 Derby")))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#5-client-access-scenarios"}),"5 Client Access Scenarios"),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#51-search-examples"}),"5.1 Search Examples")))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#6-tools"}),"6 Tools"),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#61-making-fhir-requests-with-curl"}),"6.1 Making FHIR Requests With curl")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#62-making-fhir-requests-with-ibm-fhir-server-client"}),"6.2 Making FHIR Requests with IBM FHIR Server Client"))))),Object(i.b)("h1",null,"1 Overview"),Object(i.b)("p",null,"This guide describes how to tune IBM FHIR Server and its database to get the best performance. It also describes different FHIR query strategies which may help to work around specific performance issues."),Object(i.b)("p",null,"Note: all logical-ids and resources in this guide are examples and do not refer to actual patient data."),Object(i.b)("h1",null,"2 System Sizing"),Object(i.b)("p",null,"The sizing table below should be considered a starting point. Actual requirements may vary greatly based on the specific scenarios for a given deployment. For example, search-heavy workloads will require more database CPU and IOPS capacity than a system servicing simple reads."),Object(i.b)("p",null,"CPU consumption of the IBM FHIR Server is closely correlated with the number of resources being processed, particularly during ingestion where processing involves:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Parsing"),Object(i.b)("li",{parentName:"ul"},"Validation"),Object(i.b)("li",{parentName:"ul"},"Search Parameter Evaluation"),Object(i.b)("li",{parentName:"ul"},"Persistence")),Object(i.b)("p",null,"The following sizes are guidelines only. You should test and measure for your specific use-cases."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Data Volume and Load Examples")),Object(i.b)("table",null,Object(i.b)("thead",{parentName:"table"},Object(i.b)("tr",{parentName:"thead"},Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"T-Shirt Size"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Patient Lives"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Searches/s"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Resource reads/s"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Resource writes/s"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Daily New Resources"))),Object(i.b)("tbody",{parentName:"table"},Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Small (S)"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"3,000,000"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"10"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"350"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"100"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"1,440,000")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Medium (M)"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"10,000,000"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"20"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"900"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"300"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"4,320,000")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Large (L)"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"35,000,000"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"70"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"3,500"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"1,100"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"15,840,000")))),Object(i.b)("br",null),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Example System Sizing")),Object(i.b)("table",null,Object(i.b)("thead",{parentName:"table"},Object(i.b)("tr",{parentName:"thead"},Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"T-Shirt Size"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Server Nodes"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Server Cores"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Server GB"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"DB Cores"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"DB GB"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"IOPS"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Total Cores"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Total GB"))),Object(i.b)("tbody",{parentName:"table"},Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Small (S)"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"2"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"2"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"4"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"4"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"8"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"3K"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"8"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"16")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Medium (M)"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"4"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"4"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"8"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"8"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"16"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"10K"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"24"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"48")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Large (L)"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"6"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"8"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"8"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"24"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"64"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"35K"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"72"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"112")))),Object(i.b)("br",null),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Note and Assumptions:")),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"Resource ingestion limited to a 4 hour window;"),Object(i.b)("li",{parentName:"ol"},"Resource reads/second represents total from all read, vread, history and search requests;"),Object(i.b)("li",{parentName:"ol"},"Searches and reads mostly occur during the business day, leaving capacity for maintenance tasks and new resource ingestion during off-peak hours;"),Object(i.b)("li",{parentName:"ol"},"Average resource size is 2KiB.")),Object(i.b)("br",null),Object(i.b)("h1",null,"3 FHIR Server Configuration"),Object(i.b)("p",null,"Terminology:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"tenant_name")," - the name/id of a tenant. Used interchangeably with tenant_id;"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"tenant_id")," - the name/id of a tenant. Used interchangeably with tenant_name;"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"tenant_key")," - a password fragment used in Db2 to verify tenant access ;"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"datastore")," - represents a logical database used by the persistence layer to store/retrieve FHIR resources;"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"datasource")," - the JTA object from which the persistence layer code can obtain JDBC connections to the underlying database. A datastore may include multiple datasource definitions used for different purposes;"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"ds-id")," - an identifier representing a datastore used for a tenant.")),Object(i.b)("h2",null,"3.1 Concurrency"),Object(i.b)("p",null,"This section describes how to configure the IBM FHIR Server and its database for concurrency."),Object(i.b)("h3",null,"3.1.1 Liberty Profile Concurrency"),Object(i.b)("p",null,"Liberty Profile uses an executor service to handle incoming HTTP/S requests. By default, the executor service automatically adjusts its thread pool size to most efficiently handle the request load. Although the executor service can be configured, we recommend using the default configuration. The best solution for supporting greater concurrency is to scale-out additional instances of the IBM FHIR Server."),Object(i.b)("h3",null,"3.1.2 Database Max Connections"),Object(i.b)("p",null,"Db2 and PostgreSQL limit the maximum number of open connections. It is important to configure the database in conjunction with the Liberty Profile datasource connection pools to avoid connection failures which will result in HTTP 500 errors being returned from the IBM FHIR Server."),Object(i.b)("p",null,"Assuming there are N instances of the IBM FHIR Server, the recommended connection limits should be configured as follows:"),Object(i.b)("table",null,Object(i.b)("thead",{parentName:"table"},Object(i.b)("tr",{parentName:"thead"},Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Database"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Property Name"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Recommended Setting"))),Object(i.b)("tbody",{parentName:"table"},Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"IBM Db2"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"MAX_CONNECTIONS/MAX_COORDAGENTS"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"maxPoolSize * N + 20")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"PostgreSQL"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"max_connections"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"maxPoolSize * N + 15")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Derby"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"N/A"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"N/A")))),Object(i.b)("p",null,"See ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"https://cloud.ibm.com/docs/databases-for-postgresql?topic=databases-for-postgresql-managing-connections"}),"Managing PostgreSQL Connections")," in the IBM Cloud documentation for more information."),Object(i.b)("h3",null,"3.1.3 Proxy Datasource (Default, Legacy)"),Object(i.b)("p",null,"The default datasource configuration used by the IBM FHIR Server is based on a custom datasource implementation which allows datasources to be programmatically added and removed without a server restart, something not supported natively in Liberty Profile."),Object(i.b)("p",null,"Just one Liberty Profile JTA ",Object(i.b)("inlineCode",{parentName:"p"},"<dataSource>")," is required:"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),'    <dataSource id="fhirProxyDataSource" jndiName="jdbc/fhirProxyDataSource" type="javax.sql.XADataSource" statementCacheSize="200" syncQueryTimeoutWithTransactionTimeout="true">\n        <jdbcDriver libraryRef="fhirSharedLib" javax.sql.XADataSource="com.ibm.fhir.persistence.proxy.FHIRProxyXADataSource"/>\n        <connectionManager maxPoolSize="200" minPoolSize="20" connectionTimeout="60s" maxIdleTime="2m" numConnectionsPerThreadLocal="2"/>\n    </dataSource>\n')),Object(i.b)("p",null,"Only one connection pool is supported, as defined by the ",Object(i.b)("inlineCode",{parentName:"p"},"<connectionManager>")," element. The ",Object(i.b)("inlineCode",{parentName:"p"},"max_connections")," for each target database should be configured to be ",Object(i.b)("inlineCode",{parentName:"p"},"maxPoolSize")," times the cluster size plus the overhead recommended for the given database type to support basic operation and monitoring etc."),Object(i.b)("p",null,"Note, the FHIRProxyXADataSource is only called to provide new connections. Most ",Object(i.b)("inlineCode",{parentName:"p"},"getConnection()")," requests will be served directly by the connection pool."),Object(i.b)("table",null,Object(i.b)("thead",{parentName:"table"},Object(i.b)("tr",{parentName:"thead"},Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Property"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Recommended Value"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Description"))),Object(i.b)("tbody",{parentName:"table"},Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"statementCacheSize"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"200"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"The number of prepared statements cached per connection.")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"jndiName"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"jdbc/fhirProxyDataSource"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"The JNDI address used by the IBM FHIR Server code to locate the datasource")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"type"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"javax.sql.XADataSource"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"The Java interface representing the datasource, implemented by FHIRProxyXADataSource")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"javax.sql.XADataSource"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"com.ibm.fhir.persistence.proxy.FHIRProxyXADataSource"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"The IBM FHIR Server custom datasource implementation")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"libraryRef"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"fhirSharedLib"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Liberty Profile shared library definition referencing the Jar files containing the FHIRProxyXADataSource implementation.")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"maxPoolSize"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"see below"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"The max number of connections allowed")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"minPoolSize"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"40"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"The pool will shrink to this size by aging out old connections")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"connectionTimeout"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"60s"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Timeout when trying to establish a new connection to the database")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"maxIdleTime"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"2m"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Removes connections from the pool when they are unused for this amount of time, but does not shrink the pool below minPoolSize")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"numConnectionsPerThreadLocal"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"2"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Number of connections cached in thread-local storage. Testing has shown the value 2 is sufficient to eliminate contention in high-concurrency scenarios.")))),Object(i.b)("h3",null,"3.1.4 JEE Datasource (Recommended)"),Object(i.b)("p",null,"The recommended approach for tenant datatstore configuration is to use individual JTA datasources, each with their own connection manager (connection pool):"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),'    <dataSource id="fhirDatasourcePGCloudDefault" jndiName="jdbc/fhir_tenant1_default" type="javax.sql.XADataSource" statementCacheSize="200" syncQueryTimeoutWithTransactionTimeout="true">\n        <jdbcDriver javax.sql.XADataSource="org.postgresql.xa.PGXADataSource" libraryRef="fhirSharedLib"/>\n            <properties.postgresql\n                 serverName="your.postgres.host"\n                 portNumber="5432"\n                 databaseName="fhirdb"\n                 user="fhirserver"\n                 password="change-password"\n                 currentSchema="fhirdata"\n                 ssl="true"\n                 sslmode="require"\n                 sslrootcert="resources/security/your-postgres-host.crt" />\n        />\n        <connectionManager maxPoolSize="200" minPoolSize="20" connectionTimeout="60s" maxIdleTime="2m" numConnectionsPerThreadLocal="2"/>\n    </dataSource>\n')),Object(i.b)("p",null,"Because each datasource gets its own connection manager you can tune each independently. If multiple datasources point to the same database (for example using different schemas to support multi-tenancy) be sure to configure the database ",Object(i.b)("inlineCode",{parentName:"p"},"max_connections")," accordingly. Also, remember to sum the maxPoolSize for all datasources across all IBM FHIR Server nodes in your deployment."),Object(i.b)("p",null,"Each JTA datasource should be configured in its own ",Object(i.b)("inlineCode",{parentName:"p"},".xml")," server configuration file and placed into ",Object(i.b)("inlineCode",{parentName:"p"},"{fhir-server-home}/configDropins/overrides")," where it will be picked up automatically by Liberty Profile on startup."),Object(i.b)("h2",null,"3.2 Transaction Timeout"),Object(i.b)("p",null,"Long transactions consume significant resources so to protect the system, Liberty Profile will time-out a transaction after 2 minutes (120s) by default. When a transaction times out, Liberty Profile will forcibly close any database connection currently executing a statement and the IBM FHIR Server will return an HTTP 500 response to the caller. The maximum transaction time can be extended using the ",Object(i.b)("inlineCode",{parentName:"p"},"<transaction>")," element in the Liberty Profile configuration. See Database Access TransactionManager Timeout in the (IBM FHIR Server User’s Guide)","[https://ibm.github.io/FHIR/guides/FHIRServerUsersGuide/]"," for a description how to configure this in the IBM FHIR Server."),Object(i.b)("p",null,"The following table summarizes how the transaction timeout is used for different request types:"),Object(i.b)("table",null,Object(i.b)("thead",{parentName:"table"},Object(i.b)("tr",{parentName:"thead"},Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Request Type"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Transaction Scope and Usage"))),Object(i.b)("tbody",{parentName:"table"},Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"READ"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Single transaction scope for entire request")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"VREAD"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Single transaction scope for entire request")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"HISTORY READ"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Single transaction scope for entire request")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"SEARCH"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Single transaction scope for entire request")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"POST/PUT"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Single transaction scope for entire request")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Batch Bundle"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Transaction per bundle entry. Request processing time can therefore exceed totalTranLifetimeTimeout")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Transaction Bundle"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Single transaction scope for entire request")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"$reindex"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"One HTTP call can request multiple resources to be reindexed. Each resource is reindexed in the scope of its own transaction. Reindexing is a relatively quick operation per resource - usually well under 1s - so transaction timeouts are unlikely. Reduce the number of resources processed per reindex operation to avoid read timeouts. Use concurrent requests to increase overall throughput.")))),Object(i.b)("p",null,"Because some requests use multiple transactions under the covers, the overall request response time can sometimes be greater than the transaction timeout. There is no server-side tuneable property for the overall request processing time. Tuning of the client read timeout and/or network configuration may be required when extending the maximum transaction time to more than 2 minutes, or supporting multi-transaction requests which also exceed 2 minutes."),Object(i.b)("p",null,"Firewalls or other components in the flow between a client and the IBM FHIR Server may forcibly close (reset) a connection which is considered idle. This is usually because no packets associated with the TCP connection will flow between the client and the IBM FHIR Server until the response is returned. There are two ways to address this:"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"Configure the network path to make sure that TCP idle timeout exceeds the client read timeout for all components in the client-server flow. This is impractical unless the infrastructure is dedicated (e.g. an internal system-to-system flow), even then it might not be desirable or allowed;"),Object(i.b)("li",{parentName:"ol"},"Configure TCP keep-alive (SO_KEEPALIVE) on the connection. This instructs the operating system to occassionally send packets over the wire to let the networking components know that the connection is still active while the client waits for a response from the server. Some clients may configure keep-alive by default, in which case no action is required. Note that TCP keep-alive should not be confused with HTTP Keep-Alive. The TCP keep-alive and client read-timeout values should be considered together. There is no point configuring TCP keep-alive if the delay before sending the first packet is longer than the client read-timeout. Likewise, TCP keep-alive will not prevent a client read from timing out. TCP keep-alive only ensures a connection is not reset by a network component thinking it is idle. The timing values you configure need to be guided by the network configuration in your particular solution.")),Object(i.b)("h2",null,"3.3 Session Affinity"),Object(i.b)("p",null,"TLS connection setup is a costly CPU operation. It is therefore important to ensure that routing components are configured for session affinity to avoid unnecessary connection setup costs. Clients should be written to reuse connections when making multiple requests."),Object(i.b)("h2",null,"3.4 Value-Id Caches"),Object(i.b)("p",null,"The IBM FHIR Server uses internal memory caches for resource type names, parameter names, references, codes and systems. These caches use a least-recently-used (LRU) strategy to avoid unbound growth which would result in an out-of-memory (OOM) condition."),Object(i.b)("p",null,"Currently the IBM FHIR Servers do not use sharding(*) to distribute client requests and so any client request may hit any server in a given cluster. This means that the memory used for caching value-id lookups is not distributed, but each servers’ cache is complete and may contain data also cached in another server. This may be revised in future releases if it becomes a scaling issue."),Object(i.b)("p",null,"(*) - sharding is really the responsibility of the component used to route requests to the IBM FHIR Servers, and if such a component were to support sharding, it would help to reduce the cache pressure by distributing values among the available cache instances."),Object(i.b)("p",null,"The following datasource properties in fhir-server-config.json are used to tune the size of the value-id caches:"),Object(i.b)("table",null,Object(i.b)("thead",{parentName:"table"},Object(i.b)("tr",{parentName:"thead"},Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Property"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Default Value"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Units"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Description"))),Object(i.b)("tbody",{parentName:"table"},Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"externalSystemCacheSize"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"1000"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Number of items"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Size of the LRU cache used to hold unique code-system values. Per tenant/datastore.")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"externalValueCacheSize"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"100000"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Number of items"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Size of the LRU cache used to hold unique token values. Per tenant/datastore.")))),Object(i.b)("p",null,"The caches are isolated by tenant and specific to each datasource defined for that tenant:"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),'{\n    "fhirServer": {\n        "persistence": {\n            "factoryClassname": "com.ibm.fhir.persistence.jdbc.FHIRPersistenceJDBCFactory",\n            "common": {\n                "__comment": "Configuration properties common to all persistence layer implementations",\n                "updateCreateEnabled": true\n            },\n            "jdbc": {\n                ...\n                "enableCodeSystemsCache": true,\n                "enableParameterNamesCache": true,\n                "enableResourceTypesCache": true\n            },\n            "datasources": {\n                "default": {\n                    "jndiName": "jdbc/bootstrap_default_default",\n                    "type": "derby",\n                    "currentSchema": "APP",\n                    "externalSystemCacheSize": 1000, \n                    "externalValueCacheSize": 100000\n                },\n                ...\n            }\n        }\n    }\n}\n')),Object(i.b)("p",null,"Currently no cache-hit metrics are exposed related to the caches. Tuning relies on Application Performance Management (APM) profiling and monitoring database activity looking for frequent value-id lookups against the following tables:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"PARAMETER_NAMES"),Object(i.b)("li",{parentName:"ul"},"RESOURCE_TYPES"),Object(i.b)("li",{parentName:"ul"},"COMMON_TOKEN_VALUES"),Object(i.b)("li",{parentName:"ul"},"CODE_SYSTEMS")),Object(i.b)("p",null,"The values for PARAMETER_NAMES and RESOURCE_TYPES are supposed to be fully cached. Any substantial reads (selects) from these tables after initial startup/first request should be considered a defect."),Object(i.b)("h2",null,"3.5 Logical Id Generation"),Object(i.b)("p",null,"Using random values for resource identifiers can cause performance issues in large databases. This is a particular issue when using PostgreSQL with the IBM FHIR Server due to an issue known as write amplification from full page writes. For details, see this blog post: ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"https://www.2ndquadrant.com/en/blog/on-the-impact-of-full-page-writes"}),"https://www.2ndquadrant.com/en/blog/on-the-impact-of-full-page-writes"),"."),Object(i.b)("p",null,"For best performance, ids generated by clients should not be purely random but instead be structured to include a prefix which increments over time. This causes index entries for new values to share pages (right-hand inserts), greatly reducing the write amplification overhead. "),Object(i.b)("p",null,"One example of a suitable id generation strategy can be found here in the IBM FHIR Server codebase (here)","[https://github.com/IBM/FHIR/blob/master/fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/TimestampPrefixedUUID.java]"),Object(i.b)("p",null,"This strategy provides both the desirable trait of global uniqueness as well as a low write amplification overhead thanks to the time-based prefix."),Object(i.b)("p",null,"The IBM FHIR Server also uses normalization to avoid storing (and indexing) long identifier strings in multiple places. This saves space, and the database-generated identity values are based on sequences which naturally produce the desired right-hand-insert behavior."),Object(i.b)("h2",null,"3.6 Compartment Search Optimization"),Object(i.b)("p",null,"Resources are assigned to various compartments using expressions with multiple terms. In the IBM FHIR Server JDBC persistence layer, these expressions are translated to SQL predicates with multiple ",Object(i.b)("inlineCode",{parentName:"p"},"OR")," statements. These ",Object(i.b)("inlineCode",{parentName:"p"},"ORs")," make it more difficult for the query optimizer to compute the most efficient execution plan resulting in a slow query. To address this, the IBM FHIR Server evaluates the compartment membership expression during ingestion and stores the results. The SQL query can then be written using a single value predicate resulting in faster query."),Object(i.b)("p",null,"To enable this optimization, set the ",Object(i.b)("inlineCode",{parentName:"p"},"fhirServer/search/useStoredCompartmentParam")," configuration parameter to ",Object(i.b)("inlineCode",{parentName:"p"},"true")," in the fhir-server-config.json file: "),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),'        "search": {\n            "useStoredCompartmentParam": true\n        },\n')),Object(i.b)("p",null,"Enabling this optimization is recommended. See the IBM FHIR Server release notes for more details."),Object(i.b)("h1",null,"4 Database Tuning"),Object(i.b)("table",null,Object(i.b)("thead",{parentName:"table"},Object(i.b)("tr",{parentName:"thead"},Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Tuneable"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Guidance"))),Object(i.b)("tbody",{parentName:"table"},Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Caching"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Avoiding physical reads is important for most database applications and the IBM FHIR Server is no different. Memory sizing and configuration is important for good ingestion performance as well as good read performance.")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Statistics"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Ensure statistics are up-to-date to allow the query optimizer to generate the best execution plans.")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Concurrency"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Ensure the database supports the required number of connections from the application server cluster, plus any administration overhead. Connections and their associated sessions consume memory which must be considered in the overall database server memory budget.")))),Object(i.b)("h2",null,"4.1 PostgreSQL"),Object(i.b)("p",null,"For PostgreSQL, we recommend tuning the following properties:"),Object(i.b)("table",null,Object(i.b)("thead",{parentName:"table"},Object(i.b)("tr",{parentName:"thead"},Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Property"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Recommendation"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Description"))),Object(i.b)("tbody",{parentName:"table"},Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"max_connections"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"N+15"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"N is the aggregate number of connections from the IBM FHIR Server cluster, defined by the connection manager’s ",Object(i.b)("inlineCode",{parentName:"td"},"maxPoolSize")," property. Check the PostgreSQL documentation. Connections require memory, so be careful with large values which could lead to memory pressure on the database server causing performance issues or stability problems.")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"shared_buffers"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"1/2 of memory"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"The number of 8kB blocks used for caching table data. This is important for ingestion as well as query performance. The database must be able to find free blocks to hold table and index data it needs to modify when ingesting new data.")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"effective_cache_size"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"3/4 of memory"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"Number of 8kB blocks. Not an allocation, just provides guidance to the query optimizer for how much data it can expect to be cached by the database and operating system file system cache. It is used to bias decisions on choosing index-based access paths. IBM FHIR Server queries rely heavily on index-driven plans so this value should be at the upper end of any recommended range.")))),Object(i.b)("p",null,"The recommended values should be considered a starting point. Monitor database metrics and tune appropriately for your given workload. See the ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"https://wiki.postgresql.org/wiki/Tuning_Your_PostgreSQL_Server"}),"PostgreSQL wiki")," for additional guidance."),Object(i.b)("h3",null,"4.1.1 Fillfactor"),Object(i.b)("p",null,"In PostgreSQL, the default ",Object(i.b)("inlineCode",{parentName:"p"},"fillfactor")," for each table is 100 - no room is reserved for updates. This maximizes storage utilization, but impacts performance for updates which occur when new versions of a resource are ingested. Update statements are also used frequently during the reindex process."),Object(i.b)("p",null,"To provide space for updates, all the ",Object(i.b)("inlineCode",{parentName:"p"},"<resourceType>_logical_resources")," should be configured with a ",Object(i.b)("inlineCode",{parentName:"p"},"fillfactor")," of 80 as a starting point. DBAs may specify their own ",Object(i.b)("inlineCode",{parentName:"p"},"fillfactor")," values based on their own knowledge and understanding of the system."),Object(i.b)("p",null,"The ",Object(i.b)("inlineCode",{parentName:"p"},"fillfactor")," for the ",Object(i.b)("inlineCode",{parentName:"p"},"logical_resources")," table may benefit from an even lower value to support the heavy update load during a reindex operation. This is a special case due to the fact that every row in the table is updated once."),Object(i.b)("p",null,"To change the fillfactor for existing data, a ",Object(i.b)("inlineCode",{parentName:"p"},"VACUUM FULL")," operation is required:"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"ALTER TABLE fhirdata.logical_resources SET (fillfactor=70);\n...\nVACUUM FULL fhirdata.logical_resources;\n")),Object(i.b)("p",null,"This should only be performed during a maintenance window when there is no load on the system."),Object(i.b)("h3",null,"4.1.2 Tuning Auto-vacuum"),Object(i.b)("p",null,"When running reindex operations (after a search parameter configuration change, for example), the ",Object(i.b)("inlineCode",{parentName:"p"},"logical_resources")," table undergoes frequent updates to an indexed column. Due to the nature of how PostgreSQL handles updates, this results in a significant amount of old index blocks which slows progress. The table storage parameters may need to be tuned to vacuum the ",Object(i.b)("inlineCode",{parentName:"p"},"logical_resources")," table more aggressively. To address this, tune the storage parameters for this table as follows:"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"-- Lower the trigger threshold for starting work\nalter table fhirdata.logical_resources SET (autovacuum_vacuum_scale_factor = 0.01, autovacuum_vacuum_threshold=1000);\n\n-- Increase the amount of work vacuuming completes before taking a breather (default is typically 200)\nalter table fhirdata.logical_resources SET (autovacuum_vacuum_cost_limit=2000);\n")),Object(i.b)("p",null,"The default value for autovacuum_vacuum_cost_limit is likely too restrictive for a system with good IO performance. Increasing the value to 2000 increases the throttling threshold 10x, significantly improving throughput and helping the ",Object(i.b)("inlineCode",{parentName:"p"},"logical_resources")," vacuuming to be completed before it negatively impacts reindexing performance."),Object(i.b)("p",null,"See the ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"https://www.postgresql.org/docs/12/sql-vacuum.html"}),"PostSQL VACUUM documentation")," for more details."),Object(i.b)("p",null,"In addition, administrators may also choose to run a manual vacuum as shown in the following example:"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),'fhirdb=> VACUUM (ANALYZE,VERBOSE) fhirdata.logical_resources;\nINFO:  vacuuming "fhirdata.logical_resources"\nINFO:  scanned index "logical_resources_pk" to remove 16813312 row versions\nDETAIL:  CPU: user: 31.70 s, system: 14.30 s, elapsed: 75.38 s\n\nINFO:  scanned index "unq_logical_resources" to remove 16813312 row versions\nDETAIL:  CPU: user: 70.03 s, system: 56.69 s, elapsed: 232.57 s\nINFO:  scanned index "idx_logical_resources_rits" to remove 16813312 row versions\nDETAIL:  CPU: user: 11.42 s, system: 14.00 s, elapsed: 45.40 s\nINFO:  "logical_resources": removed 16813312 row versions in 355153 pages\nDETAIL:  CPU: user: 27.36 s, system: 12.08 s, elapsed: 67.53 s\nINFO:  index "logical_resources_pk" now contains 77504219 row versions in 544383 pages\nDETAIL:  16806938 index row versions were removed.\n0 index pages have been deleted, 0 are currently reusable.\nCPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s.\nINFO:  index "unq_logical_resources" now contains 77504219 row versions in 2393179 pages\nDETAIL:  16805676 index row versions were removed.\n0 index pages have been deleted, 0 are currently reusable.\nCPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s.\nINFO:  index "idx_logical_resources_rits" now contains 77504219 row versions in 775877 pages\nDETAIL:  16813298 index row versions were removed.\n507613 index pages have been deleted, 445589 are currently reusable.\nCPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s.\nINFO:  "logical_resources": found 7765149 removable, 16804352 nonremovable row versions in 549284 out of 4210218 pages\nDETAIL:  0 dead row versions cannot be removed yet, oldest xmin: 320896669\nThere were 21857963 unused item identifiers.\nSkipped 0 pages due to buffer pins, 3070111 frozen pages.\n46 pages are entirely empty.\nCPU: user: 206.67 s, system: 113.27 s, elapsed: 537.14 s.\nINFO:  analyzing "fhirdata.logical_resources"\nINFO:  "logical_resources": scanned 30000 of 4210218 pages, containing 551774 live rows and 0 dead rows; 30000 rows in sample, 77436294 estimated total rows\nVACUUM\n')),Object(i.b)("h3",null,"4.1.3 Transaction Id Wraparound"),Object(i.b)("p",null,"Be ware of multixact wraparound issues, as highlighted by the following warning when running a manual vacuum:"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-fhirdb=>",metastring:"VACUUM (VERBOSE) fhirdata.logical_resources;",VACUUM:!0,"(VERBOSE)":!0,"fhirdata.logical_resources;":!0}),"WARNING:  oldest multixact is far in the past\nHINT:  Close open transactions with multixacts soon to avoid wraparound problems.\n")),Object(i.b)("p",null,"This indicates that the automatic vacuum process needs to be more aggressive. See ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"https://info.crunchydata.com/blog/managing-transaction-id-wraparound-in-postgresql"}),"here")," for details."),Object(i.b)("h3",null,"4.1.4 Vacuum Monitoring"),Object(i.b)("p",null,"Use the following query to see the impact of updates and deletes on the IBM FHIR Server tables (assuming the tenant is configured to use the ",Object(i.b)("inlineCode",{parentName:"p"},"fhirdata")," schema):"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),' SELECT relname, \n        n_tup_ins AS "inserts", \n        n_tup_upd AS "updates", \n        n_tup_del AS "deletes", \n        n_live_tup AS "live_tuples", \n        n_dead_tup AS "dead_tuples"\n   FROM pg_stat_user_tables\n  WHERE schemaname = \'fhirdata\'\n    AND (relname = \'logical_resources\' OR relname LIKE \'%_values\')\n    AND n_dead_tup > 0;\n')),Object(i.b)("p",null,"The values reported are since the database was last restarted. To check uptime, run the following query:"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{})," SELECT current_timestamp - pg_postmaster_start_time();\n    ?column?     \n-----------------\n 05:45:41.835965\n")),Object(i.b)("p",null,"The following query can be used to see how many auto-vacuum jobs are currently in progress and for which tables:"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"fhirdb=> SELECT r.relname, v.* \n           FROM pg_stat_progress_vacuum v, \n                pg_stat_user_tables r \n          WHERE r.relid = v.relid;\n\n          relname          |  pid   | datid | datname | relid |       phase       | heap_blks_total | heap_blks_scanned | heap_blks_vacuumed | index_vacuum_count | max_dead_tuples | num_dead_tuples \n---------------------------+--------+-------+---------+-------+-------------------+-----------------+-------------------+--------------------+--------------------+-----------------+-----------------\n imagingstudy_token_values | 451383 | 16478 | fhirdb  | 45603 | vacuuming indexes |          332918 |            332918 |                  0 |                  0 |        96879138 |            5102\n condition_token_values    | 451793 | 16478 | fhirdb  | 52193 | scanning heap     |           53883 |             18173 |                  0 |                  0 |        15679953 |          301285\n logical_resources         | 451180 | 16478 | fhirdb  | 16533 | vacuuming indexes |         1432256 |           1432256 |                  0 |                  0 |       178956970 |          765313\n")),Object(i.b)("p",null,"By default, only 3 vacuum jobs can run concurrently."),Object(i.b)("h2",null,"4.2 IBM Db2"),Object(i.b)("p",null,"TBD."),Object(i.b)("h2",null,"4.3 Derby"),Object(i.b)("p",null,"Derby is not recommended for production use and therefore tuning Derby will not be addressed in this guide."),Object(i.b)("h1",null,"5 Client Access Scenarios"),Object(i.b)("p",null,"The IBM FHIR Server translates a FHIR search request into a SQL query. The database performs query optimization to generate what it thinks is the most efficient execution plan before running the query. This optimization depends on the database having good statistics (and a clever algorithm) to make the right choice. When this goes wrong, the result is a slow response which can also end up consuming significant resources which impact the capacity of the system as a whole."),Object(i.b)("p",null,"The FHIR search specification includes a rich set of capabilities designed to make it easier for clients to find data. If a particular search performs poorly, there are likely other ways the same data can be fetched. One solution is to use multiple requests, using FHIR bundle requests to request multiple resources in one server request."),Object(i.b)("p",null,"There are many ways to retrieve data:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"READ: read the latest version of a resource using its logical identifier. Fast."),Object(i.b)("li",{parentName:"ul"},"VREAD: reads a specific version of a resource using its logical identifier and version. Fast."),Object(i.b)("li",{parentName:"ul"},"SEARCH: id - fetch one resource matching the given logical id: "),Object(i.b)("li",{parentName:"ul"},"SEARCH: identity - fetch all resources matching the given identity. Usually one but could be multiple"),Object(i.b)("li",{parentName:"ul"},"SEARCH: last-modified - Find resources modified since a given date."),Object(i.b)("li",{parentName:"ul"},"SEARCH: multiple attributes - find resources matching the search condition. Can be slow depending on the complexity of the resulting database query and the relative cardinality (row counts) of the resource search parameters."),Object(i.b)("li",{parentName:"ul"},"SEARCH: include - fetch additional resources based on the relationships found in the resources returned by the main search criteria."),Object(i.b)("li",{parentName:"ul"},"SEARCH - has "),Object(i.b)("li",{parentName:"ul"},"SEARCH - revinclude")),Object(i.b)("p",null,"There may also be some subtle semantic differences among searches which might appear to be equivalent. This is particularly true for compartment-based queries due to the complex definition of compartment membership defined in the FHIR specification."),Object(i.b)("h2",null,"5.1 Read"),Object(i.b)("p",null,"Logical id-based read requests are the fastest way to access a resource, for example:"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"    <base>/Patient/17546b5cd4a-cae29bb0-d6d7-4a1a-a8df-505e2e3a975e\n")),Object(i.b)("p",null,"This translates into a single query which utilizes indexes to quickly locate the required record:"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"SELECT R.RESOURCE_ID, R.LOGICAL_RESOURCE_ID, R.VERSION_ID, \n       R.LAST_UPDATED, R.IS_DELETED, R.DATA, LR.LOGICAL_ID \n  FROM Patient_RESOURCES R, \n       Patient_LOGICAL_RESOURCES LR \n WHERE LR.LOGICAL_ID = ? \n   AND R.RESOURCE_ID = LR.CURRENT_RESOURCE_ID\n")),Object(i.b)("p",null,"When the data is currently cached by the database, this query takes less than a millisecond to execute, as shown in the following execution plan analysis from PostgreSQL:"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"Nested Loop  (cost=0.84..10.88 rows=1 width=1335) (actual time=0.046..0.058 rows=1 loops=1)\n  Buffers: shared hit=8\n  ->  Index Scan using idx_patient_logical_resourceslogical_id on patient_logical_resources lr  (cost=0.42..5.44 rows=1 width=53) (actual time=0.026..0.030 rows=1 loops=1)\n        Index Cond: ((logical_id)::text = '17546b5cd4a-cae29bb0-d6d7-4a1a-a8df-505e2e3a975e'::text)\n        Buffers: shared hit=4\n  ->  Index Scan using patient_resources_prf_in1 on patient_resources r  (cost=0.42..5.44 rows=1 width=1290) (actual time=0.011..0.012 rows=1 loops=1)\n        Index Cond: (resource_id = lr.current_resource_id)\n        Buffers: shared hit=4\nPlanning Time: 0.313 ms\nExecution Time: 0.127 ms\n")),Object(i.b)("h2",null,"5.2 Version Read"),Object(i.b)("p",null,"The FHIR specification supports reading a specific version of a resource:"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"Patient/17546b5cd4a-cae29bb0-d6d7-4a1a-a8df-505e2e3a975e/_history/1\n")),Object(i.b)("p",null,"The resulting query is similar, except in this case, the specified version is requested from the PATIENT_RESOURCES table. Performance is similar to the plain read, depending on what data is currently cached, of course:"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"SELECT R.RESOURCE_ID, R.LOGICAL_RESOURCE_ID, R.VERSION_ID, \n       R.LAST_UPDATED, R.IS_DELETED, R.DATA, LR.LOGICAL_ID \n  FROM Patient_RESOURCES R, Patient_LOGICAL_RESOURCES LR \n WHERE LR.LOGICAL_ID = ? \n   AND R.LOGICAL_RESOURCE_ID = LR.LOGICAL_RESOURCE_ID \n   AND R.VERSION_ID = ?\n")),Object(i.b)("h2",null,"5.3 History"),Object(i.b)("p",null,"The history query returns all versions of a resource. Because there is no limit to the number of versions for a given resource, the results are ordered by the version_id (resource version number) and paginated using OFFSET and FETCH NEXT ROWS clauses:"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"  SELECT R.RESOURCE_ID, R.LOGICAL_RESOURCE_ID, R.VERSION_ID, \n         R.LAST_UPDATED, R.IS_DELETED, R.DATA, LR.LOGICAL_ID \n    FROM Patient_RESOURCES R, Patient_LOGICAL_RESOURCES LR \n   WHERE LR.LOGICAL_ID = ? \n     AND R.LOGICAL_RESOURCE_ID = LR.LOGICAL_RESOURCE_ID \nORDER BY R.VERSION_ID DESC \n  OFFSET ? ROWS \n  FETCH NEXT ? ROWS ONLY \n")),Object(i.b)("p",null,"In order to include an overall count of the number of resource versions, the IBM FHIR Server must execute an additional SQL query:"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"SELECT COUNT(R.VERSION_ID) \n  FROM Patient_RESOURCES R, \n       Patient_LOGICAL_RESOURCES LR \n WHERE LR.LOGICAL_ID = ? \n   AND R.LOGICAL_RESOURCE_ID = LR.LOGICAL_RESOURCE_ID;\n")),Object(i.b)("p",null,"In most cases the history queries will execute very quickly. Performance will be slower for cases where a single resource has thousands of versions. To avoid this, ingestion pipelines must ensure they only update a version when necessary."),Object(i.b)("h2",null,"5.4 Search Examples"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"COMPARTMENT SEARCHES")),Object(i.b)("p",null,"Search for all ExplanationOfBenefit records which reference the patient according to its logical id ",Object(i.b)("inlineCode",{parentName:"p"},"17546b5cd4a-cae29bb0-d6d7-4a1a-a8df-505e2e3a975e"),"."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"    <base>/ExplanationOfBenefit?patient=17546b5cd4a-cae29bb0-d6d7-4a1a-a8df-505e2e3a975e\n")),Object(i.b)("p",null,"Search the patient compartment ",Object(i.b)("inlineCode",{parentName:"p"},"17546b5cd4a-cae29bb0-d6d7-4a1a-a8df-505e2e3a975e")," for all matching ExplanationOfBenefit resources."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"    <base>/Patient/17546b5cd4a-cae29bb0-d6d7-4a1a-a8df-505e2e3a975e/ExplanationOfBenefit\n")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"COMPARTMENT CHAINED SEARCH")),Object(i.b)("p",null,"Requests any ExplanationOfBenefit resources belonging to the compartment for patient ",Object(i.b)("inlineCode",{parentName:"p"},"17546b5cd4a-cae29bb0-d6d7-4a1a-a8df-505e2e3a975e")," with a Claim created on a given day: 2015-10-16."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"    <base>/Patient/17546b5cd4a-cae29bb0-d6d7-4a1a-a8df-505e2e3a975e/ExplanationOfBenefit?claim:Claim.created=2015-10-16\n")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"CLIENT SEARCH BUNDLES")),Object(i.b)("p",null,"If the response time is not acceptable, an alternative strategy is to first fetch all the ExplanationOfBenefit resources associated with the given patient, then compose a second bundle request for the Claim records associated with the ExplanationOfBenefit resources returned by the first search. The initial request can fetch the Patient resource along with the ExplanationOfBenefit resources for that patient."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),'{\n    "entry": [\n        {\n            "request": {\n                "method": "GET",\n                "url": "Patient/17546b5cd4a-cae29bb0-d6d7-4a1a-a8df-505e2e3a975e"\n            }\n        },\n        {\n            "request": {\n                "method": "GET",\n                "url": "ExplanationOfBenefit?patient=17546b5cd4a-cae29bb0-d6d7-4a1a-a8df-505e2e3a975e"\n            }\n        }\n    ],\n    "resourceType": "Bundle",\n    "type": "transaction"\n}\n')),Object(i.b)("p",null,"Note the bundle type is specified as ",Object(i.b)("inlineCode",{parentName:"p"},"transaction"),". Because all the entries in the bundle are reads, there’s no modification to the database and so no semantic difference between using ",Object(i.b)("inlineCode",{parentName:"p"},"transaction")," or ",Object(i.b)("inlineCode",{parentName:"p"},"batch"),". However, for ",Object(i.b)("inlineCode",{parentName:"p"},"transaction"),", the IBM FHIR Server initiates a single transaction for the entire request. In high load/concurrency conditions, this improves throughput."),Object(i.b)("p",null,"The number of ExplanationOfBenefit resources for a given patient is likely to be relatively small. By iterating over the response to the previous request, the client can package a number of resource reads into one or more bundle requests. Read requests are the most efficient type of request for accessing data from the IBM FHIR Server."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),'{\n    "entry": [\n        {\n            "request": {\n                "method": "GET",\n                "url": "Claim/1747d7abed3-7f331c1b-5262-41b7-894a-09d63ddc1791"\n            }\n        },\n        {\n            "request": {\n                "method": "GET",\n                "url": "Practitioner/1747d7abe89-61ad12fd-61ba-4c06-9fbf-89a130babd27"\n            }\n        },\n        {\n            "request": {\n                "method": "GET",\n                "url": "Claim/1747d7abf2d-bbfd621f-31ec-4044-88df-a5d14efba26a"\n            }\n        },\n        ...\n        {\n            "request": {\n                "method": "GET",\n                "url": "Practitioner/1747d7ac6b2-90d24ffc-b773-45c0-8194-a24057087c82"\n            }\n        }\n    ],\n    "resourceType": "Bundle",\n    "type": "transaction"\n}\n')),Object(i.b)("p",null,"Although this approach involves multiple requests to the IBM FHIR Server, the overall response time may be quicker due to the simplicity of the requests."),Object(i.b)("p",null,"The client can filter the required Claim resources, or alternatively convert the reads to search requests:"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),'{\n    "entry": [\n        {\n            "request": {\n                "method": "GET",\n                "url": "Claim?_id=1747d7abed3-7f331c1b-5262-41b7-894a-09d63ddc1791&created=2015-10-16"\n            }\n        },\n        {\n            "request": {\n                "method": "GET",\n                "url": "Practitioner/1747d7abe89-61ad12fd-61ba-4c06-9fbf-89a130babd27"\n            }\n        },\n        {\n            "request": {\n                "method": "GET",\n                "url": "Claim?_id=1747d7abf2d-bbfd621f-31ec-4044-88df-a5d14efba26a&created=2015-10-16"\n            }\n        },\n        ...\n        {\n            "request": {\n                "method": "GET",\n                "url": "Practitioner/1747d7ac6b2-90d24ffc-b773-45c0-8194-a24057087c82"\n            }\n        }\n    ],\n    "resourceType": "Bundle",\n    "type": "transaction"\n}\n')),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"INCLUDE")),Object(i.b)("p",null,"Another alternative which tends to perform well uses the ",Object(i.b)("inlineCode",{parentName:"p"},"_include")," function. The ",Object(i.b)("inlineCode",{parentName:"p"},"_include")," function is useful because it avoids the need for additional round-trips (the server performs the iteration internally). "),Object(i.b)("p",null,"This example retrieves ExplanationOfBenefit resources for patient ",Object(i.b)("inlineCode",{parentName:"p"},"17478598887-c1279929-f2ca-48e5-815a-b812bfc2e756")," which were created between 2010 and 2020. The result bundle also includes the Patient, Provider, CareTeam and Coverage resources referenced by each matching ExplanationOfBenefit resource."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"    <base>/ExplanationOfBenefit?patient=Patient/17478598887-c1279929-f2ca-48e5-815a-b812bfc2e756&created=ge2010&created=lt2021&_include=ExplanationOfBenefit:patient&_include=ExplanationOfBenefit:provider&_include=ExplanationOfBenefit:care-team&_include=ExplanationOfBenefit:coverage\n")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"REVINCLUDE")),Object(i.b)("p",null,"Used when a client wants a particular resource and other resources pointing to it. For example, to retrieve a Patient resource and any Observations referring to that patient as the subject:"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"    <base>/Patient?_id=17478598887-c1279929-f2ca-48e5-815a-b812bfc2e756&_revinclude=Observation.subject\n")),Object(i.b)("p",null,"Find all Observations matching the composite code-value-quantity value and for each such Observation, also return any DiagnosticReport referring to that Observation as the result:"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"    <base>/Observation?code-value-quantity=http://loinc.org|2339-0$69.1&_revinclude=DiagnosticReport:result\n")),Object(i.b)("p",null,"The above query is likely to be expensive if the number of matching Observations is high. For better performance, consider constraining the search with additional predicates like the patient id."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"LAST UPDATED")),Object(i.b)("p",null,"Searching for all resources updated on a single day is expensive:"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"    <base>?_lastUpdated=2020-10-31\n")),Object(i.b)("p",null,"If possible, limit the search to a specific resource type. For example:"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"    <base>/Patient?_lastUpdated=2020-10-31\n")),Object(i.b)("p",null,"If multiple resource types are of interest, consider packaging multiple search requests into a bundle:"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),'{\n    "entry": [\n        {\n            "request": {\n                "method": "GET",\n                "url": "Patient?_lastUpdated=2020-10-31"\n            }\n        },\n        {\n            "request": {\n                "method": "GET",\n                "url": "Claim?_lastUpdated=2020-10-31"\n            }\n        },\n        {\n            "request": {\n                "method": "GET",\n                "url": "Practitioner?_lastUpdated=2020-10-31"\n            }\n        },\n        ...\n        {\n            "request": {\n                "method": "GET",\n                "url": "ExplanationOfBenefit?_lastUpdated=2020-10-31"\n            }\n        }\n    ],\n    "resourceType": "Bundle",\n    "type": "transaction"\n}\n')),Object(i.b)("h2",null,"6 Tools"),Object(i.b)("h2",null,"6.1 Making FHIR Requests With curl"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"curl -k -i \\\n-H 'Content-Type: application/json' \\\n-H 'X-FHIR-TENANT-ID: default' \\\n-u 'fhiruser:change-password' 'https://localhost:9443/fhir-server/api/v4/Practitioner/1749321b933-9fd77253-7fd4-47db-8ff8-9e4ccb21441d'\n")),Object(i.b)("p",null,"Note that the tenant header must match the tenant header defined in the fhir-server-config.json. The default tenant header is ",Object(i.b)("inlineCode",{parentName:"p"},"X-FHIR-TENANT-ID"),". If this header is not provided, the tenant value will be ",Object(i.b)("inlineCode",{parentName:"p"},"default"),"."),Object(i.b)("p",null,"The curl command can also be used to make POST calls to the IBM FHIR Server. This example creates a new Observation resource for the patient subject ",Object(i.b)("inlineCode",{parentName:"p"},"abc123"),":"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),'curl -k -i \\\n-H \'Content-Type: application/json\' \\\n-H \'X-FHIR-TENANT-ID: default\' \\\n-u \'fhiruser:change-password\' \'https://localhost:9443/fhir-server/api/v4/Observation\' -d \'\n{\n    "resourceType": "Observation",\n    "subject": {\n        "reference": "Patient/abc123"\n    },\n    "status": "final",\n    "code": {\n        "coding": [{\n            "system": "http://snomed.info/sct",\n            "code": "363779003",\n            "display": "Genotype determination"\n        }],\n        "text": "Diplotype Call"\n    },\n"text": {\n    "status": "generated",\n    "div": "__redacted for brevity__"\n  }\n}\n\'\n')),Object(i.b)("p",null,"Examples of valid resources can be found in the ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/IBM/FHIR/tree/master/fhir-examples"}),"fhir-examples")," project."),Object(i.b)("h2",null,"6.2 Making FHIR Requests with IBM FHIR Server Client"),Object(i.b)("p",null,"See FHIR client API in the ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"https://ibm.github.io/FHIR/guides/FHIRServerUsersGuide"}),"IBM FHIR Server User’s Guide"),"."))}b.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-guides-fhir-performance-guide-md-b70d52165fbf1f6c9c09.js.map